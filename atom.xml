<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>睡到自然醒</title>
  
  <subtitle>Do what you love,Love what you do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lishaojie.top/"/>
  <updated>2020-03-11T14:15:12.236Z</updated>
  <id>https://www.lishaojie.top/</id>
  
  <author>
    <name>lishaojie-C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java锁-Sync&amp;Lock</title>
    <link href="https://www.lishaojie.top/2020/02/29/lock/"/>
    <id>https://www.lishaojie.top/2020/02/29/lock/</id>
    <published>2020-02-29T10:35:17.000Z</published>
    <updated>2020-03-11T14:15:12.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="公平锁｜非公平锁"><a href="#公平锁｜非公平锁" class="headerlink" title="公平锁｜非公平锁"></a>公平锁｜非公平锁</h2><p><strong>公平锁</strong>：是指多个线程按照申请锁的顺序来获取锁，性能下降，但是顺序得到保障，讲究先来后到。</p><p><strong>非公平锁</strong>：是指多个线程获取锁的顺序并不是按照申请锁的顺序，先抢先得，抢不到再排队。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//可重入锁的空构造方法默认使用ReentrantLock(false)</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有boolean类型参数的构造方法,fair=true为公平锁，false为不公平锁</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>  sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<strong>ReentrantLock</strong>而言，可以通过构造函数指定该锁是公平锁还是非公平锁，默认无参构造是非公平锁。非公平锁的优点在于吞吐量比公平锁大，缺点是在高并发的情况下，有可能造成<strong>优先级反转</strong>或者<strong>饥饿现象</strong>。</p><p>对于<strong>Synchronized</strong>而言，也是一种<strong>非公平锁</strong>，根据优先级高低来占有锁。<a id="more"></a></p><h2 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁-SpinLock"></a>自旋锁-SpinLock</h2><p>详细请参考我的上一篇博客：<a href="https://lishaojie1993.gitee.io/2020/02/21/SpinLock/" target="_blank" rel="noopener">自旋锁-SpinLock</a></p><h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁/递归锁"></a>可重入锁/递归锁</h2><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程外层方法获取锁的时候，在进入内层方法会自动获取锁。也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p><p><strong>ReentrantLock</strong>和<strong>Synchronized</strong>都是可重入锁，可重入锁的最大作用在于避免死锁。</p><ul><li><p><strong>Synchronized实现原理</strong></p><p>每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁并调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p></li><li><p><strong>ReentrantLock实现原理</strong></p><p>主要利用了AQS，简单可理解为：</p><pre class="line-numbers language-java"><code class="language-java">lock aqs<span class="token punctuation">{</span>  自旋  <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  CAS<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>详细请参考我的上一篇博客：<a href="https://lishaojie1993.gitee.io/2020/02/23/AQS/" target="_blank" rel="noopener">ReentrantLock源码解析-AQS</a></p><h2 id="独占锁｜共享锁"><a href="#独占锁｜共享锁" class="headerlink" title="独占锁｜共享锁"></a>独占锁｜共享锁</h2><p><strong>独占锁</strong>：也叫<strong>写锁</strong>，该锁一次只能被一个线程锁持有。ReentrantLock和Synchronized都是独占锁。</p><p><strong>共享锁</strong>：也叫<strong>读锁</strong>，该锁可被多个线程同时持有。ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁。共享锁可保证并发读诗非常高效的，读写，写读，写写的过程是互斥的。</p><p><strong>读写锁Demo</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantReadWriteLock<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ReentrantReadWriteLock rwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 写方法，包含写锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t writing..."</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t finish writing!"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 读方法，包含读锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t reading..."</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            Object result <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t finish reading!"</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 线程操纵类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyCache myCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tempInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">,</span>tempInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tempInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//1     writing...1</span><span class="token comment" spellcheck="true">//1     finish writing!1</span><span class="token comment" spellcheck="true">//2     writing...2</span><span class="token comment" spellcheck="true">//2     finish writing!2</span><span class="token comment" spellcheck="true">//3     writing...3</span><span class="token comment" spellcheck="true">//3     finish writing!3</span><span class="token comment" spellcheck="true">//4     writing...4</span><span class="token comment" spellcheck="true">//4     finish writing!4</span><span class="token comment" spellcheck="true">//5     writing...5</span><span class="token comment" spellcheck="true">//5     finish writing!5</span><span class="token comment" spellcheck="true">//1     reading...1</span><span class="token comment" spellcheck="true">//1     finish reading!1</span><span class="token comment" spellcheck="true">//3     reading...3</span><span class="token comment" spellcheck="true">//5     reading...5</span><span class="token comment" spellcheck="true">//5     finish reading!5</span><span class="token comment" spellcheck="true">//4     reading...4</span><span class="token comment" spellcheck="true">//2     reading...2</span><span class="token comment" spellcheck="true">//2     finish reading!2</span><span class="token comment" spellcheck="true">//4     finish reading!4</span><span class="token comment" spellcheck="true">//3     finish reading!3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉它们都将无法推进下去。如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci5y7k0boj30q60ce7cy.jpg" style="zoom:50%;"><h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ol><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ol><h3 id="手写一个死锁"><a href="#手写一个死锁" class="headerlink" title="手写一个死锁"></a>手写一个死锁</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HoldLockThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockA<span class="token punctuation">;</span>    <span class="token keyword">private</span> String lockB<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HoldLockThread</span><span class="token punctuation">(</span>String lockA<span class="token punctuation">,</span> String lockB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockA <span class="token operator">=</span> lockA<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockB <span class="token operator">=</span> lockB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 自己持有："</span> <span class="token operator">+</span> lockA <span class="token operator">+</span> <span class="token string">"\t 尝试获得："</span> <span class="token operator">+</span> lockB<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 自己持有："</span> <span class="token operator">+</span> lockB <span class="token operator">+</span> <span class="token string">"\t 尝试获得："</span> <span class="token operator">+</span> lockA<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String lockA <span class="token operator">=</span> <span class="token string">"lockA"</span><span class="token punctuation">;</span>        String lockB <span class="token operator">=</span> <span class="token string">"lockB"</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HoldLockThread</span><span class="token punctuation">(</span>lockA<span class="token punctuation">,</span> lockB<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HoldLockThread</span><span class="token punctuation">(</span>lockB<span class="token punctuation">,</span> lockA<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h3><h4 id="jps命令定位进程号"><a href="#jps命令定位进程号" class="headerlink" title="jps命令定位进程号"></a>jps命令定位进程号</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci6pdzjljj30jo05wtbm.jpg" alt></p><h4 id="jstack找到死锁查看"><a href="#jstack找到死锁查看" class="headerlink" title="jstack找到死锁查看"></a>jstack找到死锁查看</h4><p> <strong>jstack 23576</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci6qzpnwcj30ug0eetjr.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;公平锁｜非公平锁&quot;&gt;&lt;a href=&quot;#公平锁｜非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁｜非公平锁&quot;&gt;&lt;/a&gt;公平锁｜非公平锁&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;公平锁&lt;/strong&gt;：是指多个线程按照申请锁的顺序来获取锁，性能下降，但是顺序得到保障，讲究先来后到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非公平锁&lt;/strong&gt;：是指多个线程获取锁的顺序并不是按照申请锁的顺序，先抢先得，抢不到再排队。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//可重入锁的空构造方法默认使用ReentrantLock(false)
public ReentrantLock() {
  sync = new NonfairSync();
}
//有boolean类型参数的构造方法,fair=true为公平锁，false为不公平锁
public ReentrantLock(boolean fair) {
  sync = fair ? new FairSync() : new NonfairSync();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;strong&gt;ReentrantLock&lt;/strong&gt;而言，可以通过构造函数指定该锁是公平锁还是非公平锁，默认无参构造是非公平锁。非公平锁的优点在于吞吐量比公平锁大，缺点是在高并发的情况下，有可能造成&lt;strong&gt;优先级反转&lt;/strong&gt;或者&lt;strong&gt;饥饿现象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;Synchronized&lt;/strong&gt;而言，也是一种&lt;strong&gt;非公平锁&lt;/strong&gt;，根据优先级高低来占有锁。
    
    </summary>
    
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="lock" scheme="https://www.lishaojie.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock源码-AQS</title>
    <link href="https://www.lishaojie.top/2020/02/23/AQS/"/>
    <id>https://www.lishaojie.top/2020/02/23/AQS/</id>
    <published>2020-02-23T15:26:00.000Z</published>
    <updated>2020-03-11T14:12:58.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReentrantLock源码解析"><a href="#ReentrantLock源码解析" class="headerlink" title="ReentrantLock源码解析"></a>ReentrantLock源码解析</h2><h3 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队首</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队尾</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//锁状态，加锁成功则为1，重入+1，解锁为0</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//持有锁的线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Node类的设计"><a href="#Node类的设计" class="headerlink" title="Node类的设计"></a>Node类的设计</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>  <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="AQS队列示意图"><a href="#AQS队列示意图" class="headerlink" title="AQS队列示意图"></a>AQS队列示意图</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcp98gjlqoj30vk0iu42b.jpg" alt></p><h3 id="ReentrantLock简单应用"><a href="#ReentrantLock简单应用" class="headerlink" title="ReentrantLock简单应用"></a>ReentrantLock简单应用</h3><pre class="line-numbers language-java"><code class="language-java">ReentrantLock reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//源码如下（有两种实现类）</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略代码逻辑……</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="公平锁｜非公平锁"><a href="#公平锁｜非公平锁" class="headerlink" title="公平锁｜非公平锁"></a>公平锁｜非公平锁</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加锁成功之后改变的值</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>公平锁的上锁必须判断自己需不需要排队；而非公平锁是直接进行CAS修改计数器看能不能加锁成功；如果加锁不成功则乖乖排队(调用acquire)；所以不管公平还是不公平；只要进到了AQS队列当中那么就会排队。</p></blockquote><h2 id="acquire-方法源码分析"><a href="#acquire-方法源码分析" class="headerlink" title="acquire()方法源码分析"></a>acquire()方法源码分析</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">//①</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//②③</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//①tryAcquire()：尝试加锁，如果加锁失败就会调用acquireQueued()去排队，加锁成功就不会。</span><span class="token comment" spellcheck="true">//②addWaiter()：判断队列是否需要初始化，并把当前线程节点放入阻塞队列。</span><span class="token comment" spellcheck="true">//③acquireQueued()：当前线程如果排在第一位会请求获取锁，否则入队睡眠阻塞，后续线程修改睡眠状态，等待被唤醒。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="①tryAcquire"><a href="#①tryAcquire" class="headerlink" title="①tryAcquire()"></a>①tryAcquire()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前线程</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取lock对象的状态c=0自由态，如果被上锁则为1，大于1是重入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token comment" spellcheck="true">//这里涉及到的情况比较多，下面详细讨论</span>            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置持有锁的线程是自己</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果C不等于0，判断当前线程是否为拥有锁的线程，如果不是则直接返回false，加锁失败。</span>    <span class="token comment" spellcheck="true">//如果是拥有锁的线程，则状态+1代表重入次数+1，返回true加锁成功。</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>    Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node s<span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">//这句代码涉及到的情况比较多，下面详细解释</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第一种情况：队列没有初始化，head和taill都为null，所以h!=t不成立，后面短路不执行，直接返回false。<br>而又因为前面取反：if (!hasQueuedPredecessors()…)，所以不需要排队，直接去CAS，改变计数器上锁。</p></blockquote><blockquote><p>第二种情况：队列已经初始化了，但是有且只有一个数据，即h==t且s==null，表达式后面不执行，同上返回false不排队。什么时候会出现这种情况：当排队的队尾拿到锁的时候，此时队列中有且只有一个节点，它会把自己设置为h。因为这个线程已经拿到锁了，它不参与排队，所以需要设置为头节点。</p></blockquote><blockquote><p>第三种情况：队列已经初始化了，有大于1的多个节点，h!=t成立，s=null不成立，所以还要运行 s.thread != Thread.currentThread()，这里又分为两种情况：</p><ol><li><p>s.thread != Thread.currentThread()为true，即排队的第一个线程不是当前线程，表达式整体返回true，需要排队。</p></li><li><p>s.thread != Thread.currentThread()为false，即排队的第一个线程就是当前线程，表达式整体返回false，不需要排队。</p><p>不需要排队则调用 compareAndSetState(0, acquires) 去改变计数器尝试上锁，这里还分为两种情况：</p><ol><li>第一种情况是加锁成功，即持有锁的线程释放了锁，继续执行setExclusiveOwnerThread(current)，返回true。</li><li>第二种情况是加锁失败，即持有锁的线程还没有释放锁，直接返回false。</li></ol></li></ol></blockquote><h3 id="②addWaiter"><a href="#②addWaiter" class="headerlink" title="②addWaiter()"></a>②addWaiter()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//因为AQS队列中的元素为Node，所以把当前线程封装为一个Node对象</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把队尾赋值给临时节点pred</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//队列不为空的流程很简单，直接修改指针把节点放入队列</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前线程节点指向原来的队尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//赋值操作，即队尾⇨当前节点</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//原来队尾节点的指针指向当前节点</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列为空，初始化队列并进行入队操作</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="enq"><a href="#enq" class="headerlink" title="enq()"></a>enq()</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//死循环    </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队尾赋值给临时节点t</span>        <span class="token comment" spellcheck="true">//第一次循环（初始化队列）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//队列为空，需要初始化队列</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//实例化一个属性都为空的Node对象</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列中只有一个对象，头尾都指向它</span>        <span class="token comment" spellcheck="true">//第二次循环（当前线程节点入队）</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//⑴</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//⑵</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//⑶</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面123代表的是维护链表，即当前线程节点的入队操作</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③acquireQueued"><a href="#③acquireQueued" class="headerlink" title="③acquireQueued()"></a>③acquireQueued()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把当前节点的上一个节点赋值给P</span>            <span class="token comment" spellcheck="true">//如果当前节点的前置节点是头节点，那么它会尝试去获取锁--自旋（第一个排队的）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//意图是尽量不睡眠，多询问一次</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//自旋获取锁失败后是否需要睡眠</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token comment" spellcheck="true">//给上一个节点修改状态</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//②当前线程调用park()阻塞</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取前置线程节点的状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断前置线程的状态是否为-1（已睡）</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳出方法后运行parkAndCheckInterrupt()当前线程睡眠</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//把前置节点的状态修改为-1，证明前置线程已睡</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳出方法后短路，再次自旋</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3><ol><li><p>原始构成</p><p><code>synchronized</code>是关键字，属于<strong>JVM层面</strong>。底层是通过<code>monitor</code>对象来完成，<code>wait/notify</code>方法也依赖<code>moniter</code>对象并且只有在同步块或者同步方法中才能使用<code>wait/notity</code>等方法。monitorenter｜<strong>monitorexit｜monitorexit 正常退出和异常退出</strong>，不会死锁。</p><p><strong>lock</strong>是具体的类<code>java.util.concurrent.locks.lock</code>属于<strong>API层面</strong>。</p></li><li><p>使用方法</p><p><code>synchronized</code><strong>不需要</strong>用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。</p><p><code>ReentrantLock</code><strong>需要</strong>用户去手动释放锁，如果没有主动释放锁就有可能导致死锁。需要<code>lock()</code>和<code>unlock()</code>配合<code>try/finally</code>来完成。</p></li><li><p>等待是否可中断</p><p><code>synchronized</code>不可中断，除非抛出异常或者正常运行完成。</p><p><code>ReentrantLock</code>可中断，相比synchronized更加灵活，有两种方式可以中断：</p><ul><li><p>设置超时方法<code>tryLock(long timeout,TimeUnit unit)</code></p></li><li><p><code>lockInterRuptibly()</code>放代码块中，调用<code>interrupt()</code>方法可中断。</p></li></ul></li><li><p>加锁是否公平</p><p><code>synchronized</code>是非公平锁。</p><p><code>ReentrantLock</code>两者都可以，默认非公平锁。构造方法可以传入boolean值，<strong>true</strong>为公平锁，<strong>false</strong>为非公平锁。</p></li><li><p>是否可绑定多个条件-<code>Condition</code></p><p><code>synchronized</code>不可以，要么随机唤醒一个线程，要么全部唤醒。</p><p><code>ReentrantLock</code>可以实现分组唤醒，达到精确唤醒。</p></li></ol><p>扩展：jdk1.6以前，如果线程是交替执行的话，Synchronized会调用OS函数，影响性能。ReentrantLock的交替执行是在jdk级别解决的，性能很快。如果是竞争执行的话会进入队列调用park()方法。1.8以后区别很小，ReentrantLock的API更丰富一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ReentrantLock源码解析&quot;&gt;&lt;a href=&quot;#ReentrantLock源码解析&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock源码解析&quot;&gt;&lt;/a&gt;ReentrantLock源码解析&lt;/h2&gt;&lt;h3 id=&quot;AQS（A
      
    
    </summary>
    
    
    
      <category term="Lock" scheme="https://www.lishaojie.top/tags/Lock/"/>
    
      <category term="ReentrantLock" scheme="https://www.lishaojie.top/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁-SpinLock</title>
    <link href="https://www.lishaojie.top/2020/02/21/SpinLock/"/>
    <id>https://www.lishaojie.top/2020/02/21/SpinLock/</id>
    <published>2020-02-21T15:18:15.000Z</published>
    <updated>2020-03-11T14:22:26.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁-SpinLock"></a>自旋锁-SpinLock</h2><p>指的是尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。</p><h3 id="自旋实现同步"><a href="#自旋实现同步" class="headerlink" title="自旋实现同步"></a>自旋实现同步</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//标识，锁是否被线程占用</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> except<span class="token punctuation">,</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//CAS操作，修改status成功则返回true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作。</p><p>解决思路：让得不到锁的线程让出CPU。</p></blockquote><h3 id="yield-自旋"><a href="#yield-自旋" class="headerlink" title="yield()+自旋"></a>yield()+自旋</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自己实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>yield()方法能让出cpu资源，当线程竞争锁失败时，会调用yield方法让出cpu。不过自旋+yield的方式并没有完全解决问题，当系统只有两个线程竞争锁时，yield是有效的。</p><p>缺点：该方法只是当前让出cpu，有可能操作系统下次还是选择运行该线程，如果线程过多的话还是看不到很好的效果。</p></blockquote><h3 id="sleep-自旋"><a href="#sleep-自旋" class="headerlink" title="sleep()+自旋"></a>sleep()+自旋</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>缺点：睡多久是个问题，睡的短了还是会循环，睡的久了浪费时间。</p></blockquote><h3 id="park-自旋"><a href="#park-自旋" class="headerlink" title="park()+自旋"></a>park()+自旋</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//占用锁20s</span>  <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//将当前线程加入到等待队列</span>  parkQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将当前线程释放CPU</span>  <span class="token function">releaseCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">lock_notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">lock_notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//得到要唤醒的线程（队列的头部）</span>  Thread t <span class="token operator">=</span> parkQueue<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//唤醒等待线程</span>  <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//unpark()是UnSafe类的方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>park()+自旋的方式比较完美，ReentrantLock类的原理就是利用了这种机制。</p></blockquote><h3 id="自旋锁Demo"><a href="#自旋锁Demo" class="headerlink" title="自旋锁Demo"></a>自旋锁Demo</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpinLockDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 原子引用线程</span>    AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> atomicReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t invoked myLock()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 自旋（有线程先获取锁时循环等待）</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 释放锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t invoked myUnLock()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 线程操纵类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpinLockDemo spinLockDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpinLockDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建t1线程获取锁，持有5秒后释放锁</span>          <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//延迟1秒，保证t1线程先启动</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后创建t2线程，尝试获取锁</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自旋锁-SpinLock&quot;&gt;&lt;a href=&quot;#自旋锁-SpinLock&quot; class=&quot;headerlink&quot; title=&quot;自旋锁-SpinLock&quot;&gt;&lt;/a&gt;自旋锁-SpinLock&lt;/h2&gt;&lt;p&gt;指的是尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试
      
    
    </summary>
    
    
    
      <category term="Lock" scheme="https://www.lishaojie.top/tags/Lock/"/>
    
      <category term="SpinLock" scheme="https://www.lishaojie.top/tags/SpinLock/"/>
    
  </entry>
  
  <entry>
    <title>线程池实现原理与源码分析</title>
    <link href="https://www.lishaojie.top/2020/02/19/Thread-Pool/"/>
    <id>https://www.lishaojie.top/2020/02/19/Thread-Pool/</id>
    <published>2020-02-19T13:26:44.000Z</published>
    <updated>2020-03-11T14:20:53.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们常见的创建线程的方式有两种：继承Thread类和实现Runnable接口，后者用的多一些。</p><p>在这里我们详细介绍另外2两种通过调用API创建线程的方式。</p><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式： 实现 Callable 接口。</p><p>Callable 接口类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出经过检查的异常，而 Callable 依赖 FutureTask 类获取返回结果。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>FutureTask<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t come in Callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 逻辑代码</span>        <span class="token keyword">return</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// t1，t2线程公用一个futureTask不可行，需要再创建</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//new Thread(futureTask,"t2").start();</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask2<span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// futureTask.get()获得Callable线程的计算结果，尽量放在后面，会阻塞线程的运行</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当某个请求需要在后端完成 N 次统计结果时，我们就可以使用该方式创建 N 个线程进行（并行）统计，而不需要同步等待其他统计操作完成后才统计另一个结果。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是通过Executor框架实现的，该框架用到了Executor、Executors、ExecutorService、<strong>ThreadPoolExecutor</strong>这几个类。</p><p>线程池的特点：线程复用、控制最大并发数、管理线程。</p><h3 id="线程池的架构"><a href="#线程池的架构" class="headerlink" title="线程池的架构"></a>线程池的架构</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gchx17f5qsj30pu0kktjt.jpg" alt></p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="三个简单线程池"><a href="#三个简单线程池" class="headerlink" title="三个简单线程池"></a>三个简单线程池</h3><ul><li>newFixedThreadPool：执行长期的任务，性能好很多。</li><li>newSingleThreadExecutor：一个任务一个任务的执行。</li><li>newCachedThreadPool：执行很多短期异步的小程序或者负载较轻的服务器。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 一池5个工作线程（固定）</span><span class="token comment" spellcheck="true">//        ExecutorService executorService = Executors.newSingleThreadExecutor();// 一池1个工作线程</span><span class="token comment" spellcheck="true">//        ExecutorService executorService = Executors.newCachedThreadPool();//一池N个工作线程</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 办理业务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法一览"><a href="#构造方法一览" class="headerlink" title="构造方法一览"></a>构造方法一览</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span><span class="token comment" spellcheck="true">//corePoolSize和maximumPoolSize是相等的，使用的是LinkedBlockingQueue</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定的顺序执行。</span><span class="token comment" spellcheck="true">//corePoolSize和maximumPoolSize都是1，使用的是LinkedBlockingQueue</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个可缓存的线程池，如果线程池的长度超过处理需要，可灵活回收空闲线程，若无可收回则新建线程执行。</span><span class="token comment" spellcheck="true">//corePoolSize是0，maximumPoolSize为Integer.MAX_VALUE，使用的是SynchronousQueue</span><span class="token comment" spellcheck="true">//有任务就创建线程运行，当线程空闲超过60秒就销毁线程。</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span>   <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>   <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                                    <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>   TimeUnit unit<span class="token punctuation">,</span>   BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>   ThreadFactory threadFactory<span class="token punctuation">,</span>   RejectedExecutionHandler handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci3qd3bcpj315s0u0kjl.jpg" style="zoom: 33%;"><ol><li><p><code>corePoolSize</code>（<strong>线程池的常驻大小</strong>）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p><code>maximumPoolSize</code>（<strong>线程池最大数量</strong>）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p><code>keepAliveTime</code>（<strong>多余空闲线程存活时间</strong>）：线程池的工作线程空闲后，保持存活的时间。线程空闲时间超过设置的存活时间后，线程池会判断当前运行的线程数是否大于corePoolSize，如果大于就会销毁多余的空闲线程，直到只剩下corePoolSize个线程为止。如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li><li><p><code>TimeUnit</code>（<strong>keepAliveTime的单位</strong>）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p></li><li><p><code>BlockingQueue</code>（<strong>阻塞队列</strong>）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p></li><li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p></li><li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p></li></ul></li><li><p><code>ThreadFactory</code>（<strong>线程工厂</strong>）：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。一般用默认，也可以使用开源框架guava提供的ThreadFactoryBuilder快速给线程池里的线程设置有意义的名字，代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"XX-task-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>RejectedExecutionHandler</code>（<strong>饱和策略</strong>）：当阻塞队列和最大线程数都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p><ul><li>AbortPolicy：直接抛出RejectedExecutionException异常。(默认，执行任务最少，最不友好)</li><li>CallerRunsPolicy：将任务分给调用线程来执行（如main线程，执行任务数最多）。</li><li>DiscardOldestPolicy：丢弃队列里等待最久的任务，并执行当前任务（相比DiscardPolicy丢弃的少）。</li><li>DiscardPolicy：丢弃当前任务，不处理（丢掉的任务最多）。</li></ul></li></ol><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 注意阻塞队列的范围和拒绝策略的选择 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 1L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 办理业务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-4     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-5     办理业务</span><span class="token comment" spellcheck="true">//main     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-4     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//main     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-5     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-4     办理业务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合理配置线程数"><a href="#合理配置线程数" class="headerlink" title="合理配置线程数"></a>合理配置线程数</h3><ol><li><p>CPU密集型</p><p>意思是该任务需要大量的运算，没有阻塞，CPU一直全速运行。一般公式：CPU核数+1个线程的线程池。</p><p>运行System.out.println(Runtime.getRuntime().availableProcessors());查看CPU核数（线程数）。</p></li><li><p>IO密集型（有两种，自己到测试/生产环境试验）</p><ul><li><p>意思是该任务并不是一直在执行，可以配置尽可能多的线程，比如CPU核数*2。</p></li><li><p>IO密集时，大量的线程都在阻塞，参考公式：CPU/(1-阻塞系数)=8/(1-0.9)=80个线程。</p></li></ul></li></ol><hr><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为<code>execute()</code>和<code>submit()</code>方法。</p><ul><li><code>execute()</code>方法用于提交<strong>不需要返回值</strong>的任务;</li><li><code>submit()</code>方法用于提交<strong>需要返回值</strong>的任务。</li></ul><p><code>execute()</code>：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过源码可知<code>execute()</code>方法输入的任务是一个Runnable类的实例。</p><pre class="line-numbers language-java"><code class="language-java">threadsPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>submit()</code>：线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用<code>get(long timeout,TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><pre class="line-numbers language-java"><code class="language-java">Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>haveReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    Object s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理中断异常</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理无法执行任务异常</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关闭线程池</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul><li><code>shutdown()</code></li><li><code>shutdownNow()</code></li></ul><p>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt()</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，<code>isShutdown()</code>方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed()</code>方法会返回true。</p><p>区别：</p><p><code>shutdownNow()</code>首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而<code>shutdown()</code>只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>总结：</p><p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调<code>shutdown()</code>方法来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow()</code>方法。</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ol><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<a id="more"></a></li></ol><p>对应到代码层面就是<code>ThreadPoolExecutor</code>执行<code>execute()</code>方法</p><ol><li>当<kbd>workerCount</kbd> &lt; <kbd>corePoolSize</kbd>，创建新线程执行任务。</li><li>当<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> &lt; <kbd>maximumPoolSize</kbd>，创建新线程执行任务。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。</li></ol><p>由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p><h3 id="线程池状态转换模型"><a href="#线程池状态转换模型" class="headerlink" title="线程池状态转换模型"></a>线程池状态转换模型</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg" alt></p><ul><li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li><li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li><li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li><li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li><li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li></ul><h2 id="线程池源码分析"><a href="#线程池源码分析" class="headerlink" title="线程池源码分析"></a>线程池源码分析</h2><p><strong>基于JDK1.8</strong></p><h3 id="ctl-变量"><a href="#ctl-变量" class="headerlink" title="ctl 变量"></a>ctl 变量</h3><p>后面<code>execute()</code>方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Packing and unpacking ctl</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><ul><li><code>if (! isRunning(recheck) &amp;&amp; remove(command))</code>这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。</li><li><code>addWorker(command, false)</code>：我们看到有<code>addWorker(command, true)</code>和<code>addWorker(command, false)</code>。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用<code>addWorker(command, true)</code>。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//如果提交了空的任务 抛出异常</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前线程池的状态</span>   <span class="token comment" spellcheck="true">//检查当前工作线程数量是否小于核心线程数量</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//通过addWorker方法提交任务</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">return</span><span class="token punctuation">;</span>   c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果提交失败 需要二次检查状态</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//向工作线程提交任务 </span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 再次检查状态</span>      <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//扩容失败 则拒绝任务</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker()方法"></a>addWorker()方法</h3><p>这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。</p><p>这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>       retry<span class="token operator">:</span>   <span class="token comment" spellcheck="true">//死循环更新状态</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取运行状态</span>       <span class="token comment" spellcheck="true">//检查线程池是否处于关闭状态</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                  firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                  <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//获取当前工作线程数量</span>               <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果已经超过corePoolSize获取maximumPoolSize 返回false</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                   wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//CAS增加一个工作线程</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//再次获取状态</span>               c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>       <span class="token comment" spellcheck="true">//如果状态更新失败 则循环更新</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                   <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>           w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化一个工作线程</span>           <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获得锁</span>               <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>               mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                   <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                   <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                   <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                       <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//添加工作这到hashset中保存</span>                       workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                           largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                       workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                   mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//工作线程启动 执行第一个任务 就是新提交的任务</span>                   t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>               <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker的构造方法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */</span><span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker()方法"></a>runWorker()方法</h3><p>在<code>addWorker()</code>方法快要结束的地方，调用了<code>t.start()</code>方法，我们知道它实际执行的就是Worker对象的<code>run()</code>方法，而worker的<code>run()</code>方法是这样定义的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它实际上是将自己委托给线程池的runWorker方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//不断地从blockingQueue获取任务</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>               w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// If pool is stopping, ensure thread is interrupted;</span>               <span class="token comment" spellcheck="true">// if not, ensure thread is not interrupted.  This</span>               <span class="token comment" spellcheck="true">// requires a recheck in second case to deal with</span>               <span class="token comment" spellcheck="true">// shutdownNow race while clearing interrupt</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                     <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                   <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//执行beforeExecute方法</span>                   <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                   Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                   <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//调用Runable的run方法</span>                       task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 执行aferExecute方法</span>                       <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                   task <span class="token operator">=</span> null<span class="token punctuation">;</span>                   w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                   w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下<code>runWorker(Worker w)</code>方法的执行过程：</p><ol><li>while循环中，不断地通过<code>getTask()</code>方法从workerQueue中获取任务</li><li>如果线程池正在停止，则中断线程。否则调用3.</li><li>调用<code>task.run()</code>执行任务；</li><li>如果task为null则跳出循环，执行<code>processWorkerExit()</code>方法，销毁线程<code>workers.remove(w)</code>;</li></ol><p>它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。</p><h2 id="ExecutorService详解"><a href="#ExecutorService详解" class="headerlink" title="ExecutorService详解"></a>ExecutorService详解</h2><p><strong>创建线程池的5个方法：</strong></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>只有一个线程的线程池，因此所有提交的任务是<strong>顺序执行</strong>。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</p><p>返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><hr><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最少数量</span>                Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>                60L<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间，60秒</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">",执行第 "</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：3，执行第 1 次线程ID：4，执行第 1 次线程ID：2，执行第 1 次线程ID：5，执行第 1 次线程ID：1，执行第 1 次线程ID：2，执行第 2 次线程ID：3，执行第 2 次线程ID：4，执行第 2 次线程ID：1，执行第 2 次线程ID：5，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 3 次线程ID：4，执行第 3 次线程ID：5，执行第 3 次线程ID：1，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到执行结果是5个任务在交替进行的</p><p>newCachedThreadPool的总结：</p><ol><li>重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。</li><li>使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。</li><li>超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。</li><li>结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</li></ol><hr><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService fixedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码：有两个重载方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                nThreads<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最少数量</span>                nThreads<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>                0L<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService exe <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID <span class="token operator">=</span> i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span> <span class="token operator">+</span> taskID <span class="token operator">+</span> <span class="token string">"，执行第 "</span> <span class="token operator">+</span> j <span class="token operator">+</span> <span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：2，执行第 1 次线程ID：1，执行第 1 次线程ID：3，执行第 1 次线程ID：2，执行第 2 次线程ID：3，执行第 2 次线程ID：1，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 3 次线程ID：1，执行第 3 次线程ID：4，执行第 1 次线程ID：5，执行第 1 次线程ID：4，执行第 2 次线程ID：5，执行第 2 次线程ID：4，执行第 3 次线程ID：5，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。<br>newFixedThreadPool的总结：</p><ol><li>重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。</li><li>固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li><li>超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。</li><li>使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。</li></ol><hr><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p><pre class="line-numbers language-java"><code class="language-java">ScheduledExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程池维护线程的最少数量</span>        Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程池维护线程所允许的空闲时间</span>        NANOSECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>        <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ScheduledExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>                exe<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">",时间："</span><span class="token operator">+</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 执行一次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：</p><pre class="line-numbers language-xml"><code class="language-xml">线程：1,时间：2016-12-11T13:09:18.544 执行一次线程：2,时间：2016-12-11T13:09:18.544 执行一次线程：3,时间：2016-12-11T13:09:18.544 执行一次线程：5,时间：2016-12-11T13:09:20.557 执行一次线程：1,时间：2016-12-11T13:09:20.557 执行一次线程：4,时间：2016-12-11T13:09:20.557 执行一次线程：4,时间：2016-12-11T13:09:22.572 执行一次线程：2,时间：2016-12-11T13:09:22.572 执行一次线程：3,时间：2016-12-11T13:09:22.572 执行一次线程：5,时间：2016-12-11T13:09:24.586 执行一次线程：1,时间：2016-12-11T13:09:24.586 执行一次线程：2,时间：2016-12-11T13:09:24.586 执行一次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。</p><hr><h3 id="newSingleThreadScheduledPool"><a href="#newSingleThreadScheduledPool" class="headerlink" title="newSingleThreadScheduledPool"></a>newSingleThreadScheduledPool</h3><p>单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">"，执行第 "</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：1，执行第 1 次线程ID：1，执行第 2 次线程ID：1，执行第 3 次线程ID：2，执行第 1 次线程ID：2，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 1 次线程ID：3，执行第 2 次线程ID：3，执行第 3 次线程ID：4，执行第 1 次线程ID：4，执行第 2 次线程ID：4，执行第 3 次线程ID：5，执行第 1 次线程ID：5，执行第 2 次线程ID：5，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个结果都是相隔0.5秒打印出来的，顺序执行下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们常见的创建线程的方式有两种：继承Thread类和实现Runnable接口，后者用的多一些。&lt;/p&gt;
&lt;p&gt;在这里我们详细介绍另外2两种通过调用API创建线程的方式。&lt;/p&gt;
&lt;h3 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h3&gt;&lt;p&gt;Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式： 实现 Callable 接口。&lt;/p&gt;
&lt;p&gt;Callable 接口类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出经过检查的异常，而 Callable 依赖 FutureTask 类获取返回结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyThread implements Callable&amp;lt;Integer&amp;gt; {

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName()+&amp;quot;\t come in Callable&amp;quot;);
          // 逻辑代码
        return 1024;
    }
}

public class CallableDemo {
    public static void main(String[] args) throws Exception{
        FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;Integer&amp;gt;(new MyThread());
        FutureTask&amp;lt;Integer&amp;gt; futureTask2 = new FutureTask&amp;lt;Integer&amp;gt;(new MyThread());
        // t1，t2线程公用一个futureTask不可行，需要再创建
        new Thread(futureTask,&amp;quot;t1&amp;quot;).start();
        //new Thread(futureTask,&amp;quot;t2&amp;quot;).start();
        new Thread(futureTask2,&amp;quot;t2&amp;quot;).start();
        // futureTask.get()获得Callable线程的计算结果，尽量放在后面，会阻塞线程的运行
        int result = futureTask.get();
        System.out.println(result);
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当某个请求需要在后端完成 N 次统计结果时，我们就可以使用该方式创建 N 个线程进行（并行）统计，而不需要同步等待其他统计操作完成后才统计另一个结果。&lt;/p&gt;
&lt;h3 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h3&gt;&lt;p&gt;线程池是通过Executor框架实现的，该框架用到了Executor、Executors、ExecutorService、&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;这几个类。&lt;/p&gt;
&lt;p&gt;线程池的特点：线程复用、控制最大并发数、管理线程。&lt;/p&gt;
&lt;h3 id=&quot;线程池的架构&quot;&gt;&lt;a href=&quot;#线程池的架构&quot; class=&quot;headerlink&quot; title=&quot;线程池的架构&quot;&gt;&lt;/a&gt;线程池的架构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif&quot; data-original=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gchx17f5qsj30pu0kktjt.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程池的使用&quot;&gt;&lt;a href=&quot;#线程池的使用&quot; class=&quot;headerlink&quot; title=&quot;线程池的使用&quot;&gt;&lt;/a&gt;线程池的使用&lt;/h2&gt;&lt;h3 id=&quot;三个简单线程池&quot;&gt;&lt;a href=&quot;#三个简单线程池&quot; class=&quot;headerlink&quot; title=&quot;三个简单线程池&quot;&gt;&lt;/a&gt;三个简单线程池&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;newFixedThreadPool：执行长期的任务，性能好很多。&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor：一个任务一个任务的执行。&lt;/li&gt;
&lt;li&gt;newCachedThreadPool：执行很多短期异步的小程序或者负载较轻的服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MyThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);// 一池5个工作线程（固定）
//        ExecutorService executorService = Executors.newSingleThreadExecutor();// 一池1个工作线程
//        ExecutorService executorService = Executors.newCachedThreadPool();//一池N个工作线程
        try {
            for (int i = 1; i &amp;lt;= 5; i++) {
                executorService.execute(() -&amp;gt; {
                    System.out.println(Thread.currentThread().getName() + &amp;quot;\t 办理业务&amp;quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executorService.shutdown();
        }
    }
}
//运行结果如下：
//pool-1-thread-1     办理业务
//pool-1-thread-3     办理业务
//pool-1-thread-1     办理业务
//pool-1-thread-2     办理业务
//pool-1-thread-3     办理业务&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;构造方法一览&quot;&gt;&lt;a href=&quot;#构造方法一览&quot; class=&quot;headerlink&quot; title=&quot;构造方法一览&quot;&gt;&lt;/a&gt;构造方法一览&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待。
//corePoolSize和maximumPoolSize是相等的，使用的是LinkedBlockingQueue
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定的顺序执行。
//corePoolSize和maximumPoolSize都是1，使用的是LinkedBlockingQueue
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
    }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//创建一个可缓存的线程池，如果线程池的长度超过处理需要，可灵活回收空闲线程，若无可收回则新建线程执行。
//corePoolSize是0，maximumPoolSize为Integer.MAX_VALUE，使用的是SynchronousQueue
//有任务就创建线程运行，当线程空闲超过60秒就销毁线程。
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;线程池的七大参数&quot;&gt;&lt;a href=&quot;#线程池的七大参数&quot; class=&quot;headerlink&quot; title=&quot;线程池的七大参数&quot;&gt;&lt;/a&gt;线程池的七大参数&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public ThreadPoolExecutor(
   int corePoolSize,
   int maximumPoolSize,                              
      long keepAliveTime,
   TimeUnit unit,
   BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
   ThreadFactory threadFactory,
   RejectedExecutionHandler handler)&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif&quot; data-original=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gci3qd3bcpj315s0u0kjl.jpg&quot; style=&quot;zoom: 33%;&quot;&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;corePoolSize&lt;/code&gt;（&lt;strong&gt;线程池的常驻大小&lt;/strong&gt;）：当提交一个任务到线程池时，如果当前poolSize&amp;lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt;（&lt;strong&gt;线程池最大数量&lt;/strong&gt;）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;keepAliveTime&lt;/code&gt;（&lt;strong&gt;多余空闲线程存活时间&lt;/strong&gt;）：线程池的工作线程空闲后，保持存活的时间。线程空闲时间超过设置的存活时间后，线程池会判断当前运行的线程数是否大于corePoolSize，如果大于就会销毁多余的空闲线程，直到只剩下corePoolSize个线程为止。如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;TimeUnit&lt;/code&gt;（&lt;strong&gt;keepAliveTime的单位&lt;/strong&gt;）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BlockingQueue&lt;/code&gt;（&lt;strong&gt;阻塞队列&lt;/strong&gt;）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PriorityBlockingQueue：一个具有优先级的无限阻塞队列。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ThreadFactory&lt;/code&gt;（&lt;strong&gt;线程工厂&lt;/strong&gt;）：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。一般用默认，也可以使用开源框架guava提供的ThreadFactoryBuilder快速给线程池里的线程设置有意义的名字，代码如下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;new ThreadFactoryBuilder().setNameFormat(&amp;quot;XX-task-%d&amp;quot;).build();&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;RejectedExecutionHandler&lt;/code&gt;（&lt;strong&gt;饱和策略&lt;/strong&gt;）：当阻塞队列和最大线程数都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AbortPolicy：直接抛出RejectedExecutionException异常。(默认，执行任务最少，最不友好)&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：将任务分给调用线程来执行（如main线程，执行任务数最多）。&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃队列里等待最久的任务，并执行当前任务（相比DiscardPolicy丢弃的少）。&lt;/li&gt;
&lt;li&gt;DiscardPolicy：丢弃当前任务，不处理（丢掉的任务最多）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。&lt;/p&gt;
&lt;h3 id=&quot;自定义线程池&quot;&gt;&lt;a href=&quot;#自定义线程池&quot; class=&quot;headerlink&quot; title=&quot;自定义线程池&quot;&gt;&lt;/a&gt;自定义线程池&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;import java.util.concurrent.*;
/**
 * 注意阻塞队列的范围和拒绝策略的选择
 */
public class MyThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(2, 5, 1L, TimeUnit.SECONDS,
                new LinkedBlockingDeque&amp;lt;&amp;gt;(3), Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());
        try {
            for (int i = 1; i &amp;lt;= 20; i++) {
                threadPool.execute(() -&amp;gt; {
                    System.out.println(Thread.currentThread().getName() + &amp;quot;\t 办理业务&amp;quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
//运行结果如下
//pool-1-thread-1     办理业务
//pool-1-thread-2     办理业务
//pool-1-thread-1     办理业务
//pool-1-thread-3     办理业务
//pool-1-thread-2     办理业务
//pool-1-thread-1     办理业务
//pool-1-thread-3     办理业务
//pool-1-thread-3     办理业务
//pool-1-thread-2     办理业务
//pool-1-thread-4     办理业务
//pool-1-thread-5     办理业务
//main     办理业务
//pool-1-thread-1     办理业务
//pool-1-thread-4     办理业务
//pool-1-thread-2     办理业务
//main     办理业务
//pool-1-thread-3     办理业务
//pool-1-thread-5     办理业务
//pool-1-thread-1     办理业务
//pool-1-thread-4     办理业务&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;合理配置线程数&quot;&gt;&lt;a href=&quot;#合理配置线程数&quot; class=&quot;headerlink&quot; title=&quot;合理配置线程数&quot;&gt;&lt;/a&gt;合理配置线程数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CPU密集型&lt;/p&gt;
&lt;p&gt;意思是该任务需要大量的运算，没有阻塞，CPU一直全速运行。一般公式：CPU核数+1个线程的线程池。&lt;/p&gt;
&lt;p&gt;运行System.out.println(Runtime.getRuntime().availableProcessors());查看CPU核数（线程数）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IO密集型（有两种，自己到测试/生产环境试验）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;意思是该任务并不是一直在执行，可以配置尽可能多的线程，比如CPU核数*2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IO密集时，大量的线程都在阻塞，参考公式：CPU/(1-阻塞系数)=8/(1-0.9)=80个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;向线程池提交任务&quot;&gt;&lt;a href=&quot;#向线程池提交任务&quot; class=&quot;headerlink&quot; title=&quot;向线程池提交任务&quot;&gt;&lt;/a&gt;向线程池提交任务&lt;/h3&gt;&lt;p&gt;可以使用两个方法向线程池提交任务，分别为&lt;code&gt;execute()&lt;/code&gt;和&lt;code&gt;submit()&lt;/code&gt;方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;execute()&lt;/code&gt;方法用于提交&lt;strong&gt;不需要返回值&lt;/strong&gt;的任务;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;submit()&lt;/code&gt;方法用于提交&lt;strong&gt;需要返回值&lt;/strong&gt;的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;execute()&lt;/code&gt;：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过源码可知&lt;code&gt;execute()&lt;/code&gt;方法输入的任务是一个Runnable类的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;threadsPool.execute(new Runnable() {
  @Override
  public void run() {
      // TODO Auto-generated method stub
  }
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;submit()&lt;/code&gt;：线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的&lt;code&gt;get()&lt;/code&gt;方法来获取返回值，&lt;code&gt;get()&lt;/code&gt;方法会阻塞当前线程直到任务完成，而使用&lt;code&gt;get(long timeout,TimeUnit unit)&lt;/code&gt;方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Future&amp;lt;Object&amp;gt; future = executor.submit(haveReturnValuetask);
try {
    Object s = future.get();
} catch (InterruptedException e) {
    // 处理中断异常
} catch (ExecutionException e) {
    // 处理无法执行任务异常
} finally {
    // 关闭线程池
    executor.shutdown();
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;关闭线程池&quot;&gt;&lt;a href=&quot;#关闭线程池&quot; class=&quot;headerlink&quot; title=&quot;关闭线程池&quot;&gt;&lt;/a&gt;关闭线程池&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shutdown()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutdownNow()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们的原理是遍历线程池中的工作线程，然后逐个调用线程的&lt;code&gt;interrupt()&lt;/code&gt;方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，&lt;code&gt;isShutdown()&lt;/code&gt;方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用&lt;code&gt;isTerminaed()&lt;/code&gt;方法会返回true。&lt;/p&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shutdownNow()&lt;/code&gt;首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而&lt;code&gt;shutdown()&lt;/code&gt;只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调&lt;code&gt;shutdown()&lt;/code&gt;方法来关闭线程池，如果任务不一定要执行完，则可以调用&lt;code&gt;shutdownNow()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;线程池原理&quot;&gt;&lt;a href=&quot;#线程池原理&quot; class=&quot;headerlink&quot; title=&quot;线程池原理&quot;&gt;&lt;/a&gt;线程池原理&lt;/h2&gt;&lt;h3 id=&quot;使用线程池的好处&quot;&gt;&lt;a href=&quot;#使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的好处&quot;&gt;&lt;/a&gt;使用线程池的好处&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;线程池的实现原理&quot;&gt;&lt;a href=&quot;#线程池的实现原理&quot; class=&quot;headerlink&quot; title=&quot;线程池的实现原理&quot;&gt;&lt;/a&gt;线程池的实现原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。&lt;/li&gt;
&lt;li&gt;线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。&lt;/li&gt;
&lt;li&gt;线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
    
    </summary>
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="https://www.lishaojie.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列-BlockingQueue</title>
    <link href="https://www.lishaojie.top/2020/02/16/BlockingQueue/"/>
    <id>https://www.lishaojie.top/2020/02/16/BlockingQueue/</id>
    <published>2020-02-16T14:44:38.000Z</published>
    <updated>2020-03-11T09:11:22.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列：顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用如下</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcfem6tcdyj30gf06gq4x.jpg" alt></p><ul><li>当阻塞队列是空时，试图从队列中获取元素的操作将被阻塞。</li><li>当阻塞队列是满时，试图往队列里添加元素的操作将被阻塞。</li></ul><p>在多线程领域，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒。<a id="more"></a></p><h3 id="为什么需要阻塞队列"><a href="#为什么需要阻塞队列" class="headerlink" title="为什么需要阻塞队列"></a>为什么需要阻塞队列</h3><p>在concurrent包发布以前，多线程环境下我们需要去控制线程的细节，尤其还要兼顾效率和线程安全。阻塞队列的好处是我们不需要关心线程何时阻塞，何时唤醒，因为这一切都被<code>BlockingQueue</code>一手包办了。</p><h3 id="阻塞队列的架构体系"><a href="#阻塞队列的架构体系" class="headerlink" title="阻塞队列的架构体系"></a>阻塞队列的架构体系</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcgqyg9zwhj30fi0gw0vm.jpg" alt></p><h3 id="阻塞队列的种类分析"><a href="#阻塞队列的种类分析" class="headerlink" title="阻塞队列的种类分析"></a>阻塞队列的种类分析</h3><p><code>ArrayBlockingQueue</code>：由数组结构组成的有界阻塞队列。</p><p><code>LinkedBlockingQueue</code>：由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE）阻塞队列。</p><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</p><p>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</p><p><code>SynchronousQueue</code>：<strong>一个不存储元素的阻塞队列，即队列中只有一个元素，出队后才能再进。</strong></p><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</p><p>LinkedBlocking<strong>Deque</strong>：由链表结构组成的双向阻塞队列。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronousQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t put 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t put 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t put 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t take 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t take 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t take 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//t1     put 1</span><span class="token comment" spellcheck="true">//t2     take 1</span><span class="token comment" spellcheck="true">//t1     put 2</span><span class="token comment" spellcheck="true">//t2     take 2</span><span class="token comment" spellcheck="true">//t1     put 3</span><span class="token comment" spellcheck="true">//t2     take 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞队列的核心方法"><a href="#阻塞队列的核心方法" class="headerlink" title="阻塞队列的核心方法"></a>阻塞队列的核心方法</h3><table><thead><tr><th align="center">方法类型</th><th align="center">抛出异常</th><th align="center">特殊值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center">put(e)</td><td align="center">offer(e, time,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">不可用</td><td align="center">不可用</td></tr></tbody></table><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><ul><li><p>使用add(e)进入队列，当阻塞队列满时会抛出：java.lang.IllegalStateException: Queue full</p></li><li><p>使用remove()移出队列，当阻塞队列空时会抛出：java.util.NoSuchElementException</p></li><li><p>使用element()检查队列，有值时返回首元素，队列为空时会抛出：java.util.NoSuchElementException</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//Exception in thread "main" java.lang.IllegalStateException: Queue full</span><span class="token comment" spellcheck="true">//    at java.util.AbstractQueue.add(AbstractQueue.java:98)</span><span class="token comment" spellcheck="true">//    at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span><span class="token comment" spellcheck="true">//    at BlockingQueueDemo.main(BlockingQueueDemo.java:10)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><ul><li><p>使用offer(e)插入方法，成功返回true，<strong>失败返回false，不抛出异常</strong>。</p></li><li><p>使用poll()移除方法，成功返回出队列的元素，队列里面没有就返回null。</p></li><li><p>使用peek()检查队列，有值时返回首元素，队列为空时返回null。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//a</span><span class="token comment" spellcheck="true">//b</span><span class="token comment" spellcheck="true">//c</span><span class="token comment" spellcheck="true">//null</span><span class="token comment" spellcheck="true">//null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li><p>使用put(e)方法进入队列，队列满时阻塞，没有返回值。</p></li><li><p>使用take()方法移出队列，队列空时阻塞，没有返回值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//blockingQueue.put("d");</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//blockingQueue.take();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><ul><li><p>使用offer(e,time,unit)方法进入队列，可以设置阻塞超时时间。</p></li><li><p>使用poll(time,unit)方法移出队列，可以设置阻塞等待时间。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//a</span><span class="token comment" spellcheck="true">//b</span><span class="token comment" spellcheck="true">//c</span><span class="token comment" spellcheck="true">//null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="阻塞队列的用途"><a href="#阻塞队列的用途" class="headerlink" title="阻塞队列的用途"></a>阻塞队列的用途</h3><p><strong>使用BlockingQueue建造生产者消费者模型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MySource</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 资源类</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> FLAG <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认开启，进行生产+消费操作</span>    <span class="token keyword">private</span> AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认0</span>    BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设计时范围尽量大</span>    <span class="token comment" spellcheck="true">//构造方法允许7中阻塞队列的传入</span>    <span class="token keyword">public</span> <span class="token function">MySource</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>blockingQueue <span class="token operator">=</span> blockingQueue<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定位问题（查看具体实现队列）</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 生产者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myProd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String data <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> retValue<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>FLAG<span class="token punctuation">)</span> <span class="token punctuation">{</span>            data <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            retValue <span class="token operator">=</span> blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 插入队列"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 插入队列"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 需求叫停，表示FLAG=false，生产结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 消费者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myCons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>FLAG<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> result <span class="token operator">||</span> result<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                FLAG <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 超过2秒钟没有取到数据，消费结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 消费队列"</span> <span class="token operator">+</span> result <span class="token operator">+</span> <span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 停止方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>FLAG <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProdCons_BlockQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化阻塞队列，传入ArrayBlockingQueue</span>        MySource mySource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MySource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 生产线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用生产者插入数据到队列</span>                mySource<span class="token punctuation">.</span><span class="token function">myProd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Prod"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 消费线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用消费者消费队列中的数据</span>                mySource<span class="token punctuation">.</span><span class="token function">myCons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Cons"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 生产消费5秒后结束</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mySource<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//java.util.concurrent.ArrayBlockingQueue</span><span class="token comment" spellcheck="true">//Prod     生产线程启动</span><span class="token comment" spellcheck="true">//Cons     消费线程启动</span><span class="token comment" spellcheck="true">//Prod     插入队列1成功</span><span class="token comment" spellcheck="true">//Cons     消费队列1成功</span><span class="token comment" spellcheck="true">//Prod     插入队列2成功</span><span class="token comment" spellcheck="true">//Cons     消费队列2成功</span><span class="token comment" spellcheck="true">//Prod     插入队列3成功</span><span class="token comment" spellcheck="true">//Cons     消费队列3成功</span><span class="token comment" spellcheck="true">//Prod     插入队列4成功</span><span class="token comment" spellcheck="true">//Cons     消费队列4成功</span><span class="token comment" spellcheck="true">//Prod     插入队列5成功</span><span class="token comment" spellcheck="true">//Cons     消费队列5成功</span><span class="token comment" spellcheck="true">//Prod     需求叫停，表示FLAG=false，生产结束</span><span class="token comment" spellcheck="true">//Cons     超过2秒钟没有取到数据，消费结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程控制级别</strong></p><p>1.0    synchronized、wait、notify</p><p>2.0    lock、await、singal</p><p>3.0    BlockingQueue</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;阻塞队列&quot;&gt;&lt;a href=&quot;#阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;阻塞队列&quot;&gt;&lt;/a&gt;阻塞队列&lt;/h3&gt;&lt;p&gt;阻塞队列：顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif&quot; data-original=&quot;https://tva1.sinaimg.cn/large/00831rSTgy1gcfem6tcdyj30gf06gq4x.jpg&quot; alt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当阻塞队列是空时，试图从队列中获取元素的操作将被阻塞。&lt;/li&gt;
&lt;li&gt;当阻塞队列是满时，试图往队列里添加元素的操作将被阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在多线程领域，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒。
    
    </summary>
    
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="阻塞队列" scheme="https://www.lishaojie.top/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java并发包-JUC</title>
    <link href="https://www.lishaojie.top/2020/02/12/JUC/"/>
    <id>https://www.lishaojie.top/2020/02/12/JUC/</id>
    <published>2020-02-12T10:11:40.000Z</published>
    <updated>2020-03-11T14:12:37.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><strong>倒计时/发令枪</strong>，让一些线程阻塞，直到另一些线程完成一系列操作后才被唤醒。</p><p><code>CountDownLatch</code>主要有两个方法，当一个或多个线程调用<code>await()</code>方法时，调用线程会被阻塞。其他线程调用<code>countDown()</code>方法会将计数器减1（调用countDown的线程不会阻塞），当计数器的值变为0时，因调用<code>await()</code>方法被阻塞的线程会被唤醒，继续执行。</p><p>官方解释：<code>CountDownLatch</code>用给定的计数初始化。 <code>await()</code>方法阻塞，直到由于<code>countDown()</code>方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的<code>await()</code>调用立即返回。 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用<code>CyclicBarrier</code>。<a id="more"></a></p><p><strong>CountDownLatchDemo</strong>：等待所有人上完自习离开，班长最后关门走人</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// CountDownLatch用给定的计数初始化</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 上完自习，离开教室"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// countDown()方法的调用使当前计数达到零</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//},i+" "+CountryEnum.forEach_CountryEnum(i).getRetMessage()).start(); // 枚举实现自定义顺序</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// await方法阻塞，计数到0后所有线程被释放</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 班长最后关门走人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果如下：</span><span class="token comment" spellcheck="true">//1     上完自习，离开教室</span><span class="token comment" spellcheck="true">//5     上完自习，离开教室</span><span class="token comment" spellcheck="true">//4     上完自习，离开教室</span><span class="token comment" spellcheck="true">//2     上完自习，离开教室</span><span class="token comment" spellcheck="true">//6  上完自习，离开教室</span><span class="token comment" spellcheck="true">//3     上完自习，离开教室</span><span class="token comment" spellcheck="true">//main 班长最后关门走人</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CountryEnum</strong>：枚举自定义顺序举例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Getter<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">enum</span> CountryEnum <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//ONE(1,v1,v2,v3,v4,v5…),通过增加变量可以实现自定义枚举。</span>    <span class="token function">ONE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"齐"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TWO</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"楚"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">THREE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"燕"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FOUR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"韩"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FIVE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"赵"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SEX</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"魏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Getter</span>    <span class="token keyword">private</span> Integer retCode<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Getter</span>    <span class="token keyword">private</span> String retMessage<span class="token punctuation">;</span>    <span class="token function">CountryEnum</span><span class="token punctuation">(</span>Integer retCode<span class="token punctuation">,</span> String retMessage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>retCode <span class="token operator">=</span> retCode<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>retMessage <span class="token operator">=</span> retMessage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CountryEnum <span class="token function">forEach_CountryEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountryEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> CountryEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>CountryEnum element <span class="token operator">:</span> myArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> element<span class="token punctuation">.</span><span class="token function">getRetCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> element<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//1 齐国，被灭</span><span class="token comment" spellcheck="true">//3 燕国，被灭</span><span class="token comment" spellcheck="true">//2 楚国，被灭</span><span class="token comment" spellcheck="true">//5 赵国，被灭</span><span class="token comment" spellcheck="true">//4 韩国，被灭</span><span class="token comment" spellcheck="true">//6 魏国，被灭</span><span class="token comment" spellcheck="true">//main 秦国，统一六国</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>字面意思是<strong>可循环</strong>（Cyclic）使用的<strong>屏障</strong>（Barrier）</p><p>让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被拦截的线程才会继续执行。</p><p><code>CyclicBarrier</code>通过<code>await()</code>方法开启屏障。</p><p>构造方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个新的 CyclicBarrier ，当给定数量的线程（线程）等待时，它将跳闸，并且当屏障跳闸时不执行预定义的动作。</span><span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//创建一个新的 CyclicBarrier ，当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。</span><span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CyclicBarrierDemo</strong>：集齐7颗龙珠，召唤神龙</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BrokenBarrierException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CyclicBarrier<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"*******召唤神龙"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 收集到"</span> <span class="token operator">+</span> tempInt <span class="token operator">+</span> <span class="token string">"星球"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//创建屏障，等待集齐7颗再执行给定方法</span>                      cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//1     收集到1星球</span><span class="token comment" spellcheck="true">//5     收集到5星球</span><span class="token comment" spellcheck="true">//4     收集到4星球</span><span class="token comment" spellcheck="true">//6     收集到6星球</span><span class="token comment" spellcheck="true">//3     收集到3星球</span><span class="token comment" spellcheck="true">//7     收集到7星球</span><span class="token comment" spellcheck="true">//2     收集到2星球</span><span class="token comment" spellcheck="true">//2*******召唤神龙</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>信号量</strong>主要用于两个目的：</p><ol><li>用于多个共享资源的互斥使用。</li><li>用于并发线程的控制。</li></ol><p>构造方法（可以设置公平锁和非公平锁，默认空是false非公平）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个 Semaphore与给定数量的许可证和非公平公平设置。</span><span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//创建一个 Semaphore与给定数量的许可证和给定的公平设置。</span><span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SemaphoreDemo</strong>：非公平锁类似抢车位，公平锁类似餐厅排队等位</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Semaphore<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模拟3个车位</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抢占车位</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 抢到车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 停车3秒后离开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放车位</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果：</span><span class="token comment" spellcheck="true">//1     抢到车位</span><span class="token comment" spellcheck="true">//3     抢到车位</span><span class="token comment" spellcheck="true">//2     抢到车位</span><span class="token comment" spellcheck="true">//1     停车3秒后离开</span><span class="token comment" spellcheck="true">//3     停车3秒后离开</span><span class="token comment" spellcheck="true">//4     抢到车位</span><span class="token comment" spellcheck="true">//2     停车3秒后离开</span><span class="token comment" spellcheck="true">//6     抢到车位</span><span class="token comment" spellcheck="true">//5     抢到车位</span><span class="token comment" spellcheck="true">//4     停车3秒后离开</span><span class="token comment" spellcheck="true">//6     停车3秒后离开</span><span class="token comment" spellcheck="true">//5     停车3秒后离开</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>CountDownLatch</code> : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。  </p><p><code>CyclicBarrier</code> : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p><p>这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待，而另外那N的线程在把“某个事情”做完之后可以继续执行，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</p><ul><li><p>发令枪是一次性的，无法重置，循环屏障可重复使用。<code>reset()</code></p></li><li><p><strong>CountDownLatch</strong>： 现实例子：我在一个地方等着队友开发进度，只有我的队友到达了一个预定进度，然后，我才能开始开发。当所有队友到达了一个预定进度，我开始开发了，队友也不管我，继续他们的开发。</p></li><li><p><strong>CyclicBarrier</strong>：当我使用CyclicBarrier(int count,Thread task) 这个构造方法，现实例子：几个工程队修地铁的基础设施，只有当都完成之后，技术检验人员检验合格了（这个期间工程队就歇着），工程队接着进行下一步的铁轨铺设。</p></li></ul><p><code>Semaphore</code>中有一个”许可”的概念:</p><ul><li>访问特定资源前，先使用<code>acquire(1)</code>获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</li><li>访问资源后，使用<code>release()</code>释放许可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;倒计时/发令枪&lt;/strong&gt;，让一些线程阻塞，直到另一些线程完成一系列操作后才被唤醒。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;主要有两个方法，当一个或多个线程调用&lt;code&gt;await()&lt;/code&gt;方法时，调用线程会被阻塞。其他线程调用&lt;code&gt;countDown()&lt;/code&gt;方法会将计数器减1（调用countDown的线程不会阻塞），当计数器的值变为0时，因调用&lt;code&gt;await()&lt;/code&gt;方法被阻塞的线程会被唤醒，继续执行。&lt;/p&gt;
&lt;p&gt;官方解释：&lt;code&gt;CountDownLatch&lt;/code&gt;用给定的计数初始化。 &lt;code&gt;await()&lt;/code&gt;方法阻塞，直到由于&lt;code&gt;countDown()&lt;/code&gt;方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的&lt;code&gt;await()&lt;/code&gt;调用立即返回。 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用&lt;code&gt;CyclicBarrier&lt;/code&gt;。
    
    </summary>
    
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="JUC" scheme="https://www.lishaojie.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JVM底层原理与性能优化</title>
    <link href="https://www.lishaojie.top/2020/02/09/jvm/"/>
    <id>https://www.lishaojie.top/2020/02/09/jvm/</id>
    <published>2020-02-09T14:28:22.000Z</published>
    <updated>2020-03-11T14:14:52.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、JVM基础知识"><a href="#1、JVM基础知识" class="headerlink" title="1、JVM基础知识"></a>1、JVM基础知识</h3><h4 id="JVM由哪些部分组成？"><a href="#JVM由哪些部分组成？" class="headerlink" title="JVM由哪些部分组成？"></a>JVM由哪些部分组成？</h4><ol><li><strong>类加载器</strong>（ClassLoader）</li><li><strong>运行时数据区</strong>（Runtime Data Area）</li><li><strong>执行引擎</strong>（Execution Engine）</li><li><strong>本地库接口</strong>（Native Interface）</li></ol><h4 id="各组成部分的用途？"><a href="#各组成部分的用途？" class="headerlink" title="各组成部分的用途？"></a>各组成部分的用途？</h4><p>程序在执行之前先要把java代码转换成字节码(class文件)，jvm需要把字节码通过<strong>类加载器</strong>把文件加载到内存中<strong>(运行时数据区)</strong>，而字节码文件是jvm的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器<strong>(执行引擎)</strong>将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口<strong>(本地库接口)</strong>来实现整个程序的功能。</p><h4 id="类加载器是什么？"><a href="#类加载器是什么？" class="headerlink" title="类加载器是什么？"></a>类加载器是什么？</h4><p>顾名思义，类加载器用来加载 Java 类到 jvm 中。</p><p>类加载器把 Java 字节码转换成 java.lang.Class 类的一个实例。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><ol><li><p>加载：程序运行之前jvm通过<strong>类加载器</strong>把编译完成的.class二进制文件加载到内存，供程序使用。</p></li><li><p>连接：</p><p>验证：确保类加载的正确性。（可能有的class文件是通过其他方式编译出来的）</p><p>准备：为类的<strong>静态变量</strong>分配内存，将其初始化为<strong>默认值</strong> 。（int为0，boolean为false）</p><p>解析：把类中的符号引用转化为直接引用。（比如把方法名改为方法的内存地址）</p></li><li><p>初始化：为类的静态变量赋予正确的初始值。（程序编写的值是真正的初始值）</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb1tmkh5oj30hl05j3zc.jpg" alt></p><h3 id="2、Java内存模型"><a href="#2、Java内存模型" class="headerlink" title="2、Java内存模型"></a>2、Java内存模型</h3><h4 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h4><ul><li>Java内存模型本身是一种抽象的概念，并不真实存在，它描述的是一种规范，定义了程序中各个变量的访问方式。</li><li>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了共享变量的副本。</li></ul><h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><p>线程通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p><ul><li><p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来<strong>隐式</strong>进行通信，典型的共享内存通信方式就是通过<strong>共享对象</strong>进行通信。</p></li><li><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来<strong>显式</strong>进行通信，在java中典型的消息传递方式就是wait()和notify()。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb0wr021kj30c80akt92.jpg" alt></p><h4 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h4><ol><li><p><strong>程序计数器</strong></p><p>程序计数器是一块较小的内存空间，可以看作当前线程正在执行的字节码的行号指示器。</p><p>程序计数器有两个作用：实现<strong>流程控制</strong>(循环、异常处理)和<strong>记录执行位置</strong>(多线程切换)。</p><p>线程私有，是唯一一个不会出现OutOfMemoryError的内存区域。</p><p>注意：如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。</p></li><li><p><strong>Java虚拟机栈</strong></p><p>描述Java方法运行过程的内存模型。</p><p>Java虚拟机栈会为每一个即将运行的方法创建<strong>“栈帧”(局部变量表、操作数栈、动态链接、方法出口)</strong>。</p><p>当Java方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。</p><p>线程私有，会出现StackOverFlowError和OutOfMemoryError两种异常。</p><p>注意：人们常说“堆”用来存放对象，“栈”用来存放局部变量不完全正确，只体现了栈的局部变量表部分。</p></li><li><p><strong>本地方法栈</strong></p><p>描述本地方法运行的内存模型。</p><p>本地方法被执行的时候，步骤和Java方法类似，执行完毕后相应的栈帧也会出栈并释放内存空间。</p></li><li><p><strong>堆</strong></p><p>用来<strong>存储对象</strong>的内存模型。</p><p>线程共享，堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。</p><p>可以进一步细分为：新生代、老年代。 新生代又可被分为：Eden、From Survior、To Survior。 </p><p>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，不够用会抛出OutOfMemoryError。 </p></li><li><p><strong>方法区</strong></p><p>是堆的一个逻辑部分，用于存储被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等。 </p><p><strong>运行时常量池：是方法区的一部分</strong>，用于存放编译器生成的各种字面量和符号引用。</p></li></ol><p><strong>总结</strong>：</p><ul><li><p>程序计数器、Java虚拟机栈、本地方法栈是<strong>线程私有</strong>的，生命周期随着线程的创建而创建，随着线程的结束而死亡。 </p></li><li><p>堆、方法区是<strong>线程共享</strong>的，在JVM中只有一个堆、一个方法区。在JVM启动的时候就创建，JVM停止才销毁。</p></li><li><p><strong>StackOverFlowError</strong>： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 </p></li><li><p><strong>OutOfMemoryError</strong>： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li><li><p><strong>StackOverFlowError和OutOfMemoryError的异同？</strong> </p><p>StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 </p><p>而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 </p></li></ul><h3 id="3、类加载器的双亲委派模型"><a href="#3、类加载器的双亲委派模型" class="headerlink" title="3、类加载器的双亲委派模型"></a>3、类加载器的双亲委派模型</h3><ol><li><p><strong>什么是双亲委派模型？</strong></p><p>双亲委派模型会保证父类加载器先加载类。（延伸：jvm判定两个类相同，不仅类名一致，还要被同一类加载器加载）</p></li><li><p><strong>双亲委派模型的工作过程？</strong></p><ul><li><p>当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p><p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p></li><li><p>当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p></li><li><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p></li></ul></li><li><p><strong>为什么这样设计(双亲委派的好处)？</strong></p><p>主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException.</p></li></ol><h3 id="4、JVM垃圾收集算法与收集器"><a href="#4、JVM垃圾收集算法与收集器" class="headerlink" title="4、JVM垃圾收集算法与收集器"></a>4、JVM垃圾收集算法与收集器</h3><ol><li><p><strong>如何判断一个对象是否已经死去？</strong></p><ul><li><p><strong>引用计数算法</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p><strong>可达性分析算法</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p><strong>GC Root</strong>：虚拟机栈(局部变量表)中引用的对象、方法区中类的静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象。</p></li></ul></li><li><p><strong>垃圾回收算法有哪些？</strong></p><ul><li><p><strong>复制算法</strong>：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。</p><p>优点：效率高，不会产生碎片。</p><p>缺点：可用内存变为原来的一半，存活对象多时效率低（复制成本大）。</p></li><li><p><strong>标记-清除算法</strong>：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><p>优点：相比与复制算法来说不浪费内存。</p><p>缺点：会产生内存碎片，效率低（需要扫描两次）。</p></li><li><p><strong>标记-整理算法</strong>：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。</p><p>优点：避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</p><p>缺点：效率比复制算法低，需要多维护一个链表使幸存对象连续。</p></li><li><p><strong>分代收集算法</strong>：一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p></li></ul></li><li><p><strong>GC什么时候开始？</strong></p><p>GC经常发生的区域是堆区，堆区还可以细分为新生代1/3、老年代2/3，新生代还分为一个Eden区8/10和两个Survivor1/10区。</p><ul><li><p><strong>Minor GC</strong>，发生在新生代的GC，对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快;</p></li><li><p><strong>Full GC</strong>，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝;</p></li><li><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p></li></ul></li><li><p><strong>引用的分类？</strong></p><p><strong>强引用</strong>：通过new出来的引用，只要强引用还存在，则不会回收。</p><p><strong>软引用</strong>：在内存不足的情况下，会被jvm回收。通过SoftReference类来实现。</p><p><strong>弱引用</strong>：非必须对象，只要已发生GC就会把它干掉。通过WeakReference类来实现。</p><p><strong>虚引用</strong>：相当于没有引用，被jvm干掉会收到系统通知。通过PhantomReference类来实现。</p></li><li><p><strong>垃圾收集器？</strong></p><ul><li><p><strong>Serial收集器</strong>：串行收集器效率很高，可能会产生较长的停顿，<strong>单线程-复制算法</strong>。</p></li><li><p><strong>ParNew收集器</strong>：Serial收集器的多线程版本，<strong>多线程-复制算法</strong>。</p></li><li><p><strong>Parallel Scavenge收集器</strong>：Parallel Scavenge收集器类似ParNew收集器，可以通过参数来打开<strong>自适应调节策略</strong>，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。（<strong>多线程-复制算法</strong>）</p></li><li><p><strong>Serial Old收集器</strong>：Serial的老年代版本，<strong>单线程-标记-整理算法</strong></p></li><li><p><strong>Parallel Old 收集器</strong>：Parallel Scavenge的老年代版本，在老年代提供吞吐量优先。<strong>多-标记-整理</strong></p></li><li><p><strong>CMS收集器</strong>：是一种以获取最短回收停顿时间为目标的收集器，给用户带来较好的体验。<strong>多-标记-清除</strong></p><p><strong>优点：并发收集、低停顿。</strong></p><p><strong>缺点：产生大量空间碎片、并发阶段会降低吞吐量。</strong></p></li><li><p><strong>G1收集器</strong>：Garbage First 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。<strong>标记-整理</strong></p><p><strong>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。</strong></p><p><strong>可预测停顿，在不牺牲吞吐量的前提下，实现低停顿垃圾回收。</strong></p><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分(可以不连续)Region的集合。</p></li></ul></li></ol><h3 id="5、JVM生产问题的排查与解决"><a href="#5、JVM生产问题的排查与解决" class="headerlink" title="5、JVM生产问题的排查与解决"></a>5、JVM生产问题的排查与解决</h3><h4 id="生产服务器变慢怎么办"><a href="#生产服务器变慢怎么办" class="headerlink" title="生产服务器变慢怎么办"></a>生产服务器变慢怎么办</h4><h4 id="整机：top"><a href="#整机：top" class="headerlink" title="整机：top"></a>整机：top</h4><ul><li><p>右上角<strong>load average</strong>：3个值代表1分钟，5分钟，15分钟系统的平均负载值，3个值相加除以3乘以100%，如果结果高于60%，说明系统的负载压力很大。（也可以直接输入uptime查看负载精简版）</p></li><li><p>查看<strong>%CPU</strong>和内存<strong>%MEM</strong>的占用比例。</p></li></ul><h4 id="CPU：vmstat-n-2-3"><a href="#CPU：vmstat-n-2-3" class="headerlink" title="CPU：vmstat -n 2 3"></a>CPU：vmstat -n 2 3</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb49fonjej3148064gne.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb4dp2a9kj31b10e7n9w.jpg" alt></p><ul><li><strong>id</strong>：处于空闲的CPU百分比；</li><li><strong>wa</strong>：系统等待IO的CPU时间百分比；</li><li><strong>st</strong>：来自于一个虚拟机偷取的CPU时间的百分比。</li></ul><h4 id="内存：free-m"><a href="#内存：free-m" class="headerlink" title="内存：free -m"></a>内存：free -m</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb849y0dcj314u0c442f.jpg" alt></p><p><strong>查看额外：pidstat -p 进程号 -r 采样间隔秒数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb86vzxduj30sw070tc6.jpg" alt></p><h4 id="硬盘：df-h"><a href="#硬盘：df-h" class="headerlink" title="硬盘：df -h"></a>硬盘：df -h</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcb93btg9wj30y00d27o5.jpg" alt></p><h4 id="磁盘IO：iostat-xdk-2-3"><a href="#磁盘IO：iostat-xdk-2-3" class="headerlink" title="磁盘IO：iostat -xdk 2 3"></a>磁盘IO：iostat -xdk 2 3</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbap9iegoj31po0ke4iz.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbalqfgp2j317c0cz7fs.jpg" alt></p><p><strong>查看额外：pidstat -d 采样间隔秒数 -p 进程号</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbau03v5mj314e0awdpt.jpg" alt></p><h4 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：<strong>ifstat</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbb07rl5uj312s09wgq6.jpg" alt></p><h4 id="生产环境CPU占用过高怎么办"><a href="#生产环境CPU占用过高怎么办" class="headerlink" title="生产环境CPU占用过高怎么办"></a>生产环境CPU占用过高怎么办</h4><ol><li><p>先用top命令找出CPU占比最高的。</p></li><li><p>ps -ef | grep java | grep -v grep 或者 jps -l 进一步定位，得知是什么应用程序——PID。</p></li><li><p><strong>定位到具体线程或者代码。(ps -mp 进程号 -o THREAD,tid,time)</strong>——tid线程ID。</p><p>-m：显示所有的<strong>线程</strong>、-p：进程使用的CPU时间、-o：该参数后是用户自定义格式。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbbei6igzj30nq06ugqb.jpg" alt></p></li><li><p>将需要的线程ID转换为16进制格式（<strong>英文小写格式</strong>）</p></li><li><p><strong>jstack 进程ID | grep tid (16进制线程ID) -A60</strong>（打印60行）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbbop4eloj30z40hfwqd.jpg" alt></p></li><li><p>成功定位到异常代码在JavaDemo02.java中——第10行，查看代码分析原因并修复。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、JVM基础知识&quot;&gt;&lt;a href=&quot;#1、JVM基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、JVM基础知识&quot;&gt;&lt;/a&gt;1、JVM基础知识&lt;/h3&gt;&lt;h4 id=&quot;JVM由哪些部分组成？&quot;&gt;&lt;a href=&quot;#JVM由哪些部分组成？&quot; c
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://www.lishaojie.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>几何星空连线背景-canvas</title>
    <link href="https://www.lishaojie.top/2020/02/05/star/"/>
    <id>https://www.lishaojie.top/2020/02/05/star/</id>
    <published>2020-02-05T15:10:37.000Z</published>
    <updated>2020-03-11T09:11:49.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近受疫情的影响，整天宅在家无所事事，于是就想给自己的博客添加一个动态的背景，试了各种GIF和视频，动画效果有了不过CPU占用太高，浏览体验不佳，最后选择了这个几何星空背景页面，参考网上大神的代码自己改了一份，效果如下。</p><h2 id="星空入口"><a href="#星空入口" class="headerlink" title="星空入口"></a>星空入口</h2><p>点击传送门可以预览效果：<a href="https://lishaojie1993.gitee.io/demo/star.html" target="_blank" rel="noopener">传送门</a><a id="more"></a></p><h2 id="预览实现"><a href="#预览实现" class="headerlink" title="预览实现"></a>预览实现</h2><h4 id="1、在GitHub上新建repository"><a href="#1、在GitHub上新建repository" class="headerlink" title="1、在GitHub上新建repository"></a>1、在GitHub上新建repository</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc1thz4junj316s0my7ej.jpg" alt></p><h4 id="2、点击setting，修改GitHub-Pages"><a href="#2、点击setting，修改GitHub-Pages" class="headerlink" title="2、点击setting，修改GitHub Pages"></a>2、点击setting，修改GitHub Pages</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc1tjizss0j316k0k47d1.jpg" alt></p><h4 id="3、将网页文件上传到GitHub（访问）www-lishaojie-top-demo-star-html"><a href="#3、将网页文件上传到GitHub（访问）www-lishaojie-top-demo-star-html" class="headerlink" title="3、将网页文件上传到GitHub（访问）www.lishaojie.top/demo/star.html"></a>3、将网页文件上传到GitHub（访问）<a href="http://www.lishaojie.top/demo/star.html">www.lishaojie.top/demo/star.html</a></h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc1tp8p8a3j31j00k0k0f.jpg" alt></p><hr><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>几何星空连线背景<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>canvas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 可调参数</span><span class="token keyword">var</span> BACKGROUND_COLOR <span class="token operator">=</span> <span class="token string">"rgba(0,43,54,1)"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 背景颜色</span><span class="token keyword">var</span> POINT_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 星星数目</span><span class="token keyword">var</span> POINT_COLOR <span class="token operator">=</span> <span class="token string">"rgba(255,255,255,0.7)"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 点的颜色</span><span class="token keyword">var</span> LINE_LENGTH <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 点之间连线长度(的平方)</span><span class="token comment" spellcheck="true">// 创建背景画布</span><span class="token keyword">var</span> cvs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">"\    position:fixed;\    top:0px;\    left:0px;\    z-index:-1;\    opacity:1.0;\    "</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>cvs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> ctx <span class="token operator">=</span> cvs<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> startTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机数函数</span><span class="token keyword">function</span> <span class="token function">randomInt</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//构造点类</span><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> speed <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> angle <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> POINT_COLOR<span class="token punctuation">;</span><span class="token punctuation">}</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>move <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">></span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">></span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>draw <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">initPoints</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        points<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//鼠标</span>p0<span class="token punctuation">.</span>dx <span class="token operator">=</span> p0<span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> degree <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span>onmousedown <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    degree <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span>onmouseup <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    degree <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>window<span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">drawLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> deg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> dx <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token keyword">var</span> dy <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token keyword">var</span> dis2 <span class="token operator">=</span> dx <span class="token operator">*</span> dx <span class="token operator">+</span> dy <span class="token operator">*</span> dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dis2 <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dis2 <span class="token operator">></span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">===</span> p0<span class="token punctuation">)</span> <span class="token punctuation">{</span>                p2<span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> dx <span class="token operator">*</span> <span class="token number">0.03</span><span class="token punctuation">;</span>                p2<span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> dy <span class="token operator">*</span> <span class="token number">0.03</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.05</span> <span class="token operator">-</span> dis2 <span class="token operator">/</span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.2</span> <span class="token operator">*</span> deg<span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>strokeStyle <span class="token operator">=</span> <span class="token string">"rgba(255,255,255,"</span> <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>lineWidth <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//绘制每一帧</span><span class="token keyword">function</span> <span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cvs<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>    cvs<span class="token punctuation">.</span>height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> BACKGROUND_COLOR<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span>p0<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> points <span class="token punctuation">:</span> <span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawLine</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>drawFrame<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">initPoints</span><span class="token punctuation">(</span>POINT_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近受疫情的影响，整天宅在家无所事事，于是就想给自己的博客添加一个动态的背景，试了各种GIF和视频，动画效果有了不过CPU占用太高，浏览体验不佳，最后选择了这个几何星空背景页面，参考网上大神的代码自己改了一份，效果如下。&lt;/p&gt;
&lt;h2 id=&quot;星空入口&quot;&gt;&lt;a href=&quot;#星空入口&quot; class=&quot;headerlink&quot; title=&quot;星空入口&quot;&gt;&lt;/a&gt;星空入口&lt;/h2&gt;&lt;p&gt;点击传送门可以预览效果：&lt;a href=&quot;https://lishaojie1993.gitee.io/demo/star.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;
    
    </summary>
    
    
    
      <category term="DIY" scheme="https://www.lishaojie.top/tags/DIY/"/>
    
      <category term="star-line" scheme="https://www.lishaojie.top/tags/star-line/"/>
    
  </entry>
  
  <entry>
    <title>GitHub骚操作</title>
    <link href="https://www.lishaojie.top/2020/01/20/github/"/>
    <id>https://www.lishaojie.top/2020/01/20/github/</id>
    <published>2020-01-20T09:25:02.000Z</published>
    <updated>2020-03-11T14:14:32.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="in-限制搜索范围"><a href="#in-限制搜索范围" class="headerlink" title="in:限制搜索范围"></a>in:限制搜索范围</h2><p>公式：<strong>xxx in:name｜description｜readme</strong></p><ul><li>xxx in:name 项目名包含xxx的</li><li>xxx in:description 项目描述包含xxx的</li><li>xxx in:readme 项目的readme文件中包含xxx的</li></ul><p>组合使用（查秒杀系统）：<strong>seckill in:<code>name</code>,<code>description</code>,<code>readme</code></strong><a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhjlmxiej31l30u0qv5.jpg" alt></p><h2 id="stars-｜forks-数量区间"><a href="#stars-｜forks-数量区间" class="headerlink" title="stars:｜forks:数量区间"></a>stars:｜forks:数量区间</h2><p>公式：<strong>xxx stars:</strong><kbd>></kbd><kbd><</kbd><kbd>=</kbd><strong>｜</strong><kbd>..</kbd></p><p>查找stars数大于等于5000的springboot项目：<strong>springboot stars:&gt;=5000</strong></p><p>查找fork数大于300的springcloud项目：<strong>springcloud forks:&gt;300</strong></p><p>组合使用：查找fork在100～200之间并且star数在80～100之间的springboot项目</p><p><strong>seckill forks:100..2000 stars:1000..2000</strong>：缩小查找范围</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhnxi6rrj31em0n6e2t.jpg" alt></p><h2 id="awesome-加强搜索"><a href="#awesome-加强搜索" class="headerlink" title="awesome 加强搜索"></a>awesome 加强搜索</h2><p>搜索优秀的比如redis相关的项目，包括框架、教程等。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhtnze9ij31hk0u0u0x.jpg" alt></p><h2 id="高亮显示某一行代码"><a href="#高亮显示某一行代码" class="headerlink" title="高亮显示某一行代码"></a>高亮显示某一行代码</h2><ul><li>单行高亮：<strong>GitHub地址+#L行数</strong></li><li>多行高亮：<strong>GitHub地址+#L行数-L行数</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnh72xxn6j313q0jynh5.jpg" alt></p><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li><p>进入项目页后按<kbd>t</kbd>：激活文件查看器，可以直接搜索内容</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhbtga2qj31aq0u07wh.jpg" alt></p></li><li><p>进入代码页后按<kbd>l</kbd>：输入数字，跳到代码中的具体哪一行</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhdhoeqjj31jo0gmk87.jpg" alt></p></li></ul><p>更多快捷键操作请点击：<a href="https://help.github.com/en/github/getting-started-with-github/keyboard-shortcuts" target="_blank" rel="noopener">https://help.github.com/en/github/getting-started-with-github/keyboard-shortcuts</a></p><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><p>location:地区｜language:语言</p><p>例如：<strong>location:beijing language:java</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcngwj9gyrj316o0u0npd.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;in-限制搜索范围&quot;&gt;&lt;a href=&quot;#in-限制搜索范围&quot; class=&quot;headerlink&quot; title=&quot;in:限制搜索范围&quot;&gt;&lt;/a&gt;in:限制搜索范围&lt;/h2&gt;&lt;p&gt;公式：&lt;strong&gt;xxx in:name｜description｜readme&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xxx in:name 项目名包含xxx的&lt;/li&gt;
&lt;li&gt;xxx in:description 项目描述包含xxx的&lt;/li&gt;
&lt;li&gt;xxx in:readme 项目的readme文件中包含xxx的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;组合使用（查秒杀系统）：&lt;strong&gt;seckill in:&lt;code&gt;name&lt;/code&gt;,&lt;code&gt;description&lt;/code&gt;,&lt;code&gt;readme&lt;/code&gt;&lt;/strong&gt;
    
    </summary>
    
    
    
      <category term="GitHub" scheme="https://www.lishaojie.top/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式-单例模式</title>
    <link href="https://www.lishaojie.top/2020/01/18/singleton/"/>
    <id>https://www.lishaojie.top/2020/01/18/singleton/</id>
    <published>2020-01-18T08:40:22.000Z</published>
    <updated>2020-03-11T14:23:04.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>单例模式属于设计模式三大分类的第一类——<strong>创建型模式</strong>，单例模式在创建对象的同时还要控制对象的数量，<strong>只能创建一个实例</strong>。</p><ol><li><p>有些场景下，不使用单例模式，会导致系统同一时刻出现多个状态，如网页流量计数器。</p></li><li><p>通过控制创建对象的数量，可以节约系统资源开销。不需要频繁的创建跟销毁。</p></li><li><p>全局数据共享。</p><ul><li><p>比如应用中的日志系统，所有的日志都会统一追加，方便后续管理。</p></li><li><p>读取配置的类一般会使用一个单例去统一加载读取。（一般都是启动时加载一次）<a id="more"></a></p></li></ul></li></ol><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><ol><li>私有的构造方法</li><li>指向自己实例的私有静态引用</li><li>以自己实例为返回值的静态的公有的方法</li></ol><p><strong>单例模式根据实例化对象时机的不同分为两种：饿汉式、懒汉式。</strong></p><p>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungrySingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//①</span>    <span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//②</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungrySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//③</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①static修饰，类加载时new对象，天然防止并发问题</span><span class="token comment" spellcheck="true">//②私有化构造方法，禁止其他类通过构造方法创建对象</span><span class="token comment" spellcheck="true">//③对外提供单例对象的获取方式</span><span class="token comment" spellcheck="true">//存在的问题</span><span class="token comment" spellcheck="true">//1、类初始化就创建，如果对象非常大，会对系统的性能造成影响</span><span class="token comment" spellcheck="true">//2、有时候只是单纯想加载类，不想使用对象，会浪费内存空间</span><span class="token comment" spellcheck="true">//3、如果类中有静态属性的话，访问静态属性会导致对象被实例化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> LazySingleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//①</span>    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//②</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//③</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①static修饰，类加载时不创建对象，volatile保证可见性</span><span class="token comment" spellcheck="true">//②私有化构造方法</span><span class="token comment" spellcheck="true">//③考虑线程安全加synchronized同步锁</span><span class="token comment" spellcheck="true">//存在的问题</span><span class="token comment" spellcheck="true">//每个线程不管instance有没有被创建过，都会去调用getInstance()，因为if(instance == null)是需要进入方法后才判断的，然而getInstance()又是一个同步的，同一时刻只会有一个线程进入，其余线程都必须等待，这就会导致线程阻塞，性能下降。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> LazySingleton instance<span class="token operator">=</span>null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//①</span>    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//②</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//③</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//④</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//⑤</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//⑥</span>                    instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//⑦</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①static修饰，类加载时不创建对象，volatile保证可见性、防止指令重排序</span><span class="token comment" spellcheck="true">//②私有化构造方法</span><span class="token comment" spellcheck="true">//③在获取实例的方法上不加锁</span><span class="token comment" spellcheck="true">//④判断是否创建了实例，如果有实例直接返回，提高效率</span><span class="token comment" spellcheck="true">//⑤没有创建实例，需要进入同步方法创建实例</span><span class="token comment" spellcheck="true">//⑥保证多线程安全，防止创建多个实例</span><span class="token comment" spellcheck="true">//⑦volatile防止指令重排</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于volatile指令重排序的讲解：</p><p>⑦处会创建一个<code>LazySingleton</code>实例，并且赋值给<code>instance</code>变量，但是这一个动作在指令层面<strong>并非原子操作</strong>。这个动作可以分为4步：</p><ol><li>申请内存空间</li><li>初始化默认值</li><li>执行构造器初始化</li><li>将instance指向创建的对象</li></ol><p>有些编译器会对代码做指令重排序，因为3和4本身相互并不存在依赖，指令重排序的存在可能会导致3和4顺序发生颠倒。这会有什么问题？首先在单线程下并不会有什么问题，因为指令重排序的前提就是不改变在单线程下的结果，无论先执行3还是4，最后返回的对象都是初始化好后的。但是在多线程下呢？设想一种极端场景，现在假设A线程拿到锁进入到⑦处，然后它完成了上面4步的1和2，因为现在指令重排序了，下面A线程会将<code>instance</code>指向创建的对象，也就是说，此时<code>instance != null</code>了！然后正当A要去执行构造器初始化对象时，巧得很，这时候B线程来到④处，判断<code>instance == null</code>不成立了，直接返回，但是A线程还没有初始化对象呢，因为返回了一个没有经过初始化的对象，后续操作自然会有问题。正是因为这个原因，所以①处<code>volatile</code>不可省略，<strong>主要原因就在于防止指令重排序</strong>，避免上述问题。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerSingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">StaticInnerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerSingletonInstance</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//①</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> StaticInnerSingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInnerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> StaticInnerSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//②</span>      <span class="token keyword">return</span> StaticInnerSingletonInstance<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①StaticInnerSingletonInstance是一个静态内部类，内部静态字段instance负责创建对象。外部类StaticInnerSingleton初始化时，并不会导致StaticInnerSingletonInstance初始化，进而导致instance的初始化。所以实现了延迟加载。</span><span class="token comment" spellcheck="true">//②通过StaticInnerSingletonInstance.instance对instance引用才会导致对象的创建。由于static的属性只会跟随类加载初始化一次，天然保证了线程安全问题。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">enum</span> EnumSingletonInstance<span class="token punctuation">{</span>   INSTANCE<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> EnumSingletonInstance <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//好处：绝对安全，不会被破解</span><span class="token comment" spellcheck="true">//缺点：不能实现延迟加载，对象不大的情况下推荐使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="破解单例"><a href="#破解单例" class="headerlink" title="破解单例"></a>破解单例</h2><h3 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungrySingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungrySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 破解单例</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反射破解单例..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance1 <span class="token operator">=</span> HungrySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance2 <span class="token operator">=</span> HungrySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//反射破解单例...</span><span class="token comment" spellcheck="true">//HungrySingleton@60e53b93</span><span class="token comment" spellcheck="true">//HungrySingleton@5e2de80c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何防止反射破解"><a href="#如何防止反射破解" class="headerlink" title="如何防止反射破解"></a>如何防止反射破解</h3><p>很简单，因为<code>Class.newInstance()</code>是通过调用<code>HungrySingleton()</code>无参构造器创建对象的，只要在构造器中加入有以下逻辑即可。这样，当类初始化时，第一次正常创建出实例并赋值给<code>instance</code>。当再想通过反射想要破解单例时，自然会抛出异常阻止继续实例化。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 构造方法修改如下</span><span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"只能创建一个对象！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//java.lang.Exception: 只能创建一个对象！</span><span class="token comment" spellcheck="true">//    at HungrySingleton.&lt;init>(HungrySingleton.java:6)</span><span class="token comment" spellcheck="true">//    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><span class="token comment" spellcheck="true">//    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><span class="token comment" spellcheck="true">//    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><span class="token comment" spellcheck="true">//    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><span class="token comment" spellcheck="true">//    at java.lang.Class.newInstance(Class.java:442)</span><span class="token comment" spellcheck="true">//    at HungrySingleton.main(HungrySingleton.java:20)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反序列化破解"><a href="#反序列化破解" class="headerlink" title="反序列化破解"></a>反序列化破解</h3><p>前提是单例类实现了<code>Serializable</code>接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungrySingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungrySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 破解单例</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反序列化破解单例..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance1 <span class="token operator">=</span> HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//序列化</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance2 <span class="token operator">=</span> <span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//反序列化</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//反序列化破解单例...</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//HungrySingleton@2f4d3709</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何防止反序列化破解"><a href="#如何防止反序列化破解" class="headerlink" title="如何防止反序列化破解"></a>如何防止反序列化破解</h3><p>也非常简单，只需要在单例类中添加如下<code>readResolve()</code>方法，然后在方法体中返回我们的单例实例即可。为什么？因为<code>readResolve()</code>方法是在<code>readObject()</code>方法之后才被调用，因而它每次都会用我们自己生成的单实例替换从流中读取的对象。这样自然就保证了单例。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ObjectStreamException<span class="token punctuation">{</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="适用场景和注意事项"><a href="#适用场景和注意事项" class="headerlink" title="适用场景和注意事项"></a>适用场景和注意事项</h2><h3 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h3><ol><li><p>扩展困难，由于<code>getInstance()</code>静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。</p></li><li><p>隐式使用引起类结构不清晰。</p></li><li><p>导致程序内存泄露的问题。</p></li></ol><h3 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h3><ol><li>在内存中只有一个对象，节省内存空间。</li><li>避免频繁的创建销毁对象，可以提高性能。</li><li>避免对共享资源的多重占用。</li><li>可以全局访问。</li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：</p><ol><li><p>需要频繁实例化然后销毁的对象。</p></li><li><p>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</p></li><li><p>资源共享的情况下，避免由于资源操作时导致的性能或损耗等</p></li><li><p>控制资源的情况下，方便资源之间的互相通信。</p></li></ol><h3 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h3><p>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</p><p>不要做断开单例类对象与类中静态引用的危险操作。</p><p>多线程使用单例使用共享资源时，注意线程安全问题。</p><h3 id="一般选用原则"><a href="#一般选用原则" class="headerlink" title="一般选用原则"></a>一般选用原则</h3><ul><li>单例对象占用资源少，不需要延时加载：枚举式好于饿汉式。</li><li>单例对象占用资源大，需要延时加载：静态内部类式好于懒汉式。</li></ul><h2 id="单例模式的一些常见问题"><a href="#单例模式的一些常见问题" class="headerlink" title="单例模式的一些常见问题"></a>单例模式的一些常见问题</h2><h3 id="单例模式的对象长时间不用会被jvm垃圾收集器收集吗"><a href="#单例模式的对象长时间不用会被jvm垃圾收集器收集吗" class="headerlink" title="单例模式的对象长时间不用会被jvm垃圾收集器收集吗?"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗?</h3><pre class="line-numbers language-html"><code class="language-html">除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JVM卸载类的判定条件如下：</p><ol><li><p>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ol><p>只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。</p><h3 id="单例类可以被继承吗"><a href="#单例类可以被继承吗" class="headerlink" title="单例类可以被继承吗?"></a>单例类可以被继承吗?</h3><p>根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。</p><p>这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用单例模式&quot;&gt;&lt;a href=&quot;#为什么要使用单例模式&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用单例模式&quot;&gt;&lt;/a&gt;为什么要使用单例模式&lt;/h2&gt;&lt;p&gt;单例模式属于设计模式三大分类的第一类——&lt;strong&gt;创建型模式&lt;/strong&gt;，单例模式在创建对象的同时还要控制对象的数量，&lt;strong&gt;只能创建一个实例&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有些场景下，不使用单例模式，会导致系统同一时刻出现多个状态，如网页流量计数器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过控制创建对象的数量，可以节约系统资源开销。不需要频繁的创建跟销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局数据共享。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;比如应用中的日志系统，所有的日志都会统一追加，方便后续管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读取配置的类一般会使用一个单例去统一加载读取。（一般都是启动时加载一次）
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.lishaojie.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.lishaojie.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="singleton" scheme="https://www.lishaojie.top/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 防火墙-iptables</title>
    <link href="https://www.lishaojie.top/2020/01/17/firewall/"/>
    <id>https://www.lishaojie.top/2020/01/17/firewall/</id>
    <published>2020-01-17T07:29:48.000Z</published>
    <updated>2020-03-11T14:14:04.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关闭默认防火墙"><a href="#关闭默认防火墙" class="headerlink" title="关闭默认防火墙"></a>关闭默认防火墙</h3><p>CentOS 7默认使用的防火墙是firewall，需要将其关闭</p><ul><li>systemctl stop firewalld.service #停止firewall</li><li>systemctl disable firewalld.service #禁止firewall开机启动</li></ul><h3 id="安装-iptables-service"><a href="#安装-iptables-service" class="headerlink" title="安装 iptables service"></a>安装 iptables service</h3><p>yum -y install iptables-services <a id="more"></a></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>vi /etc/sysconfig/iptables </p><h3 id="在配置文件中增加规则"><a href="#在配置文件中增加规则" class="headerlink" title="在配置文件中增加规则"></a>在配置文件中增加规则</h3><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p><h3 id="保存退出，重启防火墙"><a href="#保存退出，重启防火墙" class="headerlink" title="保存退出，重启防火墙"></a>保存退出，重启防火墙</h3><ul><li>systemctl restart iptables.service #重启防火墙使配置生效</li><li>systemctl enable iptables.service #设置防火墙开机启动</li></ul><h3 id="iptables防火墙常用命令"><a href="#iptables防火墙常用命令" class="headerlink" title="iptables防火墙常用命令"></a>iptables防火墙常用命令</h3><ul><li>systemctl start iptables.service #打开防火墙</li><li>systemctl stop iptables.service #关闭防火墙</li><li>systemctl restart iptables.service #重启防火墙</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关闭默认防火墙&quot;&gt;&lt;a href=&quot;#关闭默认防火墙&quot; class=&quot;headerlink&quot; title=&quot;关闭默认防火墙&quot;&gt;&lt;/a&gt;关闭默认防火墙&lt;/h3&gt;&lt;p&gt;CentOS 7默认使用的防火墙是firewall，需要将其关闭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;systemctl stop firewalld.service #停止firewall&lt;/li&gt;
&lt;li&gt;systemctl disable firewalld.service #禁止firewall开机启动&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装-iptables-service&quot;&gt;&lt;a href=&quot;#安装-iptables-service&quot; class=&quot;headerlink&quot; title=&quot;安装 iptables service&quot;&gt;&lt;/a&gt;安装 iptables service&lt;/h3&gt;&lt;p&gt;yum -y install iptables-services
    
    </summary>
    
    
      <category term="System" scheme="https://www.lishaojie.top/categories/System/"/>
    
    
      <category term="CentOS" scheme="https://www.lishaojie.top/tags/CentOS/"/>
    
      <category term="FireWall" scheme="https://www.lishaojie.top/tags/FireWall/"/>
    
  </entry>
  
  <entry>
    <title>神一样的存在,万能插件-Tampermonkey</title>
    <link href="https://www.lishaojie.top/2020/01/10/Tampermonkey/"/>
    <id>https://www.lishaojie.top/2020/01/10/Tampermonkey/</id>
    <published>2020-01-10T15:35:36.000Z</published>
    <updated>2020-03-11T09:12:42.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：<a href="http://www.lishaojie.top/2020/01/09/ghelper">科学上网推荐,谷歌浏览器插件Ghelper</a>  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg" alt></p><a id="more"></a><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>说到这款插件就不得不说一个网址：<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg" alt></p><p>这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg" alt></p><p>选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg" alt></p><p>点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg" alt></p><h2 id="脚本推荐"><a href="#脚本推荐" class="headerlink" title="脚本推荐"></a>脚本推荐</h2><p>管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg" alt></p><p>我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。</p><p>划词翻译</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg" alt></p><p>BiliBili会员站点解析</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg" alt></p><p>YouTube视频下载</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg" alt></p><p>是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：&lt;a href=&quot;http://www.lishaojie.top/2020/01/09/ghelper&quot;&gt;科学上网推荐,谷歌浏览器插件Ghelper&lt;/a&gt;  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif&quot; data-original=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Google plugin" scheme="https://www.lishaojie.top/tags/Google-plugin/"/>
    
      <category term="Tampermonkey" scheme="https://www.lishaojie.top/tags/Tampermonkey/"/>
    
  </entry>
  
  <entry>
    <title>科学上网推荐,谷歌浏览器插件Ghelper</title>
    <link href="https://www.lishaojie.top/2020/01/10/ghelper/"/>
    <id>https://www.lishaojie.top/2020/01/10/ghelper/</id>
    <published>2020-01-10T14:18:05.000Z</published>
    <updated>2020-03-11T14:14:12.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg" alt></p><a id="more"></a><p>不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 <a href="https://usky.ml/tool/free_ssr" target="_blank" rel="noopener">SSR工具</a></p><p>把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。</p><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg" alt></p><p>点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg" alt></p><h2 id="资费详情"><a href="#资费详情" class="headerlink" title="资费详情"></a>资费详情</h2><p>介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg" alt></p><h2 id="手机代理"><a href="#手机代理" class="headerlink" title="手机代理"></a>手机代理</h2><p>页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg" alt></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>YouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif&quot; data-original=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Google plugin" scheme="https://www.lishaojie.top/tags/Google-plugin/"/>
    
      <category term="Ghelper" scheme="https://www.lishaojie.top/tags/Ghelper/"/>
    
  </entry>
  
  <entry>
    <title>macOS 超实用的「付费」软件推荐,分享一波福利！</title>
    <link href="https://www.lishaojie.top/2020/01/07/macapp/"/>
    <id>https://www.lishaojie.top/2020/01/07/macapp/</id>
    <published>2020-01-07T03:17:15.000Z</published>
    <updated>2020-02-26T14:05:13.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Alfred-4"><a href="#Alfred-4" class="headerlink" title="Alfred 4"></a>Alfred 4</h2><p>版本号: 4.0.6</p><p>功能介绍: <a href="https://www.alfredapp.com/whats-new/" target="_blank" rel="noopener">https://www.alfredapp.com/whats-new/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA" target="_blank" rel="noopener">https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA</a>  密码:9onb</p><p>推荐指数: ★★★★★<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg" alt></p><h2 id="CleanMyMac-X"><a href="#CleanMyMac-X" class="headerlink" title="CleanMyMac X"></a>CleanMyMac X</h2><p>版本号: 4.4.6</p><p>功能介绍: <a href="https://macpaw.com/cleanmymac" target="_blank" rel="noopener">https://macpaw.com/cleanmymac</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA</a>  密码:mslx</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg" alt></p><h2 id="Movist-Pro"><a href="#Movist-Pro" class="headerlink" title="Movist Pro"></a>Movist Pro</h2><p>版本号: 2.2.13</p><p>功能介绍: <a href="https://movistprime.com/" target="_blank" rel="noopener">https://movistprime.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg</a>  密码:8ocb</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg" alt></p><h2 id="Final-Cut-Pro-X"><a href="#Final-Cut-Pro-X" class="headerlink" title="Final Cut Pro X"></a>Final Cut Pro X</h2><p>版本号: 10.4.5</p><p>功能介绍: <a href="https://www.apple.com/final-cut-pro/" target="_blank" rel="noopener">https://www.apple.com/final-cut-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ</a>  密码:wqdk</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg" alt></p><h2 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h2><p>版本号: 4.4.3</p><p>功能介绍: <a href="https://www.apple.com.cn/cn/final-cut-pro/compressor/" target="_blank" rel="noopener">https://www.apple.com.cn/cn/final-cut-pro/compressor/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA</a>  密码:8mng</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg" alt></p><h2 id="iStat-Menus-6"><a href="#iStat-Menus-6" class="headerlink" title="iStat Menus 6"></a>iStat Menus 6</h2><p>版本号: 6.31</p><p>功能介绍: <a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">https://bjango.com/mac/istatmenus/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ</a>  密码:r8yx</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg" alt></p><h2 id="Parallels-Desktop-15"><a href="#Parallels-Desktop-15" class="headerlink" title="Parallels Desktop 15"></a>Parallels Desktop 15</h2><p>版本号: 15.1.2</p><p>功能介绍: <a href="https://www.parallels.com/cn/landingpage/pd/general/" target="_blank" rel="noopener">https://www.parallels.com/cn/landingpage/pd/general/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg" alt></p><h2 id="XMind-8-Pro"><a href="#XMind-8-Pro" class="headerlink" title="XMind 8 Pro"></a>XMind 8 Pro</h2><p>版本号: 3.7.7</p><p>功能介绍: <a href="https://www.xmind.cn/xmind8-pro/" target="_blank" rel="noopener">https://www.xmind.cn/xmind8-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg" alt></p><h2 id="PDF-Expert"><a href="#PDF-Expert" class="headerlink" title="PDF Expert"></a>PDF Expert</h2><p>版本号: 2.4.23</p><p>功能介绍: <a href="https://pdfexpert.com/" target="_blank" rel="noopener">https://pdfexpert.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow" target="_blank" rel="noopener">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg" alt></p><h2 id="Things-3"><a href="#Things-3" class="headerlink" title="Things 3"></a>Things 3</h2><p>版本号: 3.11</p><p>功能介绍: <a href="https://culturedcode.com/things/" target="_blank" rel="noopener">https://culturedcode.com/things/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ</a>  密码:ddv6</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg" alt></p><h2 id="Downie-3"><a href="#Downie-3" class="headerlink" title="Downie 3"></a>Downie 3</h2><p>版本号: 3.9.4</p><p>功能介绍: <a href="https://software.charliemonroe.net/downie/" target="_blank" rel="noopener">https://software.charliemonroe.net/downie/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA</a>  密码:cqma</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg" alt></p><h2 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h2><p>版本号: 2.4.4</p><p>功能介绍: <a href="https://pasteapp.me/" target="_blank" rel="noopener">https://pasteapp.me/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g" target="_blank" rel="noopener">https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g</a>  密码:4bxn</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg" alt></p><h2 id="Bartender-3"><a href="#Bartender-3" class="headerlink" title="Bartender 3"></a>Bartender 3</h2><p>版本号: 3.1.1</p><p>功能介绍: <a href="https://www.macbartender.com/" target="_blank" rel="noopener">https://www.macbartender.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q</a>  密码:b00n</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg" alt></p><h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p>版本号: 3.2.2</p><p>功能介绍: <a href="https://zh.mweb.im/" target="_blank" rel="noopener">https://zh.mweb.im/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw</a>  密码:87dx</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg" alt></p><h2 id="Smooze"><a href="#Smooze" class="headerlink" title="Smooze"></a>Smooze</h2><p>版本号: 1.8.6</p><p>功能介绍: <a href="https://smooze.co/" target="_blank" rel="noopener">https://smooze.co/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw</a>  密码:upjo</p><p>推荐指数: ★★☆☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg" alt></p><h2 id="Keka"><a href="#Keka" class="headerlink" title="Keka"></a>Keka</h2><p>版本号: 1.1.5</p><p>功能介绍: <a href="https://www.keka.io/en/" target="_blank" rel="noopener">https://www.keka.io/en/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ</a>  密码:7sdf</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg" alt></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!</p><p>本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Alfred-4&quot;&gt;&lt;a href=&quot;#Alfred-4&quot; class=&quot;headerlink&quot; title=&quot;Alfred 4&quot;&gt;&lt;/a&gt;Alfred 4&lt;/h2&gt;&lt;p&gt;版本号: 4.0.6&lt;/p&gt;
&lt;p&gt;功能介绍: &lt;a href=&quot;https://www.alfredapp.com/whats-new/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.alfredapp.com/whats-new/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;破解版下载链接:&lt;a href=&quot;https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA&lt;/a&gt;  密码:9onb&lt;/p&gt;
&lt;p&gt;推荐指数: ★★★★★
    
    </summary>
    
    
      <category term="System" scheme="https://www.lishaojie.top/categories/System/"/>
    
    
      <category term="macOS" scheme="https://www.lishaojie.top/tags/macOS/"/>
    
      <category term="paid apps" scheme="https://www.lishaojie.top/tags/paid-apps/"/>
    
  </entry>
  
  <entry>
    <title>macOS 超实用的「免费」软件推荐,使用经验分享！</title>
    <link href="https://www.lishaojie.top/2020/01/06/macappfree/"/>
    <id>https://www.lishaojie.top/2020/01/06/macappfree/</id>
    <published>2020-01-06T14:34:14.000Z</published>
    <updated>2020-02-26T15:18:40.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它</p><p>功能介绍：<a href="https://iterm2.com/features.html" target="_blank" rel="noopener">https://iterm2.com/features.html</a></p><p>官方下载地址：<a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener">https://iterm2.com/downloads.html</a></p><p>推荐指数：★★★★★<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg" alt></p><h2 id="IINA"><a href="#IINA" class="headerlink" title="IINA"></a>IINA</h2><p>概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快</p><p>功能介绍：<a href="https://zhuanlan.zhihu.com/p/24700324" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24700324</a></p><p>官方下载地址：<a href="https://iina.io/" target="_blank" rel="noopener">https://iina.io/</a></p><p>推荐指数：★★★★☆（Movist Pro 是满分😄）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg" alt></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>概括：支持实时预览的Markdown文本编辑器</p><p>功能介绍：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">https://sspai.com/post/54912</a></p><p>官方下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><p>推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg" alt></p><h2 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h2><p>概括：Markdown 图床、文件上传工具，免费版足够用</p><p>功能介绍：<a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">https://toolinbox.net/iPic/</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg" alt></p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件</p><p>功能介绍：<a href="https://www.cnblogs.com/clwydjgs/p/10078065.html" target="_blank" rel="noopener">https://www.cnblogs.com/clwydjgs/p/10078065.html</a></p><p>官方下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><p>推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg" alt></p><h2 id="Better-And-Better"><a href="#Better-And-Better" class="headerlink" title="Better And Better"></a>Better And Better</h2><p>概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用</p><p>功能介绍：<a href="https://www.better365.cn/tv.html" target="_blank" rel="noopener">https://www.better365.cn/tv.html</a></p><p>官方下载地址：<a href="https://www.better365.cn/bab.html" target="_blank" rel="noopener">https://www.better365.cn/bab.html</a></p><p>推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg" alt></p><h2 id="iShot"><a href="#iShot" class="headerlink" title="iShot"></a>iShot</h2><p>概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法</p><p>功能介绍：<a href="https://sspai.com/post/57302" target="_blank" rel="noopener">https://sspai.com/post/57302</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg" alt></p><h2 id="Final-Shell"><a href="#Final-Shell" class="headerlink" title="Final Shell"></a>Final Shell</h2><p>概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp</p><p>功能介绍：<a href="https://blog.csdn.net/sinat_25838589/article/details/79781241" target="_blank" rel="noopener">https://blog.csdn.net/sinat_25838589/article/details/79781241</a></p><p>官方下载地址：<a href="http://www.hostbuf.com/t/988.html" target="_blank" rel="noopener">http://www.hostbuf.com/t/988.html</a></p><p>推荐指数：★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;iTerm2&quot;&gt;&lt;a href=&quot;#iTerm2&quot; class=&quot;headerlink&quot; title=&quot;iTerm2&quot;&gt;&lt;/a&gt;iTerm2&lt;/h2&gt;&lt;p&gt;概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它&lt;/p&gt;
&lt;p&gt;功能介绍：&lt;a href=&quot;https://iterm2.com/features.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://iterm2.com/features.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方下载地址：&lt;a href=&quot;https://iterm2.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://iterm2.com/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐指数：★★★★★
    
    </summary>
    
    
      <category term="System" scheme="https://www.lishaojie.top/categories/System/"/>
    
    
      <category term="macOS" scheme="https://www.lishaojie.top/tags/macOS/"/>
    
      <category term="free apps" scheme="https://www.lishaojie.top/tags/free-apps/"/>
    
  </entry>
  
  <entry>
    <title>AES对称加密算法</title>
    <link href="https://www.lishaojie.top/2019/11/05/AES/"/>
    <id>https://www.lishaojie.top/2019/11/05/AES/</id>
    <published>2019-11-05T15:36:05.000Z</published>
    <updated>2020-02-24T11:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AES算法的特点"><a href="#AES算法的特点" class="headerlink" title="AES算法的特点"></a>AES算法的特点</h2><p>AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客<a href="http://www.lishaojie.top/2019/07/04/MD5/">《MD5底层实现和解密方法》</a>所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用<strong>同一个密钥</strong>。AES支持三种长度的密钥：<strong>128位，192位，256位</strong>。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。</p><p>从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。<a id="more"></a></p><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。</p><p>假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行<strong>填充</strong>（Padding）。</p><h4 id="NoPadding"><a href="#NoPadding" class="headerlink" title="NoPadding"></a>NoPadding</h4><p>不做任何填充，但是要求明文必须是16字节的整数倍。</p><h4 id="PKCS5Padding（默认）"><a href="#PKCS5Padding（默认）" class="headerlink" title="PKCS5Padding（默认）"></a>PKCS5Padding（默认）</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p><h4 id="ISO10126Padding"><a href="#ISO10126Padding" class="headerlink" title="ISO10126Padding"></a>ISO10126Padding</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}</p><p><strong>注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</strong></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。</p><h4 id="ECB模式（默认）"><a href="#ECB模式（默认）" class="headerlink" title="ECB模式（默认）"></a>ECB模式（默认）</h4><p>电码本模式  Electronic Codebook Book</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg" alt></p><p>ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。</p><h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>密码分组链接模式  Cipher Block Chaining</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg" alt></p><p>CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它<strong>前一个明文块所加密出的密文块</strong>相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。</p><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计算器模式  Counter（实现省略……）</p><h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>密码反馈模式  Cipher FeedBack（实现省略……）</p><h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>输出反馈模式  Output FeedBack（实现省略……）</p><p><strong>注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。</strong></p><p>在Java代码中，如何修改不同长度的密钥和填充模式？</p><p>AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg" alt></p><ol><li>kgen.init传入的第一个参数128决定了密钥的长度是<strong>128bit</strong>。</li><li>Cipher.getInstance(“AES/CBC/NoPadding”)决定了AES选择的填充方式是<strong>NoPadding</strong>，工作模式是<strong>CBC</strong>模式。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。</li><li>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</li></ol><h2 id="AES加密算法底层原理"><a href="#AES加密算法底层原理" class="headerlink" title="AES加密算法底层原理"></a>AES加密算法底层原理</h2><h3 id="AES加密步骤"><a href="#AES加密步骤" class="headerlink" title="AES加密步骤"></a>AES加密步骤</h3><ol><li>把明文按照128bit拆分成若干个明文块。</li><li>按照选择的填充方式来填充最后一个明文块。</li><li>每一个明文块利用AES加密器和密钥，加密成密文块。</li><li>拼接所有的密文块，成为最终的密文结果。</li></ol><h3 id="AES加密器需要经过多少轮加密"><a href="#AES加密器需要经过多少轮加密" class="headerlink" title="AES加密器需要经过多少轮加密"></a>AES加密器需要经过多少轮加密</h3><ul><li>初始轮（Initial Round） 1次</li><li>普通轮（Rounds）     N次</li><li>最终轮（Final Round）  1次</li></ul><p>上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。</p><h3 id="除去初始轮各种Key长度对应的轮数"><a href="#除去初始轮各种Key长度对应的轮数" class="headerlink" title="除去初始轮各种Key长度对应的轮数"></a>除去初始轮各种Key长度对应的轮数</h3><ul><li>AES128：10轮</li><li>AES192：12轮</li><li>AES256：14轮</li></ul><h3 id="不同阶段Round的处理步骤"><a href="#不同阶段Round的处理步骤" class="headerlink" title="不同阶段Round的处理步骤"></a>不同阶段Round的处理步骤</h3><p><strong>初始轮只有一个步骤</strong></p><ul><li>加轮密钥（AddRoundKey）</li></ul><p><strong>普通轮有四个步骤</strong></p><ul><li><p>字节代替（SubBytes）</p><p>首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为<strong>S盒</strong>（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。</p></li><li><p>行移位（ShiftRows）</p><p>这一步很简单，就像图中所描述的：第一行不变，第二行循环左移<strong>1</strong>个字节，第三行循环左移<strong>2</strong>个字节，第四行循环左移<strong>3</strong>个字节。</p></li><li><p>列混淆（MixColumns）</p><p>这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。</p></li><li><p>加轮密钥（AddRoundKey）</p><p>这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：<strong>扩展密钥</strong>（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ……一直到W{160-175}用于最终轮（第10轮）的处理。</p></li></ul><p><strong>最终轮有三个步骤</strong></p><ul><li>字节代替（SubBytes）</li><li>行移位（ShiftRows）</li><li>加轮密钥（AddRoundKey）</li></ul><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p>解密流程基本是把加密流程倒置过来，顺序变为 最终轮-&gt;普通轮-&gt;初始轮。扩展密钥的使用顺序也和加密相反。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AES算法的特点&quot;&gt;&lt;a href=&quot;#AES算法的特点&quot; class=&quot;headerlink&quot; title=&quot;AES算法的特点&quot;&gt;&lt;/a&gt;AES算法的特点&lt;/h2&gt;&lt;p&gt;AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客&lt;a href=&quot;http://www.lishaojie.top/2019/07/04/MD5/&quot;&gt;《MD5底层实现和解密方法》&lt;/a&gt;所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。&lt;/p&gt;
&lt;h3 id=&quot;密钥&quot;&gt;&lt;a href=&quot;#密钥&quot; class=&quot;headerlink&quot; title=&quot;密钥&quot;&gt;&lt;/a&gt;密钥&lt;/h3&gt;&lt;p&gt;密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用&lt;strong&gt;同一个密钥&lt;/strong&gt;。AES支持三种长度的密钥：&lt;strong&gt;128位，192位，256位&lt;/strong&gt;。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。&lt;/p&gt;
&lt;p&gt;从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AES算法" scheme="https://www.lishaojie.top/tags/AES%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加密算法</title>
    <link href="https://www.lishaojie.top/2019/11/03/encryption/"/>
    <id>https://www.lishaojie.top/2019/11/03/encryption/</id>
    <published>2019-11-03T15:21:25.000Z</published>
    <updated>2020-03-11T14:13:48.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加密算法的种类"><a href="#加密算法的种类" class="headerlink" title="加密算法的种类"></a>加密算法的种类</h2><p>从宏观上来看，加密算法可以归结为三大类：<strong>哈希算法、对称加密算法、非对称加密算法。</strong></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从严格意义上来说，<strong>哈希算法并不属于加密算法</strong>，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是<strong>生成信息摘要</strong>，用以验证原信息的完整性和来源的可靠性。</p><p>举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，<strong>Hash（1234_100_abc） = 948569CD3466451F</strong>）<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg" alt></p><p>请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。</p><p>生成信息摘要的过程叫做<strong>签名</strong>，验证信息摘要的过程叫做<strong>验签</strong>。</p><p>哈希算法最著名的当属<strong>MD5算法</strong>。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了<strong>SHA系列算法</strong>。</p><hr><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。</p><h3 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg" alt></p><p>如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。</p><p>除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。</p><h3 id="对称加密包含哪些算法？"><a href="#对称加密包含哪些算法？" class="headerlink" title="对称加密包含哪些算法？"></a>对称加密包含哪些算法？</h3><p>在早期，人们使用<strong>DES算法</strong>进行加密解密；后来，人们觉得DES不够安全，发明了<strong>3DES</strong>算法；而如今，最为流行的对称加密算法是<strong>AES算法</strong>。</p><h3 id="对称加密的优缺点"><a href="#对称加密的优缺点" class="headerlink" title="对称加密的优缺点"></a>对称加密的优缺点</h3><p>对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。</p><hr><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg" alt></p><p>如图所示，在非对称加密中存在一对密钥，一个叫做<strong>公钥</strong>，另一个叫做<strong>私钥</strong>。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属<strong>RSA算法</strong>。</p><h3 id="非对称加密的通信过程"><a href="#非对称加密的通信过程" class="headerlink" title="非对称加密的通信过程"></a>非对称加密的通信过程</h3><ol><li>在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。</li><li>客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。</li><li>服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。</li><li>从此以后，双方可以利用密钥X进行对称加密的通信了。</li></ol><h3 id="非对称加密的优缺点"><a href="#非对称加密的优缺点" class="headerlink" title="非对称加密的优缺点"></a>非对称加密的优缺点</h3><p>好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。</p><p>缺点是性能较差，无法应用于长期的通信。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加密算法的种类&quot;&gt;&lt;a href=&quot;#加密算法的种类&quot; class=&quot;headerlink&quot; title=&quot;加密算法的种类&quot;&gt;&lt;/a&gt;加密算法的种类&lt;/h2&gt;&lt;p&gt;从宏观上来看，加密算法可以归结为三大类：&lt;strong&gt;哈希算法、对称加密算法、非对称加密算法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h2&gt;&lt;p&gt;从严格意义上来说，&lt;strong&gt;哈希算法并不属于加密算法&lt;/strong&gt;，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是&lt;strong&gt;生成信息摘要&lt;/strong&gt;，用以验证原信息的完整性和来源的可靠性。&lt;/p&gt;
&lt;p&gt;举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，&lt;strong&gt;Hash（1234_100_abc） = 948569CD3466451F&lt;/strong&gt;）
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="加密算法" scheme="https://www.lishaojie.top/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密的底层实现和破解</title>
    <link href="https://www.lishaojie.top/2019/11/03/MD5/"/>
    <id>https://www.lishaojie.top/2019/11/03/MD5/</id>
    <published>2019-11-03T14:07:27.000Z</published>
    <updated>2020-03-11T14:15:26.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息摘要技术"><a href="#信息摘要技术" class="headerlink" title="信息摘要技术"></a>信息摘要技术</h2><p>信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。</p><p>MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。</p><h2 id="摘要哈希的生成过程"><a href="#摘要哈希的生成过程" class="headerlink" title="摘要哈希的生成过程"></a>摘要哈希的生成过程</h2><ol><li>收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</li><li>按照规则，把参数名和参数值拼接成一个字符串，同时把给定的<strong>密钥</strong>也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</li><li>利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。<a id="more"></a></li></ol><h2 id="第三方支付平台验证签名"><a href="#第三方支付平台验证签名" class="headerlink" title="第三方支付平台验证签名"></a>第三方支付平台验证签名</h2><ol><li>发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。</li><li>第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。</li><li>用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做<strong>验签</strong>。</li></ol><h2 id="MD5算法底层实现原理"><a href="#MD5算法底层实现原理" class="headerlink" title="MD5算法底层实现原理"></a>MD5算法底层实现原理</h2><p>简单概括起来，MD5算法的过程分为四步：</p><ol><li><p>处理原文</p><p>首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。</p></li><li><p>设置初始值</p><p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p><p>A=0x01234567</p><p>B=0x89ABCDEF</p><p>C=0xFEDCBA98</p><p>D=0x76543210</p></li><li><p>循环加工</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg" alt></p><p>图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = <strong>M / 512</strong>，每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。上面这张图所表达的就是<strong>单次子循环</strong>的流程。下面对图中其他元素一一解释：</p><p><strong>1.绿色F</strong></p><p>图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：</p><p>F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</p><p>G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</p><p>H(X, Y, Z) =X^Y^Z</p><p>I(X, Y, Z)=Y^(X|(~Z))</p><p>在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。</p><p><strong>2.红色“田”字</strong></p><p>很简单，红色的田字代表相加的意思。</p><p><strong>3.Mi</strong></p><p>Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0<del>M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1</del>M16之一。</p><p><strong>4.Ki</strong></p><p>一个常量，在64次子循环中，每一次用到的常量都是不同的。</p><p><strong>5.黄色的&lt;&lt;</strong></p><p>左移S位，S的值也是常量。</p></li><li><p>拼接结果</p><p>这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。</p></li></ol><hr><h2 id="MD5破解"><a href="#MD5破解" class="headerlink" title="MD5破解"></a>MD5破解</h2><p>这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。</p><p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。</p><h3 id="MD5碰撞方法"><a href="#MD5碰撞方法" class="headerlink" title="MD5碰撞方法"></a>MD5碰撞方法</h3><h4 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h4><p>顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。</p><h4 id="字典法"><a href="#字典法" class="headerlink" title="字典法"></a>字典法</h4><p>如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。</p><h4 id="彩虹表法"><a href="#彩虹表法" class="headerlink" title="彩虹表法"></a>彩虹表法</h4><p>彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：<strong>彩虹表</strong>。</p><p>彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。</p><h4 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h4><p>2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息摘要技术&quot;&gt;&lt;a href=&quot;#信息摘要技术&quot; class=&quot;headerlink&quot; title=&quot;信息摘要技术&quot;&gt;&lt;/a&gt;信息摘要技术&lt;/h2&gt;&lt;p&gt;信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。&lt;/p&gt;
&lt;p&gt;MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。&lt;/p&gt;
&lt;h2 id=&quot;摘要哈希的生成过程&quot;&gt;&lt;a href=&quot;#摘要哈希的生成过程&quot; class=&quot;headerlink&quot; title=&quot;摘要哈希的生成过程&quot;&gt;&lt;/a&gt;摘要哈希的生成过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。&lt;/li&gt;
&lt;li&gt;按照规则，把参数名和参数值拼接成一个字符串，同时把给定的&lt;strong&gt;密钥&lt;/strong&gt;也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。&lt;/li&gt;
&lt;li&gt;利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="MD5算法" scheme="https://www.lishaojie.top/tags/MD5%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存-Redis</title>
    <link href="https://www.lishaojie.top/2019/10/22/redis/"/>
    <id>https://www.lishaojie.top/2019/10/22/redis/</id>
    <published>2019-10-22T15:46:44.000Z</published>
    <updated>2020-03-11T14:15:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis单线程模型原理剖析？"><a href="#redis单线程模型原理剖析？" class="headerlink" title="redis单线程模型原理剖析？"></a>redis单线程模型原理剖析？</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p><h2 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h2><ol><li>纯内存操作。</li><li>核心是基于非阻塞的IO多路复用机制。</li><li>单线程——避免了多线程的频繁上下文切换问题。</li><li>Resp协议。<a id="more"></a></li></ol><h2 id="使用redis有什么缺点？"><a href="#使用redis有什么缺点？" class="headerlink" title="使用redis有什么缺点？"></a>使用redis有什么缺点？</h2><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩、缓存击穿</li><li>缓存的并发竞争</li></ul><h2 id="redis支持的数据类型和使用场景"><a href="#redis支持的数据类型和使用场景" class="headerlink" title="redis支持的数据类型和使用场景"></a>redis支持的数据类型和使用场景</h2><ol><li><p>string</p><p>最基本的类型，普通的set和get，做简单的key-value缓存。</p></li><li><p>hash</p><p>类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。</p></li><li><p>list</p><p>有序列表，这个是可以玩出很多花样的：</p><p>比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。</p><p>还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。</p></li><li><p>set</p><p>无序集合，自动去重。</p><p>如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。</p><p>还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。</p></li><li><p>sorted set</p><p>有序集合，自动去重。</p><p>这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。</p><p>比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。</p><p>排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。</p><p>zadd board 85 jack</p><p>zadd board 72 tom</p><p>zadd board 96 jerry</p><p>zrevrange board 0 2：可以查看前三名的排序结果</p><p>zrank board tom：返回3，意思是tom排名第3</p></li></ol><hr><h2 id="redis的过期策略有哪些"><a href="#redis的过期策略有哪些" class="headerlink" title="redis的过期策略有哪些"></a>redis的过期策略有哪些</h2><p><strong>定期删除+惰性删除</strong></p><p>所谓<strong>定期删除</strong>，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。</p><p>所谓<strong>惰性删除</strong>，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。</p><p>产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走<strong>内存淘汰机制</strong>了。</p><ol><li>no-enviction（驱逐）：禁止驱逐数据，再写入会报错。<strong>（默认，应该没人用）</strong></li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。<strong>（推荐使用）</strong></li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从<code>已设置过期时间的</code>数据集中挑选<code>将要过期的</code>数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li></ol><hr><h2 id="怎么保证redis的高并发-amp-高可用？"><a href="#怎么保证redis的高并发-amp-高可用？" class="headerlink" title="怎么保证redis的高并发&amp;高可用？"></a>怎么保证redis的高并发&amp;高可用？</h2><p>redis高并发：采用<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。</p><p>redis高可用：如果做主从架构部署，其实加上<strong>哨兵</strong>就可以了，任何一个实例宕机，都会自动切换。</p><h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑10+的<strong>读QPS</strong></p><p>首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 </p><h4 id="主从复制的核心原理"><a href="#主从复制的核心原理" class="headerlink" title="主从复制的核心原理"></a>主从复制的核心原理</h4><p>当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行<strong>增量复制</strong>，如果这是slave第一次连接master，会触发一次<strong>全量复制</strong>。</p><p>官方解释：</p><ol><li>slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。</li><li>slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。</li><li>slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。</li><li>master第一次执行全量复制，将所有数据发送给slave。</li><li>master后续还会持续将写命令异步发送给slave。</li></ol><p>全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。</p><p>增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。</p><h4 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h4><p>从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。</p><p>官方解释：</p><ol><li>master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。</li><li>master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。</li><li>master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。</li><li>从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。</li></ol><h4 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h4><p>在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。</p><h4 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h4><p>slave不会过期key，只会等待master过期key。</p><p>如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。</p><h4 id="redis的心跳检测机制"><a href="#redis的心跳检测机制" class="headerlink" title="redis的心跳检测机制"></a>redis的心跳检测机制</h4><p>在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。</p><h4 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h4><p>如果采用了主从架构，建议必须开启master node的持久化。</p><p>不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。</p><p>即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。</p><p><strong>持久化方式RDB和AOF</strong></p><ul><li>RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。</li><li>AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。</li></ul><p>如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。</p><p>如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。</p><p><strong>RDB的优点</strong></p><ol><li>RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。</li><li>RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。</li><li>通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。</li></ol><p><strong>RDB的缺点</strong></p><ol><li>最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。</li><li>RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。</li></ol><p><strong>AOF的优点</strong></p><ol><li>AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。</li><li>AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。</li><li>AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。</li><li>AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。</li></ol><p><strong>AOF的缺点</strong></p><ol><li>最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。</li><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li><li>AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。</li><li>如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。</li><li>AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。</li></ol><p><strong>RDB和AOF到底如何选择</strong></p><ul><li>不要仅仅使用RDB，因为那样会导致丢失很多数据。</li><li>也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。</li><li>所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。</li></ul><hr><h3 id="redis的哨兵机制"><a href="#redis的哨兵机制" class="headerlink" title="redis的哨兵机制"></a>redis的哨兵机制</h3><p>sentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：</p><ol><li>集群监控：负责监控redis master和slave进程是否正常工作。</li><li>消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。</li><li>故障转移：如果master挂掉了，会自动转移到slave上。</li><li>配置中心：如果故障转移发生了，把新的master地址通知到客户端。</li></ol><p>哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。</p><ol><li>故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。</li></ol><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ol><li>哨兵至少需要3个实例，来保证自己的健壮性。</li><li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。</li><li>对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。</li></ol><p><strong>为什么redis哨兵集群少于3个节点无法正常工作</strong></p><p>如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。</p><h4 id="sdown和odown转换机制？"><a href="#sdown和odown转换机制？" class="headerlink" title="sdown和odown转换机制？"></a>sdown和odown转换机制？</h4><p>master宕机有sdown和odown两种失败状态</p><ul><li>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。</li><li>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。</li><li>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了</li><li>sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。</li></ul><h4 id="哨兵和slave集群的自动发现机制"><a href="#哨兵和slave集群的自动发现机制" class="headerlink" title="哨兵和slave集群的自动发现机制"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往_sentinel_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的_sentinel_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p><h4 id="slave-master选举算法"><a href="#slave-master选举算法" class="headerlink" title="slave-master选举算法"></a>slave-master选举算法</h4><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。</p><p><strong>从节点过滤</strong>：判断跟master断开连接的时长</p><p>如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。</p><ol><li>slave配置的优先级（slave-priority=100）</li><li>复制offset</li><li>run id</li></ol><p>说明：</p><ol><li>然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。</li><li>如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li></ol><h4 id="slave配置的自动纠正"><a href="#slave配置的自动纠正" class="headerlink" title="slave配置的自动纠正"></a>slave配置的自动纠正</h4><p>哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。</p><h4 id="quorum和majority"><a href="#quorum和majority" class="headerlink" title="quorum和majority"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。</p><p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。</p><p>如果quorum &gt;= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。</p><h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><p>哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。</p><h4 id="configuration传播"><a href="#configuration传播" class="headerlink" title="configuration传播"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。</p><p>这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p><hr><h2 id="异步复制和集群脑裂导致数据丢失"><a href="#异步复制和集群脑裂导致数据丢失" class="headerlink" title="异步复制和集群脑裂导致数据丢失"></a>异步复制和集群脑裂导致数据丢失</h2><p>场景一：异步复制导致的数据丢失</p><p>client往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。</p><p>场景二：集群脑裂导致的数据丢失</p><p>master出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。</p><p><strong>如何降低损失？</strong></p><ul><li>min-slaves-to-write 1</li><li>min-slaves-max-lag 10</li></ul><p>配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。</p><p>上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。</p><hr><h2 id="分布式集群-redis-cluster"><a href="#分布式集群-redis-cluster" class="headerlink" title="分布式集群-redis cluster"></a>分布式集群-redis cluster</h2><ol><li>自动将数据进行分片，每个master上放一部分数据。</li><li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的。</li></ol><p>redis cluster可以突破单机redis在海量数据面前的瓶颈。</p><p><strong>redis cluster VS replication+sentinal</strong></p><p>如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。</p><h3 id="分布式数据存储的核心算法"><a href="#分布式数据存储的核心算法" class="headerlink" title="分布式数据存储的核心算法"></a>分布式数据存储的核心算法</h3><h4 id="最老土的hash算法和弊端"><a href="#最老土的hash算法和弊端" class="headerlink" title="最老土的hash算法和弊端"></a>最老土的hash算法和弊端</h4><p>把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到<strong>大量的缓存重建</strong>，这是致命的。</p><h4 id="一致性hash算法-自动缓存迁移"><a href="#一致性hash算法-自动缓存迁移" class="headerlink" title="一致性hash算法(自动缓存迁移)"></a>一致性hash算法(自动缓存迁移)</h4><p>有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。</p><h4 id="一致性hash算法-虚拟节点"><a href="#一致性hash算法-虚拟节点" class="headerlink" title="一致性hash算法+虚拟节点"></a>一致性hash算法+虚拟节点</h4><p>基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的<strong>负载均衡</strong>。</p><h4 id="hash-slot算法"><a href="#hash-slot算法" class="headerlink" title="hash slot算法"></a>hash slot算法</h4><p>redis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。</p><hr><h3 id="redis集群模式的工作原理"><a href="#redis集群模式的工作原理" class="headerlink" title="redis集群模式的工作原理"></a>redis集群模式的工作原理</h3><h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p><strong>基础通信原理</strong></p><p>redis cluster节点间采用<strong>gossip</strong>协议进行通信。</p><p>跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。</p><ul><li>集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。</li><li>gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。</li></ul><p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。</p><p><strong>gossip协议</strong></p><p>gossip协议包含多种消息，包括ping、pong、meet、fail等。</p><ul><li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。</li><li>ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。</li><li>pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。</li><li>fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li></ul><p><strong>ping消息深入</strong></p><p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。</p><hr><p>jedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -&gt; node的映射表缓存。</p><h4 id="高性能与主备切换原理"><a href="#高性能与主备切换原理" class="headerlink" title="高性能与主备切换原理"></a>高性能与主备切换原理</h4><p>redis cluster的高可用原理，几乎和哨兵是一样的。</p><ol><li><p>判断节点宕机</p><p>如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。</p></li><li><p>从节点过滤</p><p>对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。</p></li><li><p>master选举</p><p>每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。</p></li></ol><p>综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。</p><hr><h2 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：指在某一时间段，缓存集体失效。</p><h4 id="造成缓存雪崩的原因"><a href="#造成缓存雪崩的原因" class="headerlink" title="造成缓存雪崩的原因"></a>造成缓存雪崩的原因</h4><ol><li>比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。</li><li>缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</li></ol><h4 id="如何预防缓存雪崩？"><a href="#如何预防缓存雪崩？" class="headerlink" title="如何预防缓存雪崩？"></a>如何预防缓存雪崩？</h4><p>针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p><p>针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。</p><h4 id="缓存雪崩了如何恢复？"><a href="#缓存雪崩了如何恢复？" class="headerlink" title="缓存雪崩了如何恢复？"></a>缓存雪崩了如何恢复？</h4><p>本地ehcache缓存+hystrix限流&amp;降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。</p><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。</p><h4 id="造成缓存穿透的原因"><a href="#造成缓存穿透的原因" class="headerlink" title="造成缓存穿透的原因"></a>造成缓存穿透的原因</h4><p>代码bug或者恶意攻击。</p><h4 id="如何预防缓存穿透？"><a href="#如何预防缓存穿透？" class="headerlink" title="如何预防缓存穿透？"></a>如何预防缓存穿透？</h4><p>如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p><hr><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><h3 id="如何预防缓存击穿？"><a href="#如何预防缓存击穿？" class="headerlink" title="如何预防缓存击穿？"></a>如何预防缓存击穿？</h3><p>这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。</p><hr><h2 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性"></a>如何保证缓存与数据库的双写一致性</h2><h3 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h3><p>最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）</p><ol><li>读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。</li><li>更新的时候，<strong>先删除缓存，再更新数据库</strong>，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。</li></ol><p>为什么是删除缓存，而不是更新缓存呢？</p><p>原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。</p><p>其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。</p><hr><h3 id="高并发场景下的数据不一致"><a href="#高并发场景下的数据不一致" class="headerlink" title="高并发场景下的数据不一致"></a>高并发场景下的数据不一致</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>把数据库与缓存的更新读取操作进行异步串行化。</p><ul><li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。</li><li>读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。</li></ul><p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p><p>这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。</p><h4 id="解决方案需要注意的问题"><a href="#解决方案需要注意的问题" class="headerlink" title="解决方案需要注意的问题"></a>解决方案需要注意的问题</h4><p><strong>读请求 长时间堵塞</strong></p><p>由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。</p><p>该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。</p><p><strong>读请求 并发量过高</strong></p><p>上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。</p><p><strong>多服务实例部署的请求路由</strong></p><p>可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。</p><p><strong>热点商品的路由问题</strong></p><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。</p><p>因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。</p><hr><h2 id="如何保证redis并发竞争的数据一致性"><a href="#如何保证redis并发竞争的数据一致性" class="headerlink" title="如何保证redis并发竞争的数据一致性"></a>如何保证redis并发竞争的数据一致性</h2><p>客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redis单线程模型原理剖析？&quot;&gt;&lt;a href=&quot;#redis单线程模型原理剖析？&quot; class=&quot;headerlink&quot; title=&quot;redis单线程模型原理剖析？&quot;&gt;&lt;/a&gt;redis单线程模型原理剖析？&lt;/h2&gt;&lt;p&gt;redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。&lt;/p&gt;
&lt;h2 id=&quot;redis为什么这么快？&quot;&gt;&lt;a href=&quot;#redis为什么这么快？&quot; class=&quot;headerlink&quot; title=&quot;redis为什么这么快？&quot;&gt;&lt;/a&gt;redis为什么这么快？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;纯内存操作。&lt;/li&gt;
&lt;li&gt;核心是基于非阻塞的IO多路复用机制。&lt;/li&gt;
&lt;li&gt;单线程——避免了多线程的频繁上下文切换问题。&lt;/li&gt;
&lt;li&gt;Resp协议。
    
    </summary>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="redis" scheme="https://www.lishaojie.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>链表“逆序”算法</title>
    <link href="https://www.lishaojie.top/2019/09/18/LinkedList-Reverse/"/>
    <id>https://www.lishaojie.top/2019/09/18/LinkedList-Reverse/</id>
    <published>2019-09-18T14:06:48.000Z</published>
    <updated>2020-03-11T14:15:01.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆序本质"><a href="#逆序本质" class="headerlink" title="逆序本质"></a>逆序本质</h2><p>链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。</li><li>以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>三个临时节点的引用分别向后移动一格位置。</li><li>重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>重复第3步的工作，三个临时节点分别向后移动一格位置。</li><li>继续这样迭代下去，直到p2是空为止。</li><li>最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。<a id="more"></a></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Node head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里head是静态成员，其实也可以作为方法参数传入</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//算法实现</span>  Node p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>  Node p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  Node p3 <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    p3 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p3赋值</span>    p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p2指向p1</span>    p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p1赋值</span>    p2 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p2赋值</span>  <span class="token punctuation">}</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指向null</span>  head <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给head赋值</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义节点</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span>  Node next<span class="token punctuation">;</span>  <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//初始化链表</span>  head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给头节点赋值</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//头节点的next指向新节点6</span>  Node temp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义临时节点并赋值</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//临时节点的next指向新节点1</span>  temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//临时节点指针后移</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出初始化的链表</span>  temp <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//调用逆序链表的方法</span>  <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出逆序后的链表</span>  temp <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆序本质&quot;&gt;&lt;a href=&quot;#逆序本质&quot; class=&quot;headerlink&quot; title=&quot;逆序本质&quot;&gt;&lt;/a&gt;逆序本质&lt;/h2&gt;&lt;p&gt;链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。&lt;/li&gt;
&lt;li&gt;以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。&lt;/li&gt;
&lt;li&gt;三个临时节点的引用分别向后移动一格位置。&lt;/li&gt;
&lt;li&gt;重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。&lt;/li&gt;
&lt;li&gt;重复第3步的工作，三个临时节点分别向后移动一格位置。&lt;/li&gt;
&lt;li&gt;继续这样迭代下去，直到p2是空为止。&lt;/li&gt;
&lt;li&gt;最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表逆序算法" scheme="https://www.lishaojie.top/tags/%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
