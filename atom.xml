<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>睡到自然醒</title>
  
  <subtitle>Do what you love,Love what you do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.lishaojie.top/"/>
  <updated>2020-02-28T01:19:48.745Z</updated>
  <id>https://www.lishaojie.top/</id>
  
  <author>
    <name>lishaojie-C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM底层原理与性能优化</title>
    <link href="https://www.lishaojie.top/2020/02/22/jvm/"/>
    <id>https://www.lishaojie.top/2020/02/22/jvm/</id>
    <published>2020-02-22T14:28:22.000Z</published>
    <updated>2020-02-28T01:19:48.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、JVM基础知识"><a href="#1、JVM基础知识" class="headerlink" title="1、JVM基础知识"></a>1、JVM基础知识</h3><h4 id="JVM由哪些部分组成？"><a href="#JVM由哪些部分组成？" class="headerlink" title="JVM由哪些部分组成？"></a>JVM由哪些部分组成？</h4><ol><li><strong>类加载器</strong>（ClassLoader）</li><li><strong>运行时数据区</strong>（Runtime Data Area）</li><li><strong>执行引擎</strong>（Execution Engine）</li><li><strong>本地库接口</strong>（Native Interface）</li></ol><h4 id="各组成部分的用途？"><a href="#各组成部分的用途？" class="headerlink" title="各组成部分的用途？"></a>各组成部分的用途？</h4><p>程序在执行之前先要把java代码转换成字节码(class文件)，jvm需要把字节码通过<strong>类加载器</strong>把文件加载到内存中<strong>(运行时数据区)</strong>，而字节码文件是jvm的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器<strong>(执行引擎)</strong>将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口<strong>(本地库接口)</strong>来实现整个程序的功能。</p><h4 id="类加载器是什么？"><a href="#类加载器是什么？" class="headerlink" title="类加载器是什么？"></a>类加载器是什么？</h4><p>顾名思义，类加载器用来加载 Java 类到 jvm 中。</p><p>类加载器把 Java 字节码转换成 java.lang.Class 类的一个实例。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><ol><li><p>加载：程序运行之前jvm通过<strong>类加载器</strong>把编译完成的.class二进制文件加载到内存，供程序使用。</p></li><li><p>连接：</p><p>验证：确保类加载的正确性。（可能有的class文件是通过其他方式编译出来的）</p><p>准备：为类的<strong>静态变量</strong>分配内存，将其初始化为<strong>默认值</strong> 。（int为0，boolean为false）</p><p>解析：把类中的符号引用转化为直接引用。（比如把方法名改为方法的内存地址）</p></li><li><p>初始化：为类的静态变量赋予正确的初始值。（程序编写的值是真正的初始值）</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcb1tmkh5oj30hl05j3zc.jpg" alt></p><h3 id="2、Java内存模型"><a href="#2、Java内存模型" class="headerlink" title="2、Java内存模型"></a>2、Java内存模型</h3><h4 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h4><ul><li>Java内存模型本身是一种抽象的概念，并不真实存在，它描述的是一种规范，定义了程序中各个变量的访问方式。</li><li>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了共享变量的副本。</li></ul><h4 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h4><p>线程通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p><ul><li><p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来<strong>隐式</strong>进行通信，典型的共享内存通信方式就是通过<strong>共享对象</strong>进行通信。</p></li><li><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来<strong>显式</strong>进行通信，在java中典型的消息传递方式就是wait()和notify()。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcb0wr021kj30c80akt92.jpg" alt></p><h4 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h4><ol><li><p><strong>程序计数器</strong></p><p>程序计数器是一块较小的内存空间，可以看作当前线程正在执行的字节码的行号指示器。</p><p>程序计数器有两个作用：实现<strong>流程控制</strong>(循环、异常处理)和<strong>记录执行位置</strong>(多线程切换)。</p><p>线程私有，是唯一一个不会出现OutOfMemoryError的内存区域。</p><p>注意：如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。</p></li><li><p><strong>Java虚拟机栈</strong></p><p>描述Java方法运行过程的内存模型。</p><p>Java虚拟机栈会为每一个即将运行的方法创建<strong>“栈帧”(局部变量表、操作数栈、动态链接、方法出口)</strong>。</p><p>当Java方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。</p><p>线程私有，会出现StackOverFlowError和OutOfMemoryError两种异常。</p><p>注意：人们常说“堆”用来存放对象，“栈”用来存放局部变量不完全正确，只体现了栈的局部变量表部分。</p></li><li><p><strong>本地方法栈</strong></p><p>描述本地方法运行的内存模型。</p><p>本地方法被执行的时候，步骤和Java方法类似，执行完毕后相应的栈帧也会出栈并释放内存空间。</p></li><li><p><strong>堆</strong></p><p>用来<strong>存储对象</strong>的内存模型。</p><p>线程共享，堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。</p><p>可以进一步细分为：新生代、老年代。 新生代又可被分为：Eden、From Survior、To Survior。 </p><p>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，不够用会抛出OutOfMemoryError。 </p></li><li><p><strong>方法区</strong></p><p>是堆的一个逻辑部分，用于存储被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等。 </p><p><strong>运行时常量池：是方法区的一部分</strong>，用于存放编译器生成的各种字面量和符号引用。</p></li></ol><p><strong>总结</strong>：</p><ul><li><p>程序计数器、Java虚拟机栈、本地方法栈是<strong>线程私有</strong>的，生命周期随着线程的创建而创建，随着线程的结束而死亡。 </p></li><li><p>堆、方法区是<strong>线程共享</strong>的，在JVM中只有一个堆、一个方法区。在JVM启动的时候就创建，JVM停止才销毁。</p></li><li><p><strong>StackOverFlowError</strong>： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 </p></li><li><p><strong>OutOfMemoryError</strong>： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li><li><p><strong>StackOverFlowError和OutOfMemoryError的异同？</strong> </p><p>StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 </p><p>而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 </p></li></ul><h3 id="3、类加载器的双亲委派模型"><a href="#3、类加载器的双亲委派模型" class="headerlink" title="3、类加载器的双亲委派模型"></a>3、类加载器的双亲委派模型</h3><ol><li><p><strong>什么是双亲委派模型？</strong></p><p>双亲委派模型会保证父类加载器先加载类。（延伸：jvm判定两个类相同，不仅类名一致，还要被同一类加载器加载）</p></li><li><p><strong>双亲委派模型的工作过程？</strong></p><ul><li><p>当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p><p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p></li><li><p>当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p></li><li><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p></li></ul></li><li><p><strong>为什么这样设计(双亲委派的好处)？</strong></p><p>主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException.</p></li></ol><h3 id="4、JVM垃圾收集算法与收集器"><a href="#4、JVM垃圾收集算法与收集器" class="headerlink" title="4、JVM垃圾收集算法与收集器"></a>4、JVM垃圾收集算法与收集器</h3><ol><li><p><strong>如何判断一个对象是否已经死去？</strong></p><ul><li><p><strong>引用计数算法</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p><strong>可达性分析算法</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p><strong>GC Root</strong>：虚拟机栈(局部变量表)中引用的对象、方法区中类的静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象。</p></li></ul></li><li><p><strong>垃圾回收算法有哪些？</strong></p><ul><li><p><strong>复制算法</strong>：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。</p><p>优点：效率高，不会产生碎片。</p><p>缺点：可用内存变为原来的一半，存活对象多时效率低（复制成本大）。</p></li><li><p><strong>标记-清除算法</strong>：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><p>优点：相比与复制算法来说不浪费内存。</p><p>缺点：会产生内存碎片，效率低（需要扫描两次）。</p></li><li><p><strong>标记-整理算法</strong>：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。</p><p>优点：避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</p><p>缺点：效率比复制算法低，需要多维护一个链表使幸存对象连续。</p></li><li><p><strong>分代收集算法</strong>：一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p></li></ul></li><li><p><strong>GC什么时候开始？</strong></p><p>GC经常发生的区域是堆区，堆区还可以细分为新生代1/3、老年代2/3，新生代还分为一个Eden区8/10和两个Survivor1/10区。</p><ul><li><p><strong>Minor GC</strong>，发生在新生代的GC，对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快;</p></li><li><p><strong>Full GC</strong>，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝;</p></li><li><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p></li></ul></li><li><p><strong>引用的分类？</strong></p><p><strong>强引用</strong>：通过new出来的引用，只要强引用还存在，则不会回收。</p><p><strong>软引用</strong>：在内存不足的情况下，会被jvm回收。通过SoftReference类来实现。</p><p><strong>弱引用</strong>：非必须对象，只要已发生GC就会把它干掉。通过WeakReference类来实现。</p><p><strong>虚引用</strong>：相当于没有引用，被jvm干掉会收到系统通知。通过PhantomReference类来实现。</p></li><li><p><strong>垃圾收集器？</strong></p><ul><li><p><strong>Serial收集器</strong>：串行收集器效率很高，可能会产生较长的停顿，<strong>单线程-复制算法</strong>。</p></li><li><p><strong>ParNew收集器</strong>：Serial收集器的多线程版本，<strong>多线程-复制算法</strong>。</p></li><li><p><strong>Parallel Scavenge收集器</strong>：Parallel Scavenge收集器类似ParNew收集器，可以通过参数来打开<strong>自适应调节策略</strong>，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。（<strong>多线程-复制算法</strong>）</p></li><li><p><strong>Serial Old收集器</strong>：Serial的老年代版本，<strong>单线程-标记-整理算法</strong></p></li><li><p><strong>Parallel Old 收集器</strong>：Parallel Scavenge的老年代版本，在老年代提供吞吐量优先。<strong>多-标记-整理</strong></p></li><li><p><strong>CMS收集器</strong>：是一种以获取最短回收停顿时间为目标的收集器，给用户带来较好的体验。<strong>多-标记-清除</strong></p><p><strong>优点：并发收集、低停顿。</strong></p><p><strong>缺点：产生大量空间碎片、并发阶段会降低吞吐量。</strong></p></li><li><p><strong>G1收集器</strong>：Garbage First 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。<strong>标记-整理</strong></p><p><strong>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。</strong></p><p><strong>可预测停顿，在不牺牲吞吐量的前提下，实现低停顿垃圾回收。</strong></p><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分(可以不连续)Region的集合。</p></li></ul></li></ol><h3 id="5、JVM生产问题的排查与解决"><a href="#5、JVM生产问题的排查与解决" class="headerlink" title="5、JVM生产问题的排查与解决"></a>5、JVM生产问题的排查与解决</h3><h4 id="生产服务器变慢，谈谈诊断思路和性能评估（常用的linux命令）"><a href="#生产服务器变慢，谈谈诊断思路和性能评估（常用的linux命令）" class="headerlink" title="生产服务器变慢，谈谈诊断思路和性能评估（常用的linux命令）"></a>生产服务器变慢，谈谈诊断思路和性能评估（常用的linux命令）</h4><h4 id="整机：top"><a href="#整机：top" class="headerlink" title="整机：top"></a>整机：top</h4><ul><li><p>右上角<strong>load average</strong>：3个值代表1分钟，5分钟，15分钟系统的平均负载值，3个值相加除以3乘以100%，如果结果高于60%，说明系统的负载压力很大。（也可以直接输入uptime查看负载精简版）</p></li><li><p>查看<strong>%CPU</strong>和内存<strong>%MEM</strong>的占用比例。</p></li></ul><h4 id="CPU：vmstat-n-2-3"><a href="#CPU：vmstat-n-2-3" class="headerlink" title="CPU：vmstat -n 2 3"></a>CPU：vmstat -n 2 3</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcb49fonjej3148064gne.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcb4dp2a9kj31b10e7n9w.jpg" alt></p><ul><li><strong>id</strong>：处于空闲的CPU百分比；</li><li><strong>wa</strong>：系统等待IO的CPU时间百分比；</li><li><strong>st</strong>：来自于一个虚拟机偷取的CPU时间的百分比。</li></ul><h4 id="内存：free-m"><a href="#内存：free-m" class="headerlink" title="内存：free -m"></a>内存：free -m</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcb849y0dcj314u0c442f.jpg" alt></p><p><strong>查看额外：pidstat -p 进程号 -r 采样间隔秒数</strong></p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gcb86vzxduj30sw070tc6.jpg" alt></p><h4 id="硬盘：df-h"><a href="#硬盘：df-h" class="headerlink" title="硬盘：df -h"></a>硬盘：df -h</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcb93btg9wj30y00d27o5.jpg" alt></p><h4 id="磁盘IO：iostat-xdk-2-3"><a href="#磁盘IO：iostat-xdk-2-3" class="headerlink" title="磁盘IO：iostat -xdk 2 3"></a>磁盘IO：iostat -xdk 2 3</h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcbap9iegoj31po0ke4iz.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcbalqfgp2j317c0cz7fs.jpg" alt></p><p><strong>查看额外：pidstat -d 采样间隔秒数 -p 进程号</strong> </p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcbau03v5mj314e0awdpt.jpg" alt></p><h4 id="网络IO：ifstat"><a href="#网络IO：ifstat" class="headerlink" title="网络IO：ifstat"></a>网络IO：<strong>ifstat</strong></h4><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcbb07rl5uj312s09wgq6.jpg" alt></p><h4 id="假如生产环境出现CPU占用过高，谈谈分析思路和定位（印象深刻的故障）"><a href="#假如生产环境出现CPU占用过高，谈谈分析思路和定位（印象深刻的故障）" class="headerlink" title="假如生产环境出现CPU占用过高，谈谈分析思路和定位（印象深刻的故障）"></a>假如生产环境出现CPU占用过高，谈谈分析思路和定位（印象深刻的故障）</h4><ol><li><p>先用top命令找出CPU占比最高的。</p></li><li><p>ps -ef | grep java | grep -v grep 或者 jps -l 进一步定位，得知是什么应用程序——PID。</p></li><li><p><strong>定位到具体线程或者代码。(ps -mp 进程号 -o THREAD,tid,time)</strong>——tid线程ID。</p><p>-m：显示所有的<strong>线程</strong>、-p：进程使用的CPU时间、-o：该参数后是用户自定义格式。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcbbei6igzj30nq06ugqb.jpg" alt></p></li><li><p>将需要的线程ID转换为16进制格式（<strong>英文小写格式</strong>）</p></li><li><p><strong>jstack 进程ID | grep tid (16进制线程ID) -A60</strong>（打印60行）</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gcbbop4eloj30z40hfwqd.jpg" alt></p></li><li><p>成功定位到异常代码在JavaDemo02.java中——第10行，查看代码分析原因并修复。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、JVM基础知识&quot;&gt;&lt;a href=&quot;#1、JVM基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、JVM基础知识&quot;&gt;&lt;/a&gt;1、JVM基础知识&lt;/h3&gt;&lt;h4 id=&quot;JVM由哪些部分组成？&quot;&gt;&lt;a href=&quot;#JVM由哪些部分组成？&quot; c
      
    
    </summary>
    
    
    
      <category term="jvm" scheme="https://www.lishaojie.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>几何星空连线背景-canvas</title>
    <link href="https://www.lishaojie.top/2020/02/05/star/"/>
    <id>https://www.lishaojie.top/2020/02/05/star/</id>
    <published>2020-02-05T15:10:37.000Z</published>
    <updated>2020-02-28T14:20:29.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近受疫情的影响，整天宅在家无所事事，闲的蛋疼的我最终对博客下手了，给自己的博客添加一个炫酷的背景，试了各种图片，GIF，视频，炫酷效果有了不过CPU占用太高，浏览体验不佳，最后还是选择了几何星空背景，参考网上大神的代码自己改了一份，效果如下。</p><h2 id="星空入口"><a href="#星空入口" class="headerlink" title="星空入口"></a>星空入口</h2><p>点击传送门可以预览效果：<a href="https://lishaojie1993.gitee.io/demo/star.html" target="_blank" rel="noopener">传送门</a><a id="more"></a></p><h2 id="预览实现"><a href="#预览实现" class="headerlink" title="预览实现"></a>预览实现</h2><h4 id="1、在GitHub上新建repository"><a href="#1、在GitHub上新建repository" class="headerlink" title="1、在GitHub上新建repository"></a>1、在GitHub上新建repository</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc1thz4junj316s0my7ej.jpg" alt></p><h4 id="2、点击setting，修改GitHub-Pages"><a href="#2、点击setting，修改GitHub-Pages" class="headerlink" title="2、点击setting，修改GitHub Pages"></a>2、点击setting，修改GitHub Pages</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc1tjizss0j316k0k47d1.jpg" alt></p><h4 id="3、将网页文件上传到GitHub（访问www-lishaojie-top-demo-star-html实现预览）"><a href="#3、将网页文件上传到GitHub（访问www-lishaojie-top-demo-star-html实现预览）" class="headerlink" title="3、将网页文件上传到GitHub（访问www.lishaojie.top/demo/star.html实现预览）"></a>3、将网页文件上传到GitHub（访问<a href="http://www.lishaojie.top/demo/star.html实现预览）">www.lishaojie.top/demo/star.html实现预览）</a></h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc1tp8p8a3j31j00k0k0f.jpg" alt></p><hr><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>几何星空连线背景<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>canvas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 可调参数</span><span class="token keyword">var</span> BACKGROUND_COLOR <span class="token operator">=</span> <span class="token string">"rgba(0,43,54,1)"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 背景颜色</span><span class="token keyword">var</span> POINT_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 星星数目</span><span class="token keyword">var</span> POINT_COLOR <span class="token operator">=</span> <span class="token string">"rgba(255,255,255,0.7)"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 点的颜色</span><span class="token keyword">var</span> LINE_LENGTH <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 点之间连线长度(的平方)</span><span class="token comment" spellcheck="true">// 创建背景画布</span><span class="token keyword">var</span> cvs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">"\    position:fixed;\    top:0px;\    left:0px;\    z-index:-1;\    opacity:1.0;\    "</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>cvs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> ctx <span class="token operator">=</span> cvs<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> startTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机数函数</span><span class="token keyword">function</span> <span class="token function">randomInt</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//构造点类</span><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> speed <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> angle <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> POINT_COLOR<span class="token punctuation">;</span><span class="token punctuation">}</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>move <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">></span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">></span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>draw <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">initPoints</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        points<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//鼠标</span>p0<span class="token punctuation">.</span>dx <span class="token operator">=</span> p0<span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> degree <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span>onmousedown <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    degree <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span>onmouseup <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    degree <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>window<span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">drawLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> deg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> dx <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token keyword">var</span> dy <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token keyword">var</span> dis2 <span class="token operator">=</span> dx <span class="token operator">*</span> dx <span class="token operator">+</span> dy <span class="token operator">*</span> dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dis2 <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dis2 <span class="token operator">></span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">===</span> p0<span class="token punctuation">)</span> <span class="token punctuation">{</span>                p2<span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> dx <span class="token operator">*</span> <span class="token number">0.03</span><span class="token punctuation">;</span>                p2<span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> dy <span class="token operator">*</span> <span class="token number">0.03</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.05</span> <span class="token operator">-</span> dis2 <span class="token operator">/</span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.2</span> <span class="token operator">*</span> deg<span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>strokeStyle <span class="token operator">=</span> <span class="token string">"rgba(255,255,255,"</span> <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>lineWidth <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//绘制每一帧</span><span class="token keyword">function</span> <span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cvs<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>    cvs<span class="token punctuation">.</span>height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> BACKGROUND_COLOR<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span>p0<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> points <span class="token punctuation">:</span> <span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawLine</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>drawFrame<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">initPoints</span><span class="token punctuation">(</span>POINT_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近受疫情的影响，整天宅在家无所事事，闲的蛋疼的我最终对博客下手了，给自己的博客添加一个炫酷的背景，试了各种图片，GIF，视频，炫酷效果有了不过CPU占用太高，浏览体验不佳，最后还是选择了几何星空背景，参考网上大神的代码自己改了一份，效果如下。&lt;/p&gt;
&lt;h2 id=&quot;星空入口&quot;&gt;&lt;a href=&quot;#星空入口&quot; class=&quot;headerlink&quot; title=&quot;星空入口&quot;&gt;&lt;/a&gt;星空入口&lt;/h2&gt;&lt;p&gt;点击传送门可以预览效果：&lt;a href=&quot;https://lishaojie1993.gitee.io/demo/star.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;
    
    </summary>
    
    
    
      <category term="star-line" scheme="https://www.lishaojie.top/tags/star-line/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 防火墙设置-iptables</title>
    <link href="https://www.lishaojie.top/2020/01/17/firewall/"/>
    <id>https://www.lishaojie.top/2020/01/17/firewall/</id>
    <published>2020-01-17T07:29:48.000Z</published>
    <updated>2020-02-19T09:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关闭默认防火墙"><a href="#关闭默认防火墙" class="headerlink" title="关闭默认防火墙"></a>关闭默认防火墙</h3><p>CentOS 7默认使用的防火墙是firewall，需要将其关闭</p><ul><li>systemctl stop firewalld.service #停止firewall</li><li>systemctl disable firewalld.service #禁止firewall开机启动</li></ul><h3 id="安装-iptables-service"><a href="#安装-iptables-service" class="headerlink" title="安装 iptables service"></a>安装 iptables service</h3><p>yum -y install iptables-services <a id="more"></a></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>vi /etc/sysconfig/iptables </p><h3 id="在配置文件中增加规则"><a href="#在配置文件中增加规则" class="headerlink" title="在配置文件中增加规则"></a>在配置文件中增加规则</h3><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p><h3 id="保存退出，重启防火墙"><a href="#保存退出，重启防火墙" class="headerlink" title="保存退出，重启防火墙"></a>保存退出，重启防火墙</h3><ul><li>systemctl restart iptables.service #重启防火墙使配置生效</li><li>systemctl enable iptables.service #设置防火墙开机启动</li></ul><h3 id="iptables防火墙常用命令"><a href="#iptables防火墙常用命令" class="headerlink" title="iptables防火墙常用命令"></a>iptables防火墙常用命令</h3><ul><li>systemctl start iptables.service #打开防火墙</li><li>systemctl stop iptables.service #关闭防火墙</li><li>systemctl restart iptables.service #重启防火墙</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关闭默认防火墙&quot;&gt;&lt;a href=&quot;#关闭默认防火墙&quot; class=&quot;headerlink&quot; title=&quot;关闭默认防火墙&quot;&gt;&lt;/a&gt;关闭默认防火墙&lt;/h3&gt;&lt;p&gt;CentOS 7默认使用的防火墙是firewall，需要将其关闭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;systemctl stop firewalld.service #停止firewall&lt;/li&gt;
&lt;li&gt;systemctl disable firewalld.service #禁止firewall开机启动&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装-iptables-service&quot;&gt;&lt;a href=&quot;#安装-iptables-service&quot; class=&quot;headerlink&quot; title=&quot;安装 iptables service&quot;&gt;&lt;/a&gt;安装 iptables service&lt;/h3&gt;&lt;p&gt;yum -y install iptables-services
    
    </summary>
    
    
      <category term="System" scheme="https://www.lishaojie.top/categories/System/"/>
    
    
      <category term="CentOS" scheme="https://www.lishaojie.top/tags/CentOS/"/>
    
      <category term="FireWall" scheme="https://www.lishaojie.top/tags/FireWall/"/>
    
  </entry>
  
  <entry>
    <title>神一样的存在,万能插件-Tampermonkey</title>
    <link href="https://www.lishaojie.top/2020/01/10/Tampermonkey/"/>
    <id>https://www.lishaojie.top/2020/01/10/Tampermonkey/</id>
    <published>2020-01-10T15:35:36.000Z</published>
    <updated>2020-02-26T14:04:43.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：<a href="http://www.lishaojie.top/2020/01/09/ghelper">科学上网推荐,谷歌浏览器插件Ghelper</a>  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg" alt></p><a id="more"></a><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>说到这款插件就不得不说一个网址：<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg" alt></p><p>这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg" alt></p><p>选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg" alt></p><p>点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg" alt></p><h2 id="脚本推荐"><a href="#脚本推荐" class="headerlink" title="脚本推荐"></a>脚本推荐</h2><p>管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg" alt></p><p>我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。</p><p>划词翻译</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg" alt></p><p>BiliBili会员站点解析</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg" alt></p><p>YouTube视频下载</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg" alt></p><p>是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：&lt;a href=&quot;http://www.lishaojie.top/2020/01/09/ghelper&quot;&gt;科学上网推荐,谷歌浏览器插件Ghelper&lt;/a&gt;  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Google plugin" scheme="https://www.lishaojie.top/tags/Google-plugin/"/>
    
      <category term="Tampermonkey" scheme="https://www.lishaojie.top/tags/Tampermonkey/"/>
    
  </entry>
  
  <entry>
    <title>科学上网推荐,谷歌浏览器插件Ghelper</title>
    <link href="https://www.lishaojie.top/2020/01/10/ghelper/"/>
    <id>https://www.lishaojie.top/2020/01/10/ghelper/</id>
    <published>2020-01-10T14:18:05.000Z</published>
    <updated>2020-02-24T11:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg" alt></p><a id="more"></a><p>不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 <a href="https://usky.ml/tool/free_ssr" target="_blank" rel="noopener">SSR工具</a></p><p>把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。</p><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg" alt></p><p>点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg" alt></p><h2 id="资费详情"><a href="#资费详情" class="headerlink" title="资费详情"></a>资费详情</h2><p>介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg" alt></p><h2 id="手机代理"><a href="#手机代理" class="headerlink" title="手机代理"></a>手机代理</h2><p>页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg" alt></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>YouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Google plugin" scheme="https://www.lishaojie.top/tags/Google-plugin/"/>
    
      <category term="Ghelper" scheme="https://www.lishaojie.top/tags/Ghelper/"/>
    
  </entry>
  
  <entry>
    <title>macOS 超实用的「付费」软件推荐,分享一波福利！</title>
    <link href="https://www.lishaojie.top/2020/01/07/macapp/"/>
    <id>https://www.lishaojie.top/2020/01/07/macapp/</id>
    <published>2020-01-07T03:17:15.000Z</published>
    <updated>2020-02-26T14:05:13.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Alfred-4"><a href="#Alfred-4" class="headerlink" title="Alfred 4"></a>Alfred 4</h2><p>版本号: 4.0.6</p><p>功能介绍: <a href="https://www.alfredapp.com/whats-new/" target="_blank" rel="noopener">https://www.alfredapp.com/whats-new/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA" target="_blank" rel="noopener">https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA</a>  密码:9onb</p><p>推荐指数: ★★★★★<a id="more"></a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg" alt></p><h2 id="CleanMyMac-X"><a href="#CleanMyMac-X" class="headerlink" title="CleanMyMac X"></a>CleanMyMac X</h2><p>版本号: 4.4.6</p><p>功能介绍: <a href="https://macpaw.com/cleanmymac" target="_blank" rel="noopener">https://macpaw.com/cleanmymac</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA</a>  密码:mslx</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg" alt></p><h2 id="Movist-Pro"><a href="#Movist-Pro" class="headerlink" title="Movist Pro"></a>Movist Pro</h2><p>版本号: 2.2.13</p><p>功能介绍: <a href="https://movistprime.com/" target="_blank" rel="noopener">https://movistprime.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg</a>  密码:8ocb</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg" alt></p><h2 id="Final-Cut-Pro-X"><a href="#Final-Cut-Pro-X" class="headerlink" title="Final Cut Pro X"></a>Final Cut Pro X</h2><p>版本号: 10.4.5</p><p>功能介绍: <a href="https://www.apple.com/final-cut-pro/" target="_blank" rel="noopener">https://www.apple.com/final-cut-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ</a>  密码:wqdk</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg" alt></p><h2 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h2><p>版本号: 4.4.3</p><p>功能介绍: <a href="https://www.apple.com.cn/cn/final-cut-pro/compressor/" target="_blank" rel="noopener">https://www.apple.com.cn/cn/final-cut-pro/compressor/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA</a>  密码:8mng</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg" alt></p><h2 id="iStat-Menus-6"><a href="#iStat-Menus-6" class="headerlink" title="iStat Menus 6"></a>iStat Menus 6</h2><p>版本号: 6.31</p><p>功能介绍: <a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">https://bjango.com/mac/istatmenus/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ</a>  密码:r8yx</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg" alt></p><h2 id="Parallels-Desktop-15"><a href="#Parallels-Desktop-15" class="headerlink" title="Parallels Desktop 15"></a>Parallels Desktop 15</h2><p>版本号: 15.1.2</p><p>功能介绍: <a href="https://www.parallels.com/cn/landingpage/pd/general/" target="_blank" rel="noopener">https://www.parallels.com/cn/landingpage/pd/general/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg" alt></p><h2 id="XMind-8-Pro"><a href="#XMind-8-Pro" class="headerlink" title="XMind 8 Pro"></a>XMind 8 Pro</h2><p>版本号: 3.7.7</p><p>功能介绍: <a href="https://www.xmind.cn/xmind8-pro/" target="_blank" rel="noopener">https://www.xmind.cn/xmind8-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg" alt></p><h2 id="PDF-Expert"><a href="#PDF-Expert" class="headerlink" title="PDF Expert"></a>PDF Expert</h2><p>版本号: 2.4.23</p><p>功能介绍: <a href="https://pdfexpert.com/" target="_blank" rel="noopener">https://pdfexpert.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow" target="_blank" rel="noopener">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg" alt></p><h2 id="Things-3"><a href="#Things-3" class="headerlink" title="Things 3"></a>Things 3</h2><p>版本号: 3.11</p><p>功能介绍: <a href="https://culturedcode.com/things/" target="_blank" rel="noopener">https://culturedcode.com/things/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ</a>  密码:ddv6</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg" alt></p><h2 id="Downie-3"><a href="#Downie-3" class="headerlink" title="Downie 3"></a>Downie 3</h2><p>版本号: 3.9.4</p><p>功能介绍: <a href="https://software.charliemonroe.net/downie/" target="_blank" rel="noopener">https://software.charliemonroe.net/downie/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA</a>  密码:cqma</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg" alt></p><h2 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h2><p>版本号: 2.4.4</p><p>功能介绍: <a href="https://pasteapp.me/" target="_blank" rel="noopener">https://pasteapp.me/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g" target="_blank" rel="noopener">https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g</a>  密码:4bxn</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg" alt></p><h2 id="Bartender-3"><a href="#Bartender-3" class="headerlink" title="Bartender 3"></a>Bartender 3</h2><p>版本号: 3.1.1</p><p>功能介绍: <a href="https://www.macbartender.com/" target="_blank" rel="noopener">https://www.macbartender.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q</a>  密码:b00n</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg" alt></p><h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p>版本号: 3.2.2</p><p>功能介绍: <a href="https://zh.mweb.im/" target="_blank" rel="noopener">https://zh.mweb.im/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw</a>  密码:87dx</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg" alt></p><h2 id="Smooze"><a href="#Smooze" class="headerlink" title="Smooze"></a>Smooze</h2><p>版本号: 1.8.6</p><p>功能介绍: <a href="https://smooze.co/" target="_blank" rel="noopener">https://smooze.co/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw</a>  密码:upjo</p><p>推荐指数: ★★☆☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg" alt></p><h2 id="Keka"><a href="#Keka" class="headerlink" title="Keka"></a>Keka</h2><p>版本号: 1.1.5</p><p>功能介绍: <a href="https://www.keka.io/en/" target="_blank" rel="noopener">https://www.keka.io/en/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ</a>  密码:7sdf</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg" alt></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!</p><p>本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Alfred-4&quot;&gt;&lt;a href=&quot;#Alfred-4&quot; class=&quot;headerlink&quot; title=&quot;Alfred 4&quot;&gt;&lt;/a&gt;Alfred 4&lt;/h2&gt;&lt;p&gt;版本号: 4.0.6&lt;/p&gt;
&lt;p&gt;功能介绍: &lt;a href=&quot;https://www.alfredapp.com/whats-new/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.alfredapp.com/whats-new/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;破解版下载链接:&lt;a href=&quot;https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA&lt;/a&gt;  密码:9onb&lt;/p&gt;
&lt;p&gt;推荐指数: ★★★★★
    
    </summary>
    
    
      <category term="System" scheme="https://www.lishaojie.top/categories/System/"/>
    
    
      <category term="macOS" scheme="https://www.lishaojie.top/tags/macOS/"/>
    
      <category term="paid apps" scheme="https://www.lishaojie.top/tags/paid-apps/"/>
    
  </entry>
  
  <entry>
    <title>macOS 超实用的「免费」软件推荐,使用经验分享！</title>
    <link href="https://www.lishaojie.top/2020/01/06/macappfree/"/>
    <id>https://www.lishaojie.top/2020/01/06/macappfree/</id>
    <published>2020-01-06T14:34:14.000Z</published>
    <updated>2020-02-26T15:18:40.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它</p><p>功能介绍：<a href="https://iterm2.com/features.html" target="_blank" rel="noopener">https://iterm2.com/features.html</a></p><p>官方下载地址：<a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener">https://iterm2.com/downloads.html</a></p><p>推荐指数：★★★★★<a id="more"></a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg" alt></p><h2 id="IINA"><a href="#IINA" class="headerlink" title="IINA"></a>IINA</h2><p>概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快</p><p>功能介绍：<a href="https://zhuanlan.zhihu.com/p/24700324" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24700324</a></p><p>官方下载地址：<a href="https://iina.io/" target="_blank" rel="noopener">https://iina.io/</a></p><p>推荐指数：★★★★☆（Movist Pro 是满分😄）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg" alt></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>概括：支持实时预览的Markdown文本编辑器</p><p>功能介绍：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">https://sspai.com/post/54912</a></p><p>官方下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><p>推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg" alt></p><h2 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h2><p>概括：Markdown 图床、文件上传工具，免费版足够用</p><p>功能介绍：<a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">https://toolinbox.net/iPic/</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg" alt></p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件</p><p>功能介绍：<a href="https://www.cnblogs.com/clwydjgs/p/10078065.html" target="_blank" rel="noopener">https://www.cnblogs.com/clwydjgs/p/10078065.html</a></p><p>官方下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><p>推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg" alt></p><h2 id="Better-And-Better"><a href="#Better-And-Better" class="headerlink" title="Better And Better"></a>Better And Better</h2><p>概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用</p><p>功能介绍：<a href="https://www.better365.cn/tv.html" target="_blank" rel="noopener">https://www.better365.cn/tv.html</a></p><p>官方下载地址：<a href="https://www.better365.cn/bab.html" target="_blank" rel="noopener">https://www.better365.cn/bab.html</a></p><p>推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg" alt></p><h2 id="iShot"><a href="#iShot" class="headerlink" title="iShot"></a>iShot</h2><p>概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法</p><p>功能介绍：<a href="https://sspai.com/post/57302" target="_blank" rel="noopener">https://sspai.com/post/57302</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg" alt></p><h2 id="Final-Shell"><a href="#Final-Shell" class="headerlink" title="Final Shell"></a>Final Shell</h2><p>概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp</p><p>功能介绍：<a href="https://blog.csdn.net/sinat_25838589/article/details/79781241" target="_blank" rel="noopener">https://blog.csdn.net/sinat_25838589/article/details/79781241</a></p><p>官方下载地址：<a href="http://www.hostbuf.com/t/988.html" target="_blank" rel="noopener">http://www.hostbuf.com/t/988.html</a></p><p>推荐指数：★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;iTerm2&quot;&gt;&lt;a href=&quot;#iTerm2&quot; class=&quot;headerlink&quot; title=&quot;iTerm2&quot;&gt;&lt;/a&gt;iTerm2&lt;/h2&gt;&lt;p&gt;概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它&lt;/p&gt;
&lt;p&gt;功能介绍：&lt;a href=&quot;https://iterm2.com/features.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://iterm2.com/features.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方下载地址：&lt;a href=&quot;https://iterm2.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://iterm2.com/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐指数：★★★★★
    
    </summary>
    
    
      <category term="System" scheme="https://www.lishaojie.top/categories/System/"/>
    
    
      <category term="macOS" scheme="https://www.lishaojie.top/tags/macOS/"/>
    
      <category term="free apps" scheme="https://www.lishaojie.top/tags/free-apps/"/>
    
  </entry>
  
  <entry>
    <title>AES对称加密算法</title>
    <link href="https://www.lishaojie.top/2019/11/05/AES/"/>
    <id>https://www.lishaojie.top/2019/11/05/AES/</id>
    <published>2019-11-05T15:36:05.000Z</published>
    <updated>2020-02-24T11:41:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AES算法的特点"><a href="#AES算法的特点" class="headerlink" title="AES算法的特点"></a>AES算法的特点</h2><p>AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客<a href="http://www.lishaojie.top/2019/07/04/MD5/">《MD5底层实现和解密方法》</a>所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用<strong>同一个密钥</strong>。AES支持三种长度的密钥：<strong>128位，192位，256位</strong>。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。</p><p>从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。<a id="more"></a></p><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。</p><p>假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行<strong>填充</strong>（Padding）。</p><h4 id="NoPadding"><a href="#NoPadding" class="headerlink" title="NoPadding"></a>NoPadding</h4><p>不做任何填充，但是要求明文必须是16字节的整数倍。</p><h4 id="PKCS5Padding（默认）"><a href="#PKCS5Padding（默认）" class="headerlink" title="PKCS5Padding（默认）"></a>PKCS5Padding（默认）</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p><h4 id="ISO10126Padding"><a href="#ISO10126Padding" class="headerlink" title="ISO10126Padding"></a>ISO10126Padding</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}</p><p><strong>注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</strong></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。</p><h4 id="ECB模式（默认）"><a href="#ECB模式（默认）" class="headerlink" title="ECB模式（默认）"></a>ECB模式（默认）</h4><p>电码本模式  Electronic Codebook Book</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg" alt></p><p>ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。</p><h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>密码分组链接模式  Cipher Block Chaining</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg" alt></p><p>CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它<strong>前一个明文块所加密出的密文块</strong>相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。</p><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计算器模式  Counter（实现省略……）</p><h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>密码反馈模式  Cipher FeedBack（实现省略……）</p><h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>输出反馈模式  Output FeedBack（实现省略……）</p><p><strong>注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。</strong></p><p>在Java代码中，如何修改不同长度的密钥和填充模式？</p><p>AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg" alt></p><ol><li>kgen.init传入的第一个参数128决定了密钥的长度是<strong>128bit</strong>。</li><li>Cipher.getInstance(“AES/CBC/NoPadding”)决定了AES选择的填充方式是<strong>NoPadding</strong>，工作模式是<strong>CBC</strong>模式。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。</li><li>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</li></ol><h2 id="AES加密算法底层原理"><a href="#AES加密算法底层原理" class="headerlink" title="AES加密算法底层原理"></a>AES加密算法底层原理</h2><h3 id="AES加密步骤"><a href="#AES加密步骤" class="headerlink" title="AES加密步骤"></a>AES加密步骤</h3><ol><li>把明文按照128bit拆分成若干个明文块。</li><li>按照选择的填充方式来填充最后一个明文块。</li><li>每一个明文块利用AES加密器和密钥，加密成密文块。</li><li>拼接所有的密文块，成为最终的密文结果。</li></ol><h3 id="AES加密器需要经过多少轮加密"><a href="#AES加密器需要经过多少轮加密" class="headerlink" title="AES加密器需要经过多少轮加密"></a>AES加密器需要经过多少轮加密</h3><ul><li>初始轮（Initial Round） 1次</li><li>普通轮（Rounds）     N次</li><li>最终轮（Final Round）  1次</li></ul><p>上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。</p><h3 id="除去初始轮各种Key长度对应的轮数"><a href="#除去初始轮各种Key长度对应的轮数" class="headerlink" title="除去初始轮各种Key长度对应的轮数"></a>除去初始轮各种Key长度对应的轮数</h3><ul><li>AES128：10轮</li><li>AES192：12轮</li><li>AES256：14轮</li></ul><h3 id="不同阶段Round的处理步骤"><a href="#不同阶段Round的处理步骤" class="headerlink" title="不同阶段Round的处理步骤"></a>不同阶段Round的处理步骤</h3><p><strong>初始轮只有一个步骤</strong></p><ul><li>加轮密钥（AddRoundKey）</li></ul><p><strong>普通轮有四个步骤</strong></p><ul><li><p>字节代替（SubBytes）</p><p>首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为<strong>S盒</strong>（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。</p></li><li><p>行移位（ShiftRows）</p><p>这一步很简单，就像图中所描述的：第一行不变，第二行循环左移<strong>1</strong>个字节，第三行循环左移<strong>2</strong>个字节，第四行循环左移<strong>3</strong>个字节。</p></li><li><p>列混淆（MixColumns）</p><p>这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。</p></li><li><p>加轮密钥（AddRoundKey）</p><p>这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：<strong>扩展密钥</strong>（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ……一直到W{160-175}用于最终轮（第10轮）的处理。</p></li></ul><p><strong>最终轮有三个步骤</strong></p><ul><li>字节代替（SubBytes）</li><li>行移位（ShiftRows）</li><li>加轮密钥（AddRoundKey）</li></ul><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p>解密流程基本是把加密流程倒置过来，顺序变为 最终轮-&gt;普通轮-&gt;初始轮。扩展密钥的使用顺序也和加密相反。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AES算法的特点&quot;&gt;&lt;a href=&quot;#AES算法的特点&quot; class=&quot;headerlink&quot; title=&quot;AES算法的特点&quot;&gt;&lt;/a&gt;AES算法的特点&lt;/h2&gt;&lt;p&gt;AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客&lt;a href=&quot;http://www.lishaojie.top/2019/07/04/MD5/&quot;&gt;《MD5底层实现和解密方法》&lt;/a&gt;所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。&lt;/p&gt;
&lt;h3 id=&quot;密钥&quot;&gt;&lt;a href=&quot;#密钥&quot; class=&quot;headerlink&quot; title=&quot;密钥&quot;&gt;&lt;/a&gt;密钥&lt;/h3&gt;&lt;p&gt;密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用&lt;strong&gt;同一个密钥&lt;/strong&gt;。AES支持三种长度的密钥：&lt;strong&gt;128位，192位，256位&lt;/strong&gt;。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。&lt;/p&gt;
&lt;p&gt;从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AES算法" scheme="https://www.lishaojie.top/tags/AES%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加密算法</title>
    <link href="https://www.lishaojie.top/2019/11/03/encryption/"/>
    <id>https://www.lishaojie.top/2019/11/03/encryption/</id>
    <published>2019-11-03T15:21:25.000Z</published>
    <updated>2020-02-24T12:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加密算法的种类"><a href="#加密算法的种类" class="headerlink" title="加密算法的种类"></a>加密算法的种类</h2><p>从宏观上来看，加密算法可以归结为三大类：<strong>哈希算法、对称加密算法、非对称加密算法。</strong></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从严格意义上来说，<strong>哈希算法并不属于加密算法</strong>，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是<strong>生成信息摘要</strong>，用以验证原信息的完整性和来源的可靠性。</p><p>举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，<strong>Hash（1234_100_abc） = 948569CD3466451F</strong>）<a id="more"></a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg" alt></p><p>请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。</p><p>生成信息摘要的过程叫做<strong>签名</strong>，验证信息摘要的过程叫做<strong>验签</strong>。</p><p>哈希算法最著名的当属<strong>MD5算法</strong>。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了<strong>SHA系列算法</strong>。</p><hr><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。</p><h3 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg" alt></p><p>如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。</p><p>除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。</p><h3 id="对称加密包含哪些算法？"><a href="#对称加密包含哪些算法？" class="headerlink" title="对称加密包含哪些算法？"></a>对称加密包含哪些算法？</h3><p>在早期，人们使用<strong>DES算法</strong>进行加密解密；后来，人们觉得DES不够安全，发明了<strong>3DES</strong>算法；而如今，最为流行的对称加密算法是<strong>AES算法</strong>。</p><h3 id="对称加密的优缺点"><a href="#对称加密的优缺点" class="headerlink" title="对称加密的优缺点"></a>对称加密的优缺点</h3><p>对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。</p><hr><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg" alt></p><p>如图所示，在非对称加密中存在一对密钥，一个叫做<strong>公钥</strong>，另一个叫做<strong>私钥</strong>。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属<strong>RSA算法</strong>。</p><h3 id="非对称加密的通信过程"><a href="#非对称加密的通信过程" class="headerlink" title="非对称加密的通信过程"></a>非对称加密的通信过程</h3><ol><li>在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。</li><li>客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。</li><li>服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。</li><li>从此以后，双方可以利用密钥X进行对称加密的通信了。</li></ol><h3 id="非对称加密的优缺点"><a href="#非对称加密的优缺点" class="headerlink" title="非对称加密的优缺点"></a>非对称加密的优缺点</h3><p>好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。</p><p>缺点是性能较差，无法应用于长期的通信。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加密算法的种类&quot;&gt;&lt;a href=&quot;#加密算法的种类&quot; class=&quot;headerlink&quot; title=&quot;加密算法的种类&quot;&gt;&lt;/a&gt;加密算法的种类&lt;/h2&gt;&lt;p&gt;从宏观上来看，加密算法可以归结为三大类：&lt;strong&gt;哈希算法、对称加密算法、非对称加密算法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h2&gt;&lt;p&gt;从严格意义上来说，&lt;strong&gt;哈希算法并不属于加密算法&lt;/strong&gt;，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是&lt;strong&gt;生成信息摘要&lt;/strong&gt;，用以验证原信息的完整性和来源的可靠性。&lt;/p&gt;
&lt;p&gt;举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，&lt;strong&gt;Hash（1234_100_abc） = 948569CD3466451F&lt;/strong&gt;）
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="加密算法" scheme="https://www.lishaojie.top/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密的底层实现和破解方法</title>
    <link href="https://www.lishaojie.top/2019/11/03/MD5/"/>
    <id>https://www.lishaojie.top/2019/11/03/MD5/</id>
    <published>2019-11-03T14:07:27.000Z</published>
    <updated>2020-02-24T11:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息摘要技术"><a href="#信息摘要技术" class="headerlink" title="信息摘要技术"></a>信息摘要技术</h2><p>信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。</p><p>MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。</p><h2 id="摘要哈希的生成过程"><a href="#摘要哈希的生成过程" class="headerlink" title="摘要哈希的生成过程"></a>摘要哈希的生成过程</h2><ol><li>收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</li><li>按照规则，把参数名和参数值拼接成一个字符串，同时把给定的<strong>密钥</strong>也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</li><li>利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。<a id="more"></a></li></ol><h2 id="第三方支付平台验证签名"><a href="#第三方支付平台验证签名" class="headerlink" title="第三方支付平台验证签名"></a>第三方支付平台验证签名</h2><ol><li>发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。</li><li>第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。</li><li>用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做<strong>验签</strong>。</li></ol><h2 id="MD5算法底层实现原理"><a href="#MD5算法底层实现原理" class="headerlink" title="MD5算法底层实现原理"></a>MD5算法底层实现原理</h2><p>简单概括起来，MD5算法的过程分为四步：</p><ol><li><p>处理原文</p><p>首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。</p></li><li><p>设置初始值</p><p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p><p>A=0x01234567</p><p>B=0x89ABCDEF</p><p>C=0xFEDCBA98</p><p>D=0x76543210</p></li><li><p>循环加工</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg" alt></p><p>图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = <strong>M / 512</strong>，每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。上面这张图所表达的就是<strong>单次子循环</strong>的流程。下面对图中其他元素一一解释：</p><p><strong>1.绿色F</strong></p><p>图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：</p><p>F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</p><p>G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</p><p>H(X, Y, Z) =X^Y^Z</p><p>I(X, Y, Z)=Y^(X|(~Z))</p><p>在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。</p><p><strong>2.红色“田”字</strong></p><p>很简单，红色的田字代表相加的意思。</p><p><strong>3.Mi</strong></p><p>Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0<del>M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1</del>M16之一。</p><p><strong>4.Ki</strong></p><p>一个常量，在64次子循环中，每一次用到的常量都是不同的。</p><p><strong>5.黄色的&lt;&lt;</strong></p><p>左移S位，S的值也是常量。</p></li><li><p>拼接结果</p><p>这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。</p></li></ol><hr><h2 id="MD5破解"><a href="#MD5破解" class="headerlink" title="MD5破解"></a>MD5破解</h2><p>这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。</p><p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。</p><h3 id="MD5碰撞方法"><a href="#MD5碰撞方法" class="headerlink" title="MD5碰撞方法"></a>MD5碰撞方法</h3><h4 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h4><p>顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。</p><h4 id="字典法"><a href="#字典法" class="headerlink" title="字典法"></a>字典法</h4><p>如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。</p><h4 id="彩虹表法"><a href="#彩虹表法" class="headerlink" title="彩虹表法"></a>彩虹表法</h4><p>彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：<strong>彩虹表</strong>。</p><p>彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。</p><h4 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h4><p>2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息摘要技术&quot;&gt;&lt;a href=&quot;#信息摘要技术&quot; class=&quot;headerlink&quot; title=&quot;信息摘要技术&quot;&gt;&lt;/a&gt;信息摘要技术&lt;/h2&gt;&lt;p&gt;信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。&lt;/p&gt;
&lt;p&gt;MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。&lt;/p&gt;
&lt;h2 id=&quot;摘要哈希的生成过程&quot;&gt;&lt;a href=&quot;#摘要哈希的生成过程&quot; class=&quot;headerlink&quot; title=&quot;摘要哈希的生成过程&quot;&gt;&lt;/a&gt;摘要哈希的生成过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。&lt;/li&gt;
&lt;li&gt;按照规则，把参数名和参数值拼接成一个字符串，同时把给定的&lt;strong&gt;密钥&lt;/strong&gt;也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。&lt;/li&gt;
&lt;li&gt;利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="MD5算法" scheme="https://www.lishaojie.top/tags/MD5%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存-Redis</title>
    <link href="https://www.lishaojie.top/2019/10/22/redis/"/>
    <id>https://www.lishaojie.top/2019/10/22/redis/</id>
    <published>2019-10-22T15:46:44.000Z</published>
    <updated>2020-02-24T11:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis单线程模型原理剖析？"><a href="#redis单线程模型原理剖析？" class="headerlink" title="redis单线程模型原理剖析？"></a>redis单线程模型原理剖析？</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p><h2 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h2><ol><li>纯内存操作。</li><li>核心是基于非阻塞的IO多路复用机制。</li><li>单线程——避免了多线程的频繁上下文切换问题。</li><li>Resp协议。<a id="more"></a></li></ol><h2 id="使用redis有什么缺点？"><a href="#使用redis有什么缺点？" class="headerlink" title="使用redis有什么缺点？"></a>使用redis有什么缺点？</h2><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩、缓存击穿</li><li>缓存的并发竞争</li></ul><h2 id="redis支持的数据类型和使用场景"><a href="#redis支持的数据类型和使用场景" class="headerlink" title="redis支持的数据类型和使用场景"></a>redis支持的数据类型和使用场景</h2><ol><li><p>string</p><p>最基本的类型，普通的set和get，做简单的key-value缓存。</p></li><li><p>hash</p><p>类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。</p></li><li><p>list</p><p>有序列表，这个是可以玩出很多花样的：</p><p>比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。</p><p>还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。</p></li><li><p>set</p><p>无序集合，自动去重。</p><p>如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。</p><p>还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。</p></li><li><p>sorted set</p><p>有序集合，自动去重。</p><p>这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。</p><p>比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。</p><p>排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。</p><p>zadd board 85 jack</p><p>zadd board 72 tom</p><p>zadd board 96 jerry</p><p>zrevrange board 0 2：可以查看前三名的排序结果</p><p>zrank board tom：返回3，意思是tom排名第3</p></li></ol><hr><h2 id="redis的过期策略有哪些"><a href="#redis的过期策略有哪些" class="headerlink" title="redis的过期策略有哪些"></a>redis的过期策略有哪些</h2><p><strong>定期删除+惰性删除</strong></p><p>所谓<strong>定期删除</strong>，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。</p><p>所谓<strong>惰性删除</strong>，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。</p><p>产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走<strong>内存淘汰机制</strong>了。</p><ol><li>no-enviction（驱逐）：禁止驱逐数据，再写入会报错。<strong>（默认，应该没人用）</strong></li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。<strong>（推荐使用）</strong></li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从<code>已设置过期时间的</code>数据集中挑选<code>将要过期的</code>数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li></ol><hr><h2 id="怎么保证redis的高并发-amp-高可用？"><a href="#怎么保证redis的高并发-amp-高可用？" class="headerlink" title="怎么保证redis的高并发&amp;高可用？"></a>怎么保证redis的高并发&amp;高可用？</h2><p>redis高并发：采用<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。</p><p>redis高可用：如果做主从架构部署，其实加上<strong>哨兵</strong>就可以了，任何一个实例宕机，都会自动切换。</p><h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑10+的<strong>读QPS</strong></p><p>首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 </p><h4 id="主从复制的核心原理"><a href="#主从复制的核心原理" class="headerlink" title="主从复制的核心原理"></a>主从复制的核心原理</h4><p>当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行<strong>增量复制</strong>，如果这是slave第一次连接master，会触发一次<strong>全量复制</strong>。</p><p>官方解释：</p><ol><li>slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。</li><li>slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。</li><li>slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。</li><li>master第一次执行全量复制，将所有数据发送给slave。</li><li>master后续还会持续将写命令异步发送给slave。</li></ol><p>全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。</p><p>增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。</p><h4 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h4><p>从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。</p><p>官方解释：</p><ol><li>master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。</li><li>master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。</li><li>master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。</li><li>从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。</li></ol><h4 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h4><p>在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。</p><h4 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h4><p>slave不会过期key，只会等待master过期key。</p><p>如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。</p><h4 id="redis的心跳检测机制"><a href="#redis的心跳检测机制" class="headerlink" title="redis的心跳检测机制"></a>redis的心跳检测机制</h4><p>在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。</p><h4 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h4><p>如果采用了主从架构，建议必须开启master node的持久化。</p><p>不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。</p><p>即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。</p><p><strong>持久化方式RDB和AOF</strong></p><ul><li>RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。</li><li>AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。</li></ul><p>如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。</p><p>如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。</p><p><strong>RDB的优点</strong></p><ol><li>RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。</li><li>RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。</li><li>通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。</li></ol><p><strong>RDB的缺点</strong></p><ol><li>最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。</li><li>RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。</li></ol><p><strong>AOF的优点</strong></p><ol><li>AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。</li><li>AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。</li><li>AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。</li><li>AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。</li></ol><p><strong>AOF的缺点</strong></p><ol><li>最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。</li><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li><li>AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。</li><li>如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。</li><li>AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。</li></ol><p><strong>RDB和AOF到底如何选择</strong></p><ul><li>不要仅仅使用RDB，因为那样会导致丢失很多数据。</li><li>也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。</li><li>所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。</li></ul><hr><h3 id="redis的哨兵机制"><a href="#redis的哨兵机制" class="headerlink" title="redis的哨兵机制"></a>redis的哨兵机制</h3><p>sentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：</p><ol><li>集群监控：负责监控redis master和slave进程是否正常工作。</li><li>消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。</li><li>故障转移：如果master挂掉了，会自动转移到slave上。</li><li>配置中心：如果故障转移发生了，把新的master地址通知到客户端。</li></ol><p>哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。</p><ol><li>故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。</li></ol><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ol><li>哨兵至少需要3个实例，来保证自己的健壮性。</li><li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。</li><li>对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。</li></ol><p><strong>为什么redis哨兵集群少于3个节点无法正常工作</strong></p><p>如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。</p><h4 id="sdown和odown转换机制？"><a href="#sdown和odown转换机制？" class="headerlink" title="sdown和odown转换机制？"></a>sdown和odown转换机制？</h4><p>master宕机有sdown和odown两种失败状态</p><ul><li>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。</li><li>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。</li><li>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了</li><li>sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。</li></ul><h4 id="哨兵和slave集群的自动发现机制"><a href="#哨兵和slave集群的自动发现机制" class="headerlink" title="哨兵和slave集群的自动发现机制"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往_sentinel_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的_sentinel_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p><h4 id="slave-master选举算法"><a href="#slave-master选举算法" class="headerlink" title="slave-master选举算法"></a>slave-master选举算法</h4><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。</p><p><strong>从节点过滤</strong>：判断跟master断开连接的时长</p><p>如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。</p><ol><li>slave配置的优先级（slave-priority=100）</li><li>复制offset</li><li>run id</li></ol><p>说明：</p><ol><li>然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。</li><li>如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li></ol><h4 id="slave配置的自动纠正"><a href="#slave配置的自动纠正" class="headerlink" title="slave配置的自动纠正"></a>slave配置的自动纠正</h4><p>哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。</p><h4 id="quorum和majority"><a href="#quorum和majority" class="headerlink" title="quorum和majority"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。</p><p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。</p><p>如果quorum &gt;= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。</p><h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><p>哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。</p><h4 id="configuration传播"><a href="#configuration传播" class="headerlink" title="configuration传播"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。</p><p>这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p><hr><h2 id="异步复制和集群脑裂导致数据丢失"><a href="#异步复制和集群脑裂导致数据丢失" class="headerlink" title="异步复制和集群脑裂导致数据丢失"></a>异步复制和集群脑裂导致数据丢失</h2><p>场景一：异步复制导致的数据丢失</p><p>client往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。</p><p>场景二：集群脑裂导致的数据丢失</p><p>master出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。</p><p><strong>如何降低损失？</strong></p><ul><li>min-slaves-to-write 1</li><li>min-slaves-max-lag 10</li></ul><p>配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。</p><p>上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。</p><hr><h2 id="分布式集群-redis-cluster"><a href="#分布式集群-redis-cluster" class="headerlink" title="分布式集群-redis cluster"></a>分布式集群-redis cluster</h2><ol><li>自动将数据进行分片，每个master上放一部分数据。</li><li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的。</li></ol><p>redis cluster可以突破单机redis在海量数据面前的瓶颈。</p><p><strong>redis cluster VS replication+sentinal</strong></p><p>如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。</p><h3 id="分布式数据存储的核心算法"><a href="#分布式数据存储的核心算法" class="headerlink" title="分布式数据存储的核心算法"></a>分布式数据存储的核心算法</h3><h4 id="最老土的hash算法和弊端"><a href="#最老土的hash算法和弊端" class="headerlink" title="最老土的hash算法和弊端"></a>最老土的hash算法和弊端</h4><p>把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到<strong>大量的缓存重建</strong>，这是致命的。</p><h4 id="一致性hash算法-自动缓存迁移"><a href="#一致性hash算法-自动缓存迁移" class="headerlink" title="一致性hash算法(自动缓存迁移)"></a>一致性hash算法(自动缓存迁移)</h4><p>有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。</p><h4 id="一致性hash算法-虚拟节点"><a href="#一致性hash算法-虚拟节点" class="headerlink" title="一致性hash算法+虚拟节点"></a>一致性hash算法+虚拟节点</h4><p>基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的<strong>负载均衡</strong>。</p><h4 id="hash-slot算法"><a href="#hash-slot算法" class="headerlink" title="hash slot算法"></a>hash slot算法</h4><p>redis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。</p><hr><h3 id="redis集群模式的工作原理"><a href="#redis集群模式的工作原理" class="headerlink" title="redis集群模式的工作原理"></a>redis集群模式的工作原理</h3><h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p><strong>基础通信原理</strong></p><p>redis cluster节点间采用<strong>gossip</strong>协议进行通信。</p><p>跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。</p><ul><li>集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。</li><li>gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。</li></ul><p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。</p><p><strong>gossip协议</strong></p><p>gossip协议包含多种消息，包括ping、pong、meet、fail等。</p><ul><li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。</li><li>ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。</li><li>pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。</li><li>fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li></ul><p><strong>ping消息深入</strong></p><p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。</p><hr><p>jedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -&gt; node的映射表缓存。</p><h4 id="高性能与主备切换原理"><a href="#高性能与主备切换原理" class="headerlink" title="高性能与主备切换原理"></a>高性能与主备切换原理</h4><p>redis cluster的高可用原理，几乎和哨兵是一样的。</p><ol><li><p>判断节点宕机</p><p>如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。</p></li><li><p>从节点过滤</p><p>对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。</p></li><li><p>master选举</p><p>每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。</p></li></ol><p>综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。</p><hr><h2 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：指在某一时间段，缓存集体失效。</p><h4 id="造成缓存雪崩的原因"><a href="#造成缓存雪崩的原因" class="headerlink" title="造成缓存雪崩的原因"></a>造成缓存雪崩的原因</h4><ol><li>比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。</li><li>缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</li></ol><h4 id="如何预防缓存雪崩？"><a href="#如何预防缓存雪崩？" class="headerlink" title="如何预防缓存雪崩？"></a>如何预防缓存雪崩？</h4><p>针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p><p>针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。</p><h4 id="缓存雪崩了如何恢复？"><a href="#缓存雪崩了如何恢复？" class="headerlink" title="缓存雪崩了如何恢复？"></a>缓存雪崩了如何恢复？</h4><p>本地ehcache缓存+hystrix限流&amp;降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。</p><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。</p><h4 id="造成缓存穿透的原因"><a href="#造成缓存穿透的原因" class="headerlink" title="造成缓存穿透的原因"></a>造成缓存穿透的原因</h4><p>代码bug或者恶意攻击。</p><h4 id="如何预防缓存穿透？"><a href="#如何预防缓存穿透？" class="headerlink" title="如何预防缓存穿透？"></a>如何预防缓存穿透？</h4><p>如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p><hr><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><h3 id="如何预防缓存击穿？"><a href="#如何预防缓存击穿？" class="headerlink" title="如何预防缓存击穿？"></a>如何预防缓存击穿？</h3><p>这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。</p><hr><h2 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性"></a>如何保证缓存与数据库的双写一致性</h2><h3 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h3><p>最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）</p><ol><li>读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。</li><li>更新的时候，<strong>先删除缓存，再更新数据库</strong>，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。</li></ol><p>为什么是删除缓存，而不是更新缓存呢？</p><p>原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。</p><p>其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。</p><hr><h3 id="高并发场景下的数据不一致"><a href="#高并发场景下的数据不一致" class="headerlink" title="高并发场景下的数据不一致"></a>高并发场景下的数据不一致</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>把数据库与缓存的更新读取操作进行异步串行化。</p><ul><li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。</li><li>读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。</li></ul><p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p><p>这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。</p><h4 id="解决方案需要注意的问题"><a href="#解决方案需要注意的问题" class="headerlink" title="解决方案需要注意的问题"></a>解决方案需要注意的问题</h4><p><strong>读请求 长时间堵塞</strong></p><p>由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。</p><p>该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。</p><p><strong>读请求 并发量过高</strong></p><p>上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。</p><p><strong>多服务实例部署的请求路由</strong></p><p>可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。</p><p><strong>热点商品的路由问题</strong></p><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。</p><p>因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。</p><hr><h2 id="如何保证redis并发竞争的数据一致性"><a href="#如何保证redis并发竞争的数据一致性" class="headerlink" title="如何保证redis并发竞争的数据一致性"></a>如何保证redis并发竞争的数据一致性</h2><p>客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redis单线程模型原理剖析？&quot;&gt;&lt;a href=&quot;#redis单线程模型原理剖析？&quot; class=&quot;headerlink&quot; title=&quot;redis单线程模型原理剖析？&quot;&gt;&lt;/a&gt;redis单线程模型原理剖析？&lt;/h2&gt;&lt;p&gt;redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。&lt;/p&gt;
&lt;h2 id=&quot;redis为什么这么快？&quot;&gt;&lt;a href=&quot;#redis为什么这么快？&quot; class=&quot;headerlink&quot; title=&quot;redis为什么这么快？&quot;&gt;&lt;/a&gt;redis为什么这么快？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;纯内存操作。&lt;/li&gt;
&lt;li&gt;核心是基于非阻塞的IO多路复用机制。&lt;/li&gt;
&lt;li&gt;单线程——避免了多线程的频繁上下文切换问题。&lt;/li&gt;
&lt;li&gt;Resp协议。
    
    </summary>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="redis" scheme="https://www.lishaojie.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>链表“逆序”算法</title>
    <link href="https://www.lishaojie.top/2019/09/18/LinkedList-Reverse/"/>
    <id>https://www.lishaojie.top/2019/09/18/LinkedList-Reverse/</id>
    <published>2019-09-18T14:06:48.000Z</published>
    <updated>2020-02-24T11:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆序本质"><a href="#逆序本质" class="headerlink" title="逆序本质"></a>逆序本质</h2><p>链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。</li><li>以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>三个临时节点的引用分别向后移动一格位置。</li><li>重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>重复第3步的工作，三个临时节点分别向后移动一格位置。</li><li>继续这样迭代下去，直到p2是空为止。</li><li>最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。<a id="more"></a></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Node head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里head是静态成员，其实也可以作为方法参数传入</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//算法实现</span>  Node p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>  Node p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  Node p3 <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    p3 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p3赋值</span>    p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p2指向p1</span>    p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p1赋值</span>    p2 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p2赋值</span>  <span class="token punctuation">}</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指向null</span>  head <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给head赋值</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义节点</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span>  Node next<span class="token punctuation">;</span>  <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//初始化链表</span>  head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给头节点赋值</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//头节点的next指向新节点6</span>  Node temp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义临时节点并赋值</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//临时节点的next指向新节点1</span>  temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//临时节点指针后移</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出初始化的链表</span>  temp <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//调用逆序链表的方法</span>  <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出逆序后的链表</span>  temp <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆序本质&quot;&gt;&lt;a href=&quot;#逆序本质&quot; class=&quot;headerlink&quot; title=&quot;逆序本质&quot;&gt;&lt;/a&gt;逆序本质&lt;/h2&gt;&lt;p&gt;链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。&lt;/li&gt;
&lt;li&gt;以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。&lt;/li&gt;
&lt;li&gt;三个临时节点的引用分别向后移动一格位置。&lt;/li&gt;
&lt;li&gt;重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。&lt;/li&gt;
&lt;li&gt;重复第3步的工作，三个临时节点分别向后移动一格位置。&lt;/li&gt;
&lt;li&gt;继续这样迭代下去，直到p2是空为止。&lt;/li&gt;
&lt;li&gt;最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表逆序算法" scheme="https://www.lishaojie.top/tags/%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.lishaojie.top/2019/09/16/Sort/"/>
    <id>https://www.lishaojie.top/2019/09/16/Sort/</id>
    <published>2019-09-16T14:11:20.000Z</published>
    <updated>2020-02-24T12:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h2><p>对一序列对象根据某个关键字进行排序。</p><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><ul><li><strong>稳定：</strong>如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定：</strong>如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序：</strong>所有排序操作都在内存中完成；</li><li><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong>一个算法执行所耗费的时间。</li><li><strong>空间复杂度：</strong>运行完一个程序所需内存的大小。<a id="more"></a></li></ul><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg" alt></p><h3 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p><p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。</p><p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><h3 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h3><p>计数排序、基数排序、桶排序则属于非比较排序。<strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</strong></p><p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p><p><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p><h2 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h2><h3 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h3><p>冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif" alt></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 冒泡排序     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="选择排序（不稳定）"><a href="#选择排序（不稳定）" class="headerlink" title="选择排序（不稳定）"></a>选择排序（不稳定）</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p><p>选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="过程演示-1"><a href="#过程演示-1" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif" alt></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 选择排序     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//找到最小的数</span>                    minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将最小数的索引保存</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n2) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><h4 id="过程演示-2"><a href="#过程演示-2" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif" alt></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 插入排序     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">int</span> current<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                preIndex<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最坏情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="希尔排序（不稳定）"><a href="#希尔排序（不稳定）" class="headerlink" title="希尔排序（不稳定）"></a>希尔排序（不稳定）</h3><p>希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="过程演示-3"><a href="#过程演示-3" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg" alt></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 希尔排序     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp<span class="token punctuation">,</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                    preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlog2 n) </li><li>最坏情况：T(n) = O(nlog2 n) </li><li>平均情况：T(n) =O(nlog2n)　</li></ul><hr><h3 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p><strong>归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</strong></p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="过程演示-4"><a href="#过程演示-4" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif" alt></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 归并排序     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">MergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 归并排序——将两段排序好的数组结合成一个排序数组     *     * @param left     * @param right     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最差情况：T(n) = O(nlogn) </li><li>平均情况：T(n) = O(nlogn)</li></ul><hr><h3 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h3><p>快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="过程演示-5"><a href="#过程演示-5" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif" alt></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 快速排序方法     * @param array     * @param start     * @param end     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">>=</span> array<span class="token punctuation">.</span>length <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> smallIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallIndex <span class="token operator">></span> start<span class="token punctuation">)</span>            <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> smallIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallIndex <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>            <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> smallIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 快速排序算法——partition     * @param array     * @param start     * @param end     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> smallIndex <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                smallIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> smallIndex<span class="token punctuation">)</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> smallIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token keyword">return</span> smallIndex<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换数组内两个元素     * @param array     * @param i     * @param j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(nlogn)　</li></ul><hr><h3 id="堆排序（不稳定）"><a href="#堆排序（不稳定）" class="headerlink" title="堆排序（不稳定）"></a>堆排序（不稳定）</h3><p>堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="过程演示-6"><a href="#过程演示-6" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif" alt></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//声明全局变量，用于记录数组array的长度；</span><span class="token keyword">static</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 堆排序算法     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//1.构建一个最大堆</span>        <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            len<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 建立最大堆     *     * @param array     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//从最后一个非叶子节点开始向上构造最大堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整使之成为最大堆     *     * @param array     * @param i     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxIndex <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxIndex <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> maxIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn) </li><li>最差情况：T(n) = O(nlogn) </li><li>平均情况：T(n) = O(nlogn)</li></ul><hr><h3 id="基数排序（稳定）"><a href="#基数排序（稳定）" class="headerlink" title="基数排序（稳定）"></a>基数排序（稳定）</h3><p>基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序(利用计数排序适用于小范围数的特点)；</li></ul><h4 id="过程演示-7"><a href="#过程演示-7" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif" alt></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 基数排序     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> null <span class="token operator">||</span> array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.先算出最大数的位数；</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxDigit<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> bucketList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            bucketList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> div<span class="token punctuation">;</span>                bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                    array<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n * k) </li><li>最差情况：T(n) = O(n * k) </li><li>平均情况：T(n) = O(n * k)</li></ul><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序</li><li>LSD 从低位开始进行排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序的定义&quot;&gt;&lt;a href=&quot;#排序的定义&quot; class=&quot;headerlink&quot; title=&quot;排序的定义&quot;&gt;&lt;/a&gt;排序的定义&lt;/h2&gt;&lt;p&gt;对一序列对象根据某个关键字进行排序。&lt;/p&gt;
&lt;h2 id=&quot;术语说明&quot;&gt;&lt;a href=&quot;#术语说明&quot; class=&quot;headerlink&quot; title=&quot;术语说明&quot;&gt;&lt;/a&gt;术语说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定：&lt;/strong&gt;如果a原本在b前面，而a=b，排序之后a仍然在b的前面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不稳定：&lt;/strong&gt;如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内排序：&lt;/strong&gt;所有排序操作都在内存中完成；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外排序：&lt;/strong&gt;由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt;一个算法执行所耗费的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度：&lt;/strong&gt;运行完一个程序所需内存的大小。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.lishaojie.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="https://www.lishaojie.top/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分库分表的原理</title>
    <link href="https://www.lishaojie.top/2019/08/27/Sub-table/"/>
    <id>https://www.lishaojie.top/2019/08/27/Sub-table/</id>
    <published>2019-08-27T15:43:23.000Z</published>
    <updated>2020-02-24T12:20:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h2><ul><li><p>数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。</p></li><li><p>物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。</p><p>换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p><p>比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。<a id="more"></a></p></li></ul><hr><h2 id="如何进行分库分表？"><a href="#如何进行分库分表？" class="headerlink" title="如何进行分库分表？"></a>如何进行分库分表？</h2><h3 id="数据分表"><a href="#数据分表" class="headerlink" title="数据分表"></a>数据分表</h3><ul><li><p><strong>垂直分表</strong></p><p>根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。<strong>主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。</strong></p><p>垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。</p></li><li><p><strong>水平分表</strong></p><p>将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。</p><p>水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg" alt></p><h3 id="数据分库"><a href="#数据分库" class="headerlink" title="数据分库"></a>数据分库</h3><p>每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。</p><ul><li>根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。</li><li>根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。</li><li>根据访问数据的地域/时间范围进行分库。</li></ul><p><strong>range和hash的优缺点</strong></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg" alt></p><p><strong>分库分表会遇到哪些问题</strong></p><ul><li><p>ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(“-“,””)，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。</p></li><li><p>Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。</p></li><li><p>排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。</p><ol><li><p>对分表的数据先进行排序/分页/聚合，再进行合并。</p></li><li><p>对分表的数据先进行合并再做排序/分页/聚合。</p></li></ol></li><li><p>事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。</p></li></ul><hr><h2 id="如何对数据库进行扩容？"><a href="#如何对数据库进行扩容？" class="headerlink" title="如何对数据库进行扩容？"></a>如何对数据库进行扩容？</h2><p>分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。</p><ul><li><p><strong>主从数据库扩容</strong></p><p>我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。</p><p>由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。</p><p>负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。</p><p>这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。</p><p>此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。</p></li><li><p><strong>双写数据库扩容</strong></p><p>在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。</p><p>这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。</p><p>与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。</p><p>当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。</p><p>当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。</p></li></ul><hr><h2 id="有哪些分库分表的中间件？"><a href="#有哪些分库分表的中间件？" class="headerlink" title="有哪些分库分表的中间件？"></a>有哪些分库分表的中间件？</h2><p><strong>sharding-jdbc 和 mycat</strong>。</p><p>sharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。</p><p>mycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。</p><h2 id="不同的中间件有什么优缺点？"><a href="#不同的中间件有什么优缺点？" class="headerlink" title="不同的中间件有什么优缺点？"></a>不同的中间件有什么优缺点？</h2><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg" alt></p><hr><h2 id="如何把单库单表的系统迁移到分库分表？"><a href="#如何把单库单表的系统迁移到分库分表？" class="headerlink" title="如何把单库单表的系统迁移到分库分表？"></a>如何把单库单表的系统迁移到分库分表？</h2><h3 id="停机迁移"><a href="#停机迁移" class="headerlink" title="停机迁移"></a>停机迁移</h3><p>发布公告，凌晨0点～2点维护系统，暂停使用。</p><p>数据迁移，修改配置，验证测试。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg" alt></p><h3 id="不停机双写迁移"><a href="#不停机双写迁移" class="headerlink" title="不停机双写迁移"></a>不停机双写迁移</h3><p>通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。</p><p>此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg" alt></p><hr><h2 id="分库分表以后ID主键如何处理？"><a href="#分库分表以后ID主键如何处理？" class="headerlink" title="分库分表以后ID主键如何处理？"></a>分库分表以后ID主键如何处理？</h2><p>推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。</p><p>其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg" alt></p><hr><h2 id="简述如何实现mysql的读写分离？"><a href="#简述如何实现mysql的读写分离？" class="headerlink" title="简述如何实现mysql的读写分离？"></a>简述如何实现mysql的读写分离？</h2><p>其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。</p><h2 id="mysql主从复制的原理？"><a href="#mysql主从复制的原理？" class="headerlink" title="mysql主从复制的原理？"></a>mysql主从复制的原理？</h2><ol><li>mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。</li><li>从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。</li><li>接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。</li></ol><p><strong>需要注意的问题（数据延迟和数据丢失）</strong></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg" alt></p><ol><li>从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。</li><li>由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。</li><li>如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。</li></ol><p><strong>如何解决？</strong></p><p>mysql在这一块有两个机制，一个是<strong>半同步复制</strong>，解决数据丢失问题。一个是<strong>并行复制</strong>，缓解数据延时问题。</p><ul><li>所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。</li><li>所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。</li></ul><p><strong>有没有更好的方法解决主从数据延时问题（重点）</strong></p><ol><li>分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。</li><li>重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。</li><li>如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>因为数据量的上升，为了提高性能会对系统进行分表分库。</li><li>从分表来说，有水平分表和垂直分表两种方式。</li><li>从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。</li><li>如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要分库分表？&quot;&gt;&lt;a href=&quot;#为什么要分库分表？&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表？&quot;&gt;&lt;/a&gt;为什么要分库分表？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。&lt;/p&gt;
&lt;p&gt;换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。&lt;/p&gt;
&lt;p&gt;比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。
    
    </summary>
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="数据库" scheme="https://www.lishaojie.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Sub-table" scheme="https://www.lishaojie.top/tags/Sub-table/"/>
    
  </entry>
  
  <entry>
    <title>消息队列-MQ</title>
    <link href="https://www.lishaojie.top/2019/08/19/MQ/"/>
    <id>https://www.lishaojie.top/2019/08/19/MQ/</id>
    <published>2019-08-19T15:28:33.000Z</published>
    <updated>2020-02-24T11:45:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用消息队列？说说优缺点？"><a href="#为什么使用消息队列？说说优缺点？" class="headerlink" title="为什么使用消息队列？说说优缺点？"></a>为什么使用消息队列？说说优缺点？</h2><p>我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。</p><p>比较核心的使用场景有3个：<strong>解耦、异步、削峰</strong>。同样也是使用MQ的<strong>优点</strong>。</p><p><strong>解耦举例</strong>：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。</p><p>总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。<a id="more"></a></p><p><strong>异步举例</strong>：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。</p><p>总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。</p><p><strong>削峰举例</strong>：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。</p><p>总结：削峰可以缓解数据库压力，达到最终一致性。</p><p><strong>缺点</strong>：</p><ul><li>系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。</li><li>系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。</li><li>一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。</li></ul><hr><h2 id="不同消息中间件的区别以及适用场景？"><a href="#不同消息中间件的区别以及适用场景？" class="headerlink" title="不同消息中间件的区别以及适用场景？"></a>不同消息中间件的区别以及适用场景？</h2><ul><li>单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。</li><li>时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。</li><li>可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。</li></ul><p>优劣势总结</p><ul><li>activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。</li><li>rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。</li><li>rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。</li><li>kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。</li></ul><p>综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。</p><hr><h2 id="RabbitMQ如何保证消息队列的高可用？"><a href="#RabbitMQ如何保证消息队列的高可用？" class="headerlink" title="RabbitMQ如何保证消息队列的高可用？"></a>RabbitMQ如何保证消息队列的高可用？</h2><p>RabbitMQ是比较有代表性的，因为是基于<strong>主从架构</strong>实现的的高可用。</p><p>RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。</p><ol><li><p>单机模式</p><p>就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。</p></li><li><p>普通集群模式（不是高可用的）</p><p>意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。</p><p>该模式有两个缺点：</p><p>​    如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；</p><p>​    如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。</p></li><li><p>镜像集群模式（是高可用的）</p><p>这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。</p><p>这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。</p><p><strong>怎么开启这个镜像集群模式呢？</strong></p><p>rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。</p></li></ol><hr><h2 id="如何保证消息不被重复消费？-幂等性"><a href="#如何保证消息不被重复消费？-幂等性" class="headerlink" title="如何保证消息不被重复消费？(幂等性)"></a>如何保证消息不被重复消费？(幂等性)</h2><p>什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。</p><p><strong>如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：</strong></p><ol><li>比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。</li><li>比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。</li><li>还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。</li></ol><hr><h2 id="如何保证消息的可靠性传输，不丢消息？"><a href="#如何保证消息的可靠性传输，不丢消息？" class="headerlink" title="如何保证消息的可靠性传输，不丢消息？"></a>如何保证消息的可靠性传输，不丢消息？</h2><p><strong>消息丢失的3种情况：</strong></p><ol><li><strong>生产者</strong>写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；</li><li><strong>rabbitmq</strong>接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；</li><li><strong>消费者</strong>消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。</li></ol><p>情况1<strong>（生产者弄丢了数据）</strong>的解决方案：</p><p><strong>rabbitmq的事务机制</strong>：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。</p><p><strong>confirm机制</strong>：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。</p><p>事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。</p><p>情况2<strong>（rabbitmq弄丢了数据）</strong>的解决方案：</p><p><strong>开启rabbitmq持久化</strong>：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。</p><p>设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，<strong>注意：必须同时设置这两个才可以</strong>。</p><p>这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。</p><p>情况3<strong>（消费者弄丢了数据）</strong>的解决方案：</p><p>消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。</p><hr><h2 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h2><p>先看看造成消息错乱的场景</p><p>如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。</p><p>解决方案：</p><p>拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；</p><p>一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。</p><hr><p>如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？</p><p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：</p><ol><li>先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。</li><li>临时建立好原先10倍或者20倍的queue数量。</li><li>然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。</li><li>等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。</li></ol><p>假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。</p><p>如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。</p><hr><h2 id="如果让你写消息队列，如何架构设计？"><a href="#如果让你写消息队列，如何架构设计？" class="headerlink" title="如果让你写消息队列，如何架构设计？"></a>如果让你写消息队列，如何架构设计？</h2><p><strong>下面说一下设计思路</strong></p><ol><li>首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。</li><li>其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。</li><li>还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举leader即可对外服务。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用消息队列？说说优缺点？&quot;&gt;&lt;a href=&quot;#为什么使用消息队列？说说优缺点？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用消息队列？说说优缺点？&quot;&gt;&lt;/a&gt;为什么使用消息队列？说说优缺点？&lt;/h2&gt;&lt;p&gt;我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。&lt;/p&gt;
&lt;p&gt;比较核心的使用场景有3个：&lt;strong&gt;解耦、异步、削峰&lt;/strong&gt;。同样也是使用MQ的&lt;strong&gt;优点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解耦举例&lt;/strong&gt;：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。&lt;/p&gt;
&lt;p&gt;总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。
    
    </summary>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="消息队列" scheme="https://www.lishaojie.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引,B+Tree详解</title>
    <link href="https://www.lishaojie.top/2019/08/10/BTree/"/>
    <id>https://www.lishaojie.top/2019/08/10/BTree/</id>
    <published>2019-08-10T15:00:13.000Z</published>
    <updated>2020-02-24T11:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql索引？"><a href="#Mysql索引？" class="headerlink" title="Mysql索引？"></a>Mysql索引？</h2><h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><h3 id="为什么要创建索引？"><a href="#为什么要创建索引？" class="headerlink" title="为什么要创建索引？"></a>为什么要创建索引？</h3><ol><li>创建索引可以大大提高系统的查询性能。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。</li><li>在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。</li><li>通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。<a id="more"></a></li></ol><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如要建立聚集索引，则需要空间更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li></ol><h3 id="适合添加索引的字段"><a href="#适合添加索引的字段" class="headerlink" title="适合添加索引的字段"></a>适合添加索引的字段</h3><p>经常需要搜索的列、主键、外键、经常需要范围查询的列、经常需要排序的列、经常使用的where子句的列。</p><p>注意：建立索引一般按照select的where条件来建立，比如条件是where f1 and f2，需要在f1、f2上同时建立。</p><h3 id="不适合添加索引的字段"><a href="#不适合添加索引的字段" class="headerlink" title="不适合添加索引的字段"></a>不适合添加索引的字段</h3><p>查询中很少使用的字段、区分度不高的列、text,image,bit等数据量大的列、修改性能大于检索性能不要加。</p><h2 id="二叉树的缺陷"><a href="#二叉树的缺陷" class="headerlink" title="二叉树的缺陷"></a>二叉树的缺陷</h2><p><strong>搜索效率不足，树的深度不可控。</strong>（树的深度决定着搜索时IO次数）</p><p><strong>节点数据内容太少。</strong>（没有很好的利用系统和磁盘的数据交换特性）</p><h2 id="B-树的特点"><a href="#B-树的特点" class="headerlink" title="B-树的特点"></a>B-树的特点</h2><p>B-树是一种多路平衡二叉树，相比于二叉树大大降低了树的高度，减少了磁盘IO。</p><h2 id="B-树的特点-1"><a href="#B-树的特点-1" class="headerlink" title="B+树的特点"></a>B+树的特点</h2><ol><li>每一个根节点的元素都出现在子节点中，是子节点的最大（或最小）元素。</li><li>根节点的最大元素就是整个B+树的最大元素，无论插入删除多少元素，始终保持最大元素在根节点中。</li><li>由于特点1，所以叶子节点包含了全量的元素信息。</li><li>每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。</li></ol><h3 id="卫星数据的位置"><a href="#卫星数据的位置" class="headerlink" title="卫星数据的位置"></a>卫星数据的位置</h3><p>在B-树中，无论中间节点还是叶子节点都带有卫星数据。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay4wwcz3lj30ji0brae3.jpg" alt></p><p>在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay4x092ahj30jk0bfjv0.jpg" alt></p><p>PS：在数据库的聚集索引(Clustered Index)中，叶子节点直接包含卫星数据；在非聚集索引(NonClustered Index)中，叶子节点带有指向卫星数据的指针。</p><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><ul><li>B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的元素，这就意味着数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数更少。</li><li>B+树的查找性能更稳定，因为B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树的查找性能不如B+树稳定。</li><li>在范围查找方面，B-树只能依靠繁琐的中序遍历，反观B+树则要简单的多，只需要在链表上做遍历即可。</li></ul><p><strong>综上所述，B+树相比于B-树的优势有三个</strong></p><ol><li>单一节点存储更多的元素，使得查询的IO次数更少。</li><li>所有查询都要查找到子节点，查询性能稳定。</li><li>所有叶子节点形成有序链表，便于范围查询。</li></ol><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay93ok47nj30sz0gj45e.jpg" alt></p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay94rzzm0j30sy0ef47q.jpg" alt></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay95n2xzmj30sp0i4gyc.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql索引？&quot;&gt;&lt;a href=&quot;#Mysql索引？&quot; class=&quot;headerlink&quot; title=&quot;Mysql索引？&quot;&gt;&lt;/a&gt;Mysql索引？&lt;/h2&gt;&lt;h3 id=&quot;索引是什么？&quot;&gt;&lt;a href=&quot;#索引是什么？&quot; class=&quot;headerlink&quot; title=&quot;索引是什么？&quot;&gt;&lt;/a&gt;索引是什么？&lt;/h3&gt;&lt;p&gt;索引是为了加速对表中数据行的检索而创建的一种分散存储的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么要创建索引？&quot;&gt;&lt;a href=&quot;#为什么要创建索引？&quot; class=&quot;headerlink&quot; title=&quot;为什么要创建索引？&quot;&gt;&lt;/a&gt;为什么要创建索引？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建索引可以大大提高系统的查询性能。&lt;/li&gt;
&lt;li&gt;通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&lt;/li&gt;
&lt;li&gt;可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。&lt;/li&gt;
&lt;li&gt;在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。&lt;/li&gt;
&lt;li&gt;通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.lishaojie.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.lishaojie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="B+Tree" scheme="https://www.lishaojie.top/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Mac常用APP推荐</title>
    <link href="https://www.lishaojie.top/2019/05/16/app/"/>
    <id>https://www.lishaojie.top/2019/05/16/app/</id>
    <published>2019-05-16T15:16:19.000Z</published>
    <updated>2020-02-27T05:37:47.222Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家推荐几款我平时比较常用的APP，设计到的功能比较广泛，有工作流、磁盘整理、虚拟机载体、播放器、PDF编辑器、思维导图、系统监控、下载器等等，对提升工作效率很有帮助。</p><p>除百度网盘外的下载地址均提供不限速下载通道，喜欢的小伙伴可以自行下载安装体验。</p><h3 id="Alfred-4-0-6"><a href="#Alfred-4-0-6" class="headerlink" title="Alfred 4.0.6"></a>Alfred 4.0.6</h3><p>功能介绍: <a href="https://www.alfredapp.com/whats-new/" target="_blank" rel="noopener">https://www.alfredapp.com/whats-new/</a></p><p>下载地址：<a href="https://www.lanzous.com/i9gpbsj" target="_blank" rel="noopener">Alfred 4_4.0.6.1123.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc643pfzhxj31at0u0hdt.jpg" alt></p><hr><h3 id="CleanMyMacX-4-4-6"><a href="#CleanMyMacX-4-4-6" class="headerlink" title="CleanMyMacX 4.4.6"></a>CleanMyMacX 4.4.6</h3><p>功能介绍: <a href="https://macpaw.com/cleanmymac" target="_blank" rel="noopener">https://macpaw.com/cleanmymac</a></p><p>下载地址：<a href="https://www.lanzous.com/i9gnxyf" target="_blank" rel="noopener">CleanMyMacX 4.4.6.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc64698mw1j31em0u0b29.jpg" alt></p><hr><h3 id="DaisyDisk-4-8-2"><a href="#DaisyDisk-4-8-2" class="headerlink" title="DaisyDisk 4.8.2"></a>DaisyDisk 4.8.2</h3><p>下载地址：<a href="https://www.lanzous.com/i9gnxab" target="_blank" rel="noopener">DaisyDisk 4.8.2 REPACK.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc7fvcq4okj316k0u0nhm.jpg" alt></p><hr><h3 id="Parallels-Desktop-15-1-2"><a href="#Parallels-Desktop-15-1-2" class="headerlink" title="Parallels Desktop 15.1.2"></a>Parallels Desktop 15.1.2</h3><p>功能介绍: <a href="https://www.parallels.com/cn/landingpage/pd/general/" target="_blank" rel="noopener">https://www.parallels.com/cn/landingpage/pd/general/</a></p><p>下载链接:<a href="https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc7fg4p4ugj31280qmh3y.jpg" alt></p><hr><h3 id="Movist-Pro-2-2-14"><a href="#Movist-Pro-2-2-14" class="headerlink" title="Movist Pro 2.2.14"></a>Movist Pro 2.2.14</h3><p>下载地址：<a href="https://www.lanzous.com/i9gphfc" target="_blank" rel="noopener">Movist Pro 2.2.14.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc64mjzpdkj31lr0u0npg.jpg" alt></p><hr><h3 id="XMind-8-Pro-3-7-7"><a href="#XMind-8-Pro-3-7-7" class="headerlink" title="XMind 8 Pro 3.7.7"></a>XMind 8 Pro 3.7.7</h3><p>功能介绍: <a href="https://www.xmind.cn/xmind8-pro/" target="_blank" rel="noopener">https://www.xmind.cn/xmind8-pro/</a></p><p>下载链接:<a href="https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg" alt></p><hr><h3 id="PDF-Expert-2-4-23"><a href="#PDF-Expert-2-4-23" class="headerlink" title="PDF Expert 2.4.23"></a>PDF Expert 2.4.23</h3><p>功能介绍: <a href="https://pdfexpert.com/" target="_blank" rel="noopener">https://pdfexpert.com/</a></p><p>下载链接:<a href="https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow" target="_blank" rel="noopener">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc7fs42yp4j31gm0u047m.jpg" alt></p><hr><h3 id="iStat-Menus-6-31"><a href="#iStat-Menus-6-31" class="headerlink" title="iStat Menus 6.31"></a>iStat Menus 6.31</h3><p>下载地址：<a href="https://www.lanzous.com/i9gnybi" target="_blank" rel="noopener">iStat Menus 6.31.1107.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc64kbydrwj31j70u0hdt.jpg" alt></p><hr><h3 id="Downie-3-9-4"><a href="#Downie-3-9-4" class="headerlink" title="Downie 3.9.4"></a>Downie 3.9.4</h3><p>下载地址：<a href="https://www.lanzous.com/i9gny7e" target="_blank" rel="noopener">Downie 3.9.4.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc6472ufahj31b40jm7wh.jpg" alt></p><hr><h3 id="Paste-2-4-4"><a href="#Paste-2-4-4" class="headerlink" title="Paste 2.4.4"></a>Paste 2.4.4</h3><p>下载地址：<a href="https://www.lanzous.com/i9gpc8f" target="_blank" rel="noopener">Paste_2.4.4.dmg</a></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc64fhptj7j317m0u01kx.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天给大家推荐几款我平时比较常用的APP，设计到的功能比较广泛，有工作流、磁盘整理、虚拟机载体、播放器、PDF编辑器、思维导图、系统监控、下载器等等，对提升工作效率很有帮助。&lt;/p&gt;
&lt;p&gt;除百度网盘外的下载地址均提供不限速下载通道，喜欢的小伙伴可以自行下载安装体验。&lt;/p
      
    
    </summary>
    
    
    
      <category term="macOS" scheme="https://www.lishaojie.top/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>版本控制-Git</title>
    <link href="https://www.lishaojie.top/2019/05/13/git/"/>
    <id>https://www.lishaojie.top/2019/05/13/git/</id>
    <published>2019-05-13T14:10:27.000Z</published>
    <updated>2020-02-24T11:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="Git-的特点"><a href="#Git-的特点" class="headerlink" title="Git 的特点"></a>Git 的特点</h2><p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：</p><p>从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。<a id="more"></a></p><ul><li>优点</li></ul><p>适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。</p><ul><li>缺点</li></ul><p>资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有码和版本信息。因其资料的公开性，导致大型商业化工程几乎不会使用GIT来托管工程版本信息（除非搭建企业私服）。</p><h2 id="Git-创建仓库"><a href="#Git-创建仓库" class="headerlink" title="Git 创建仓库"></a>Git 创建仓库</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p><p><strong>使用方法</strong></p><p>使用当前目录作为Git仓库，我们只需使它初始化。</p><pre><code>git init</code></pre><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。</p><pre><code>git init newrepo</code></pre><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><pre><code>$ git add *.c$ git add README$ git commit -m &#39;初始化项目版本&#39;</code></pre><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><hr><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p><p>克隆仓库的命令格式为：</p><pre><code>git clone &lt;repo&gt;</code></pre><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><pre><code>git clone &lt;repo&gt; &lt;directory&gt;</code></pre><p><strong>参数说明：</strong></p><ul><li><strong>repo:</strong> Git 仓库。</li><li><strong>directory:</strong> 本地目录。</li></ul><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><pre><code>$ git clone git://github.com/schacon/grit.git</code></pre><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><pre><code>$ git clone git://github.com/schacon/grit.git mygrit</code></pre><h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add 命令可将文件添加到缓存</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>git status 命令可以查看当前的提交状态</p><pre class="line-numbers language-xml"><code class="language-xml">➜  lishaojie.github.io git:(master) ✗ git status -s m themes/melody?? source/_posts/git.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>git diff 命令可以查看文件具体哪里做了改动</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit 命令可以把缓存区的内容提交到本地仓库</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset 命令可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示。</p><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p><pre><code>git rm &lt;file&gt;</code></pre><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <strong>-f</strong></p><pre><code>git rm -f &lt;file&gt;</code></pre><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可</p><pre><code>git rm --cached &lt;file&gt;</code></pre><p>如我们删除 hello.php文件：</p><pre><code>$ git rm hello.php rm &#39;hello.php&#39;$ lsREADME</code></pre><p>不从工作区中删除文件：</p><pre><code>$ git rm --cached README rm &#39;README&#39;$ lsREADME</code></pre><p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p><pre><code>git rm –r * </code></pre><p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录</p><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>git mv 命令用于移动或重命名一个文件、目录、软连接</p><h2 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code>git branch (branchname)</code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre><code>git checkout (branchname)</code></pre><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><h3 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h3><pre><code>git branch</code></pre><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><pre><code>$ git branch* master</code></pre><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p><pre><code>$ git branch testing$ git branch* master  testing</code></pre><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><pre><code>$ lsREADME$ echo &#39;runoob.com&#39; &gt; test.txt$ git add .$ git commit -m &#39;add test.txt&#39;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME        test.txt$ git checkout testingSwitched to branch &#39;testing&#39;$ lsREADME</code></pre><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p><pre><code>$ git checkout masterSwitched to branch &#39;master&#39;$ lsREADME        test.txt</code></pre><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><pre><code>$ git checkout -b newtestSwitched to a new branch &#39;newtest&#39;$ git rm test.txt rm &#39;test.txt&#39;$ lsREADME$ touch runoob.php$ git add .$ git commit -am &#39;removed test.txt、add runoob.php&#39;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME        runoob.php$ git checkout masterSwitched to branch &#39;master&#39;$ lsREADME        test.txt</code></pre><p>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支命令：</p><pre><code>git branch -d (branchname)</code></pre><p>例如我们要删除 testing 分支：</p><pre><code>$ git branch* master  testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master</code></pre><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><pre><code>git merge$ git branch* master  newtest$ lsREADME        test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt   | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME        runoob.php</code></pre><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p><p>合并完后就可以删除分支:</p><pre><code>$ git branch -d newtestDeleted branch newtest (was c1501a2).</code></pre><p>删除后， 就只剩下 master 分支了：</p><pre><code>$ git branch* master</code></pre><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><pre><code>$ git branch* master$ cat runoob.php</code></pre><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p><pre><code>&lt;?phpecho &#39;runoob&#39;;?&gt;</code></pre><p>创建 change_site 分支：</p><pre><code>$ git checkout -b change_siteSwitched to a new branch &#39;change_site&#39;$ vim runoob.php$ head -3 runoob.php&lt;?phpecho &#39;runoob&#39;;?&gt;$ git commit -am &#39;changed the runoob.php&#39;[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+)</code></pre><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><pre><code>$ git checkout masterSwitched to branch &#39;master&#39;$ cat runoob.php$ vim runoob.php    # 修改内容如下$ cat runoob.php&lt;?phpecho 1;?&gt;$ git diffdiff --git a/runoob.php b/runoob.phpindex e69de29..ac60739 100644--- a/runoob.php+++ b/runoob.php@@ -0,0 +1,3 @@+&lt;?php+echo 1;+?&gt;$ git commit -am &#39;修改代码&#39;[master c68142b] 修改代码 1 file changed, 3 insertions(+)</code></pre><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><pre><code>$ git merge change_siteAuto-merging runoob.phpCONFLICT (content): Merge conflict in runoob.phpAutomatic merge failed; fix conflicts and then commit the result.$ cat runoob.php     # 代开文件，看到冲突内容&lt;?php&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADecho 1;=======echo &#39;runoob&#39;;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site?&gt;</code></pre><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><pre><code>$ vim runoob.php $ cat runoob.php&lt;?phpecho 1;echo &#39;runoob&#39;;?&gt;$ git diffdiff --cc runoob.phpindex ac60739,b63d7d7..0000000--- a/runoob.php+++ b/runoob.php@@@ -1,3 -1,3 +1,4 @@@  &lt;?php +echo 1;+ echo &#39;runoob&#39;;  ?&gt;</code></pre><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p><pre><code>$ git status -sUU runoob.php$ git add runoob.php$ git status -sM  runoob.php$ git commit[master 88afe0e] Merge branch &#39;change_site&#39;</code></pre><p>现在我们成功解决了合并中的冲突，并提交了结果。</p><h2 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p><p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p><pre><code>$ git logcommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)Merge: c68142b 7774248Author: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:55:58 2019 +0800    Merge branch &#39;change_site&#39;commit c68142b562c260c3071754623b08e2657b4c6d5bAuthor: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:52:12 2019 +0800    修改代码commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)Author: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:49:26 2019 +0800    changed the runoob.phpcommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00Author: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:35:32 2019 +0800</code></pre><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><pre><code>$ git log --oneline$ git log --onelined5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;c68142b 修改代码7774248 (change_site) changed the runoob.phpc1501a2 removed test.txt、add runoob.php3e92c19 add test.txt3b58100 第一次版本提交</code></pre><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><pre><code>*   d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;|\  | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/  * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交</code></pre><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</p><pre><code>$ git log --reverse --oneline3b58100 第一次版本提交3e92c19 add test.txtc1501a2 removed test.txt、add runoob.php7774248 (change_site) changed the runoob.phpc68142b 修改代码d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;</code></pre><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><pre><code>$ git log --author=Linus --oneline -581b50f3 Move &#39;builtin-*&#39; into a &#39;builtin/&#39; subdirectory3bb7256 make &quot;index-pack&quot; a built-in377d027 make &quot;git pack-redundant&quot; a built-inb532581 make &quot;git unpack-file&quot; a built-in112dd51 make &quot;mktag&quot; a built-in</code></pre><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><pre><code>$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges5469e2d Git 1.7.1-rc2d43427d Documentation/remote-helpers: Fix typos and improve language272a36b Fixup: Second argument may be any arbitrary stringb6c8d2d Documentation/remote-helpers: Add invocation section5ce4f4e Documentation/urls: Rewrite to accomodate transport::address00b84e9 Documentation/remote-helpers: Rewrite description03aa87e Documentation: Describe other situations where -z affects git diff77bc694 rebase-interactive: silence warning when no commits rewritten636db2c t3301: add tests to use --format=&quot;%N&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Git&quot;&gt;&lt;a href=&quot;#什么是-Git&quot; class=&quot;headerlink&quot; title=&quot;什么是 Git&quot;&gt;&lt;/a&gt;什么是 Git&lt;/h2&gt;&lt;p&gt;Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;h2 id=&quot;Git-的特点&quot;&gt;&lt;a href=&quot;#Git-的特点&quot; class=&quot;headerlink&quot; title=&quot;Git 的特点&quot;&gt;&lt;/a&gt;Git 的特点&lt;/h2&gt;&lt;p&gt;分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：&lt;/p&gt;
&lt;p&gt;从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。
    
    </summary>
    
    
      <category term="分布式" scheme="https://www.lishaojie.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="version control" scheme="https://www.lishaojie.top/tags/version-control/"/>
    
      <category term="git" scheme="https://www.lishaojie.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>编程书籍推荐</title>
    <link href="https://www.lishaojie.top/2019/05/13/book/"/>
    <id>https://www.lishaojie.top/2019/05/13/book/</id>
    <published>2019-05-13T13:27:34.000Z</published>
    <updated>2020-02-26T04:19:20.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编程书籍推荐"><a href="#编程书籍推荐" class="headerlink" title="编程书籍推荐"></a>编程书籍推荐</h3><p>这里是我平时所积累的一些有关编程的书籍，包括设计模式、网站架构、还有一些常用的中间件和面试指南等。</p><p>本站所有书籍下载地址均为不限速链接，永久有效。</p><h4 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5m6q35ihj30u0154b29.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la4pe" target="_blank" rel="noopener">剑指OFFER  名企面试官精讲典型编程题  第2版.PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5la3umw8j305a05aglw.jpg" alt></p><hr><h4 id="大话设计模式"><a href="#大话设计模式" class="headerlink" title="大话设计模式"></a>大话设计模式</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5m8a97tbj30u01441kz.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la3oh" target="_blank" rel="noopener">大话设计模式(带目录完整版).PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5lmdukzej305a05aaac.jpg" alt></p><hr><h4 id="大型网站系统与Java中间件实践"><a href="#大型网站系统与Java中间件实践" class="headerlink" title="大型网站系统与Java中间件实践"></a>大型网站系统与Java中间件实践</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mb9y3t2j30u013mnpe.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la2wj" target="_blank" rel="noopener">大型网站系统与Java中间件实践.PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mglgjvsj305a05a74k.jpg" alt></p><hr><h4 id="大型网站技术架构"><a href="#大型网站技术架构" class="headerlink" title="大型网站技术架构"></a>大型网站技术架构</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mkg7twuj30ta16ghdu.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la2cj" target="_blank" rel="noopener">大型网站技术架构 核心原理与案例分析-李智慧.PDF</a></p><p>手机下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mlh6n7kj305a05a0t0.jpg" alt></p><hr><h4 id="Spring源码深度剖析"><a href="#Spring源码深度剖析" class="headerlink" title="Spring源码深度剖析"></a>Spring源码深度剖析</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mpau0skj30u01241ky.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la21i" target="_blank" rel="noopener">Spring源码深度剖析.PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybpgy1gc5mq0z1pnj305a05adg4.jpg" alt></p><hr><h4 id="Spring技术内幕"><a href="#Spring技术内幕" class="headerlink" title="Spring技术内幕"></a>Spring技术内幕</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5msksrb5j30u0157npd.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la1de" target="_blank" rel="noopener">SPRING技术内幕：深入解析SPRING架构与设计原理.PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mtuls3lj305a05a0t0.jpg" alt></p><hr><h4 id="Spring-Boot实战"><a href="#Spring-Boot实战" class="headerlink" title="Spring Boot实战"></a>Spring Boot实战</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5mxirk69j30u011pnpd.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la15g" target="_blank" rel="noopener">Spring Boot实战 ,丁雪丰(译者).PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5myik23cj305a05a74k.jpg" alt></p><hr><h4 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5n1x4cetj30u012du0x.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la13e" target="_blank" rel="noopener">Redis实战.PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5n09zh7dj305a05at8z.jpg" alt></p><hr><h4 id="Java并发编程实践"><a href="#Java并发编程实践" class="headerlink" title="Java并发编程实践"></a>Java并发编程实践</h4><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc5n4jt76pj30u013wx6p.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la0mh" target="_blank" rel="noopener">JAVA并发编程实践-带书签-完整版.PDF</a></p><p>手机扫码下载：<img src="https://tva1.sinaimg.cn/large/0082zybply1gc5n3i17wbj305a05a74k.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;编程书籍推荐&quot;&gt;&lt;a href=&quot;#编程书籍推荐&quot; class=&quot;headerlink&quot; title=&quot;编程书籍推荐&quot;&gt;&lt;/a&gt;编程书籍推荐&lt;/h3&gt;&lt;p&gt;这里是我平时所积累的一些有关编程的书籍，包括设计模式、网站架构、还有一些常用的中间件和面试指南等。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="book" scheme="https://www.lishaojie.top/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>线程池实现原理与源码分析</title>
    <link href="https://www.lishaojie.top/2019/05/11/Thread-Pool/"/>
    <id>https://www.lishaojie.top/2019/05/11/Thread-Pool/</id>
    <published>2019-05-11T13:26:44.000Z</published>
    <updated>2020-02-24T11:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ol><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<a id="more"></a></li></ol><p>对应到代码层面就是<code>ThreadPoolExecutor</code>执行<code>execute()</code>方法</p><ol><li>当<kbd>workerCount</kbd> &lt; <kbd>corePoolSize</kbd>，创建新线程执行任务。</li><li>当<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> &lt; <kbd>maximumPoolSize</kbd>，创建新线程执行任务。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。</li></ol><p>由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p><h3 id="线程池状态转换模型"><a href="#线程池状态转换模型" class="headerlink" title="线程池状态转换模型"></a>线程池状态转换模型</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg" alt></p><ul><li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li><li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li><li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li><li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li><li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li></ul><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>我们可以通过ThreadPoolExecutor的<strong>构造方法</strong>来创建线程池</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span>   <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>   <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                                    <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>   TimeUnit unit<span class="token punctuation">,</span>   BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>   ThreadFactory threadFactory<span class="token punctuation">,</span>   RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面介绍一下代码中的参数：</p><ol><li><p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li><li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p></li><li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p></li><li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p></li><li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p></li></ul></li><li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"XX-task-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p><ul><li>AbortPolicy：直接抛出异常。(默认)</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul></li></ol><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p><p>区别:</p><ul><li>execute()方法用于提交<strong>不需要返回值</strong>的任务;</li><li>submit()方法用于提交<strong>需要返回值</strong>的任务。</li></ul><p>execute方法：</p><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><pre class="line-numbers language-java"><code class="language-java">threadsPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>submit方法：</p><p>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方<br>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><pre class="line-numbers language-java"><code class="language-java">Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>haveReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    Object s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理中断异常</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理无法执行任务异常</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关闭线程池</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul><li>shutdown()</li><li>shutdownNow()</li></ul><p>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><p>区别：</p><p>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>总结：</p><p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h3 id="线程池实例Demo"><a href="#线程池实例Demo" class="headerlink" title="线程池实例Demo"></a>线程池实例Demo</h3><ol><li><p>首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> BlockingQueue blockingQueue<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> ThreadPoolExecutor threadPoolExecutor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">,</span> blockingQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TaskBusyWithoutResult</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token function">TaskBusyWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>   <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"开始运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10000</span><span class="token operator">*</span><span class="token number">10000</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>           i<span class="token operator">--</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"运行结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>向线程池提交20个任务，执行任务</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaskBusyWithoutResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="线程池源码分析"><a href="#线程池源码分析" class="headerlink" title="线程池源码分析"></a>线程池源码分析</h2><p><strong>基于JDK1.8</strong></p><h3 id="ctl-变量"><a href="#ctl-变量" class="headerlink" title="ctl 变量"></a>ctl 变量</h3><p>后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Packing and unpacking ctl</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><ul><li>if (! isRunning(recheck) &amp;&amp; remove(command))这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。</li><li>addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//如果提交了空的任务 抛出异常</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前线程池的状态</span>   <span class="token comment" spellcheck="true">//检查当前工作线程数量是否小于核心线程数量</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//通过addWorker方法提交任务</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">return</span><span class="token punctuation">;</span>   c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果提交失败 需要二次检查状态</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//向工作线程提交任务 </span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 再次检查状态</span>      <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//扩容失败 则拒绝任务</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker()方法"></a>addWorker()方法</h3><p>这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。</p><p>这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>       retry<span class="token operator">:</span>   <span class="token comment" spellcheck="true">//死循环更新状态</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取运行状态</span>       <span class="token comment" spellcheck="true">//检查线程池是否处于关闭状态</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                  firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                  <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//获取当前工作线程数量</span>               <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果已经超过corePoolSize获取maximumPoolSize 返回false</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                   wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//CAS增加一个工作线程</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//再次获取状态</span>               c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>       <span class="token comment" spellcheck="true">//如果状态更新失败 则循环更新</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                   <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>           w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化一个工作线程</span>           <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获得锁</span>               <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>               mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                   <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                   <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                   <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                       <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//添加工作这到hashset中保存</span>                       workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                           largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                       workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                   mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//工作线程启动 执行第一个任务 就是新提交的任务</span>                   t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>               <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker的构造方法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */</span><span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker()方法"></a>runWorker()方法</h3><p>在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它实际上是将自己委托给线程池的runWorker方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//不断地从blockingQueue获取任务</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>               w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// If pool is stopping, ensure thread is interrupted;</span>               <span class="token comment" spellcheck="true">// if not, ensure thread is not interrupted.  This</span>               <span class="token comment" spellcheck="true">// requires a recheck in second case to deal with</span>               <span class="token comment" spellcheck="true">// shutdownNow race while clearing interrupt</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                     <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                   <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//执行beforeExecute方法</span>                   <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                   Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                   <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//调用Runable的run方法</span>                       task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 执行aferExecute方法</span>                       <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                   task <span class="token operator">=</span> null<span class="token punctuation">;</span>                   w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                   w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环中，不断地通过getTask()方法从workerQueue中获取任务</li><li>如果线程池正在停止，则中断线程。否则调用3.</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程workers.remove(w);</li></ol><p>它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p><strong>创建线程池的5个方法：</strong></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>只有一个线程的线程池，因此所有提交的任务是<strong>顺序执行</strong>。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</p><p>返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><hr><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最少数量</span>                Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>                60L<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间，60秒</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">",执行第 "</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：3，执行第 1 次线程ID：4，执行第 1 次线程ID：2，执行第 1 次线程ID：5，执行第 1 次线程ID：1，执行第 1 次线程ID：2，执行第 2 次线程ID：3，执行第 2 次线程ID：4，执行第 2 次线程ID：1，执行第 2 次线程ID：5，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 3 次线程ID：4，执行第 3 次线程ID：5，执行第 3 次线程ID：1，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到执行结果是5个任务在交替进行的</p><p>newCachedThreadPool的总结：</p><ol><li>重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。</li><li>使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。</li><li>超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。</li><li>结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</li></ol><hr><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService fixedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码：有两个重载方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                nThreads<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最少数量</span>                nThreads<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>                0L<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService exe <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID <span class="token operator">=</span> i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span> <span class="token operator">+</span> taskID <span class="token operator">+</span> <span class="token string">"，执行第 "</span> <span class="token operator">+</span> j <span class="token operator">+</span> <span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：2，执行第 1 次线程ID：1，执行第 1 次线程ID：3，执行第 1 次线程ID：2，执行第 2 次线程ID：3，执行第 2 次线程ID：1，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 3 次线程ID：1，执行第 3 次线程ID：4，执行第 1 次线程ID：5，执行第 1 次线程ID：4，执行第 2 次线程ID：5，执行第 2 次线程ID：4，执行第 3 次线程ID：5，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。<br>newFixedThreadPool的总结：</p><ol><li>重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。</li><li>固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li><li>超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。</li><li>使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。</li></ol><hr><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p><pre class="line-numbers language-java"><code class="language-java">ScheduledExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程池维护线程的最少数量</span>        Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程池维护线程所允许的空闲时间</span>        NANOSECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>        <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ScheduledExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>                exe<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">",时间："</span><span class="token operator">+</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 执行一次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：</p><pre class="line-numbers language-xml"><code class="language-xml">线程：1,时间：2016-12-11T13:09:18.544 执行一次线程：2,时间：2016-12-11T13:09:18.544 执行一次线程：3,时间：2016-12-11T13:09:18.544 执行一次线程：5,时间：2016-12-11T13:09:20.557 执行一次线程：1,时间：2016-12-11T13:09:20.557 执行一次线程：4,时间：2016-12-11T13:09:20.557 执行一次线程：4,时间：2016-12-11T13:09:22.572 执行一次线程：2,时间：2016-12-11T13:09:22.572 执行一次线程：3,时间：2016-12-11T13:09:22.572 执行一次线程：5,时间：2016-12-11T13:09:24.586 执行一次线程：1,时间：2016-12-11T13:09:24.586 执行一次线程：2,时间：2016-12-11T13:09:24.586 执行一次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。</p><hr><h3 id="newSingleThreadScheduledPool"><a href="#newSingleThreadScheduledPool" class="headerlink" title="newSingleThreadScheduledPool"></a>newSingleThreadScheduledPool</h3><p>单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">"，执行第 "</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：1，执行第 1 次线程ID：1，执行第 2 次线程ID：1，执行第 3 次线程ID：2，执行第 1 次线程ID：2，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 1 次线程ID：3，执行第 2 次线程ID：3，执行第 3 次线程ID：4，执行第 1 次线程ID：4，执行第 2 次线程ID：4，执行第 3 次线程ID：5，执行第 1 次线程ID：5，执行第 2 次线程ID：5，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个结果都是相隔0.5秒打印出来的，顺序执行下去。</p><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程池原理&quot;&gt;&lt;a href=&quot;#线程池原理&quot; class=&quot;headerlink&quot; title=&quot;线程池原理&quot;&gt;&lt;/a&gt;线程池原理&lt;/h2&gt;&lt;h3 id=&quot;使用线程池的好处&quot;&gt;&lt;a href=&quot;#使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的好处&quot;&gt;&lt;/a&gt;使用线程池的好处&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;线程池的实现原理&quot;&gt;&lt;a href=&quot;#线程池的实现原理&quot; class=&quot;headerlink&quot; title=&quot;线程池的实现原理&quot;&gt;&lt;/a&gt;线程池的实现原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。&lt;/li&gt;
&lt;li&gt;线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。&lt;/li&gt;
&lt;li&gt;线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
    
    </summary>
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="高并发" scheme="https://www.lishaojie.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="https://www.lishaojie.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
</feed>
