<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>个人网站如何被百度收录</title>
      <link href="/2020/04/29/baidu-push/"/>
      <url>/2020/04/29/baidu-push/</url>
      
        <content type="html"><![CDATA[<h2 id="检测是否被收录"><a href="#检测是否被收录" class="headerlink" title="检测是否被收录"></a>检测是否被收录</h2><p>我们要想查看自己的网站有没有被谷歌站点地图或者百度资源搜索平台收录，只需要在搜索栏输入<code>site:</code>后面跟你的域名或者地址就可以查看了，有收录的话会显示你网站中的内容，如果没有被收录进去的话会显示“没有找到相关网页”。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gear0ez96nj31au0jq46i.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1geappoki70j316i0j4gqr.jpg" alt></p><p>这里可以看出，Google是成功收录了的，不过百度还没有收录。接下来看看如何才能被成功收录。</p><h2 id="谷歌站点地图"><a href="#谷歌站点地图" class="headerlink" title="谷歌站点地图"></a>谷歌站点地图</h2><p>首先进入谷歌站点地图页面：<a href="https://search.google.com/search-console" target="_blank" rel="noopener">https://search.google.com/search-console</a></p><p>如何使用sitemap.xml提交给谷歌站点地图网上教程很多，也很简单，这里不再赘述。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1geapiibmajj31ia0mm42n.jpg" alt></p><h2 id="百度资源搜索平台"><a href="#百度资源搜索平台" class="headerlink" title="百度资源搜索平台"></a>百度资源搜索平台</h2><p>由于特殊原因，官方也没有解释，最近提交sitemap给百度一直显示等待状态，也就是通过sitemap提交链接的这条路走不通了，不知道你是不是跟我有相同的遭遇。百度真是不让人省心啊……</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gear1nudn7j31i20fojtu.jpg" alt></p><p>接下来才是本文的重点，在sitemap提交失败的情况下，如何主动把链接推送给搜索资源搜索平台。</p><h3 id="推送方式"><a href="#推送方式" class="headerlink" title="推送方式"></a>推送方式</h3><p>百度资源搜索平台提供了三种提交方式：<strong>主动推送(实时)、自动推送、sitemap</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1geaqa9ins4j31a50u0gti.jpg" alt></p><h3 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h3><p>这里我们主要介绍如何通过主动实时推送到搜索引擎，百度也提供了示例，不过我猜非计算机行业看着还是一头雾水，下面我教你通过官方提供的接口调用地址，以post的方式推送链接给百度。废话不多说，直接上代码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStreamReader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintWriter<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URLConnection<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @create 2020-04-29 23:27 * @function: 主动推送链接给百度资源搜索平台 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaiduPushTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">Post</span><span class="token punctuation">(</span>String PostUrl<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> Parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> PostUrl <span class="token operator">||</span> null <span class="token operator">==</span> Parameters <span class="token operator">||</span> Parameters<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        PrintWriter out <span class="token operator">=</span> null<span class="token punctuation">;</span>        BufferedReader in <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            URLConnection conn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>PostUrl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            conn<span class="token punctuation">.</span><span class="token function">setRequestProperty</span><span class="token punctuation">(</span><span class="token string">"Host"</span><span class="token punctuation">,</span> <span class="token string">"data.zz.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            conn<span class="token punctuation">.</span><span class="token function">setRequestProperty</span><span class="token punctuation">(</span><span class="token string">"User-Agent"</span><span class="token punctuation">,</span> <span class="token string">"curl/7.12.1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            conn<span class="token punctuation">.</span><span class="token function">setRequestProperty</span><span class="token punctuation">(</span><span class="token string">"Content-Length"</span><span class="token punctuation">,</span> <span class="token string">"83"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            conn<span class="token punctuation">.</span><span class="token function">setRequestProperty</span><span class="token punctuation">(</span><span class="token string">"Content-Type"</span><span class="token punctuation">,</span> <span class="token string">"text/plain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            conn<span class="token punctuation">.</span><span class="token function">setDoInput</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            conn<span class="token punctuation">.</span><span class="token function">setDoOutput</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String param <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String s <span class="token operator">:</span> Parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>                param <span class="token operator">+=</span> s <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String line<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">+=</span> line<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送post请求出现异常！"</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>in <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBaidu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里写网站的服务器连接，在你的百度站长链接提交页面复制属于你的链接和token</span>        String url <span class="token operator">=</span> <span class="token string">"http://data.zz.baidu.com/urls?site=https://www.xxxx.com&amp;token=xxx"</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> param <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里写你要提交的链接</span>                <span class="token string">"https://www.xxxx.com/xxx/"</span><span class="token punctuation">,</span>                <span class="token string">"https://www.xxxx.com/xxx/"</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> <span class="token function">Post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结果是"</span> <span class="token operator">+</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//结果是{"remain":2941,"success":55}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件爬虫"><a href="#文件爬虫" class="headerlink" title="文件爬虫"></a>文件爬虫</h2><p>如果你的网站内容比较丰富，通过sitemap获取到的链接比较多，一个个复制很显然效率太低，我再附赠一段简单的爬虫代码，把你想要的资源文件拷贝到本地，稍加修改后通过爬虫获取，然后再把结果复制到上面的推送链接代码中。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpiderTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        File file<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"/Users/lishaojie/IdeaProjects/sitemap.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BufferedReader buf<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String str<span class="token operator">=</span>null<span class="token punctuation">;</span>        String regex<span class="token operator">=</span><span class="token string">"^(?:https?://)?[\\w]{1,}(?:\\.?[\\w]{1,})+[\\w-_/?&amp;=#%:]*$"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//正则</span>        Pattern pattern<span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>regex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>str<span class="token operator">=</span>buf<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Matcher matcher<span class="token operator">=</span>pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buf<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改代码中的正则表达式可以任意获取你想要的内容，今天先分享到这里，如果对你有帮助可以在文末赞赏支持一下！谢谢</p>]]></content>
      
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务-SpringCloud</title>
      <link href="/2020/04/20/springcloud/"/>
      <url>/2020/04/20/springcloud/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作(通常是基于HTTP协议的 RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><h3 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h3><p>SpringCloud是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdm5rrlf2wj31j90u0b2a.jpg" alt="SpringCloud相关优质项目"></p><h2 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h2><ul><li>服务注册与发现</li><li>服务调用</li><li>负载均衡</li><li>服务降级</li><li>服务熔断</li><li>服务监控</li><li>服务网关</li><li>配置中心管理</li><li>服务消息队列</li><li>全链路追踪</li><li>自动化构建部署</li><li>服务定时任务调度操作</li></ul><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>springboot源码地址：<a href="https://github.com/spring-projects/spring-boot/releases" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/releases</a></p><h3 id="SpringCloud版本"><a href="#SpringCloud版本" class="headerlink" title="SpringCloud版本"></a>SpringCloud版本</h3><p>Spring Cloud采用了<strong>英国伦敦地铁站</strong>的名称来命名，并由地铁站名称字母A-Z依次类推的形式来发布迭代版。</p><p>SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为了管理SpringCloud与各子项目的版本依赖关系,发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。 为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。例如angel是第一个版本, Brixton是第二个版本。当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后会发布一个”service releases’ 版本，简称SRX版本(X是数字)，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。</p><h3 id="技术选型参考JSON"><a href="#技术选型参考JSON" class="headerlink" title="技术选型参考JSON"></a>技术选型参考JSON</h3><p>依赖关系地址：<a href="https://start.spring.io/actuator/info" target="_blank" rel="noopener">https://start.spring.io/actuator/info</a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdm7csa39ej31240m44do.jpg" alt="详细版本参考"></p><h3 id="最终版本确定"><a href="#最终版本确定" class="headerlink" title="最终版本确定"></a>最终版本确定</h3><ul><li>SpringCloud Hoxton.SR1</li><li>SpringBoot 2.2.2 RELEASE</li><li>SpringCloud Alibaba 2.1.0 RELEASE</li></ul><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="SpringCloud停更-升级-替换"><a href="#SpringCloud停更-升级-替换" class="headerlink" title="SpringCloud停更/升级/替换"></a>SpringCloud停更/升级/替换</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdm82c96d7j31rq0jwn6t.jpg" alt="各组件的更新迭代"></p><h3 id="什么是服务注册与发现"><a href="#什么是服务注册与发现" class="headerlink" title="什么是服务注册与发现"></a>什么是服务注册与发现</h3><p>Eurek采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使佣Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者|服务提供者) ,以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中， 都会有一个注册中心(存放服务地址相关信息(接口地址)。</p><h3 id="什么是服务治理"><a href="#什么是服务治理" class="headerlink" title="什么是服务治理"></a>什么是服务治理</h3><p>Spring Cloud封装了Netflix公司开发的Eureka模块来实现服务治理</p><p>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系和管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等， 实现服务发现与注册。</p><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><h3 id="显示Run-Dashboard调试框"><a href="#显示Run-Dashboard调试框" class="headerlink" title="显示Run Dashboard调试框"></a>显示Run Dashboard调试框</h3><p>找到父工程项目所在的工作空间，打开.idea文件夹，修改workspace.xml文件，在&lt;component name=”RunDashboard”&gt;下添加</p><pre class="line-numbers language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>configurationTypes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SpringBootApplicationConfigurationType<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存文件，重启idea。</p><h3 id="dependencyManagement作用"><a href="#dependencyManagement作用" class="headerlink" title="dependencyManagement作用"></a>dependencyManagement作用</h3><p>Maven使用dependencyManagement元素来提供一种管理依赖版本号的方式。</p><p><strong>通常会在一个组织或者项目的最顶层的父POM中看到dependencyManagement元素</strong>。</p><p>使用pom.xml中的dependencyManagement元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。</p><p>Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后使用这个dependencyManagement元素中指定的版本号。 </p><p>这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要个个子项目的修改；另外如果某个子项目需要另外的一个版本，只需要声明version即可。</p><ul><li><strong>dependencyManagement里只是声明依赖，并不实观引入，因此子项目需要显示的声明需要用的依赖。</strong></li><li>如果不在子项目中声明依赖，是不会从父项目中继承下来的；</li><li>只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom；</li><li>如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</li></ul><h2 id="服务注册与发现-Eureka"><a href="#服务注册与发现-Eureka" class="headerlink" title="服务注册与发现-Eureka"></a>服务注册与发现-Eureka</h2><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdmpejcx4yj30xw0imgr5.jpg" alt="Eureka架构图" style="zoom:50%;"><ul><li><p>Eureka Server提供服务注册服务</p><p>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p></li><li><p>EurekaClient通过注册中心进行访问</p><p>EurekaClient是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、 使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将 会从服务注册表中把这个服务节点移除(默认90秒)。</p></li></ul><h3 id="Eureka工作流程"><a href="#Eureka工作流程" class="headerlink" title="Eureka工作流程"></a>Eureka工作流程</h3><ol><li>先启动eureka注册中心。</li><li>启动服务提供者payment支付服务。</li><li>支付服务启动后会把自身信息(比如服务地址)以别名方式注册进eureka。</li><li>消费者order服务在需要调用接口时，使用服务别名去注册中心获取实际的RPC远程调用地址。</li><li>消费者获得调用地址后，底层实际是利用HttpClien技术，实现远程调用。</li><li>消费者获得服务地址后会缓存在本地jvm内存中，默认每间隔30秒更新一次服务调用地址。</li></ol><p><strong>微服务RPC远程服务调用最核心的是什么？</strong></p><p>高可用，所以需要搭建Eureka注册中心集群，实现负载均衡+故障容错。</p><h3 id="Eureka的自我保护"><a href="#Eureka的自我保护" class="headerlink" title="Eureka的自我保护"></a>Eureka的自我保护</h3><p>某时刻某一个微服务不可用了，Eureka 不会立刻清理，依旧会对该微服务的信息进行保存。（属于CAP里面的AP分支）</p><p>自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让 Eureka集群更加的健壮、稳定。</p><p>如何关闭自我保护？</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Eureka服务端（注册中心7001）的配置中添加如下修改</span><span class="token attr-name">server</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">    #关闭白我保护制，保证不用服务被及时踢除，默认是true</span><span class="token attr-name">    enable-self-preservation</span><span class="token punctuation">:</span> <span class="token attr-value">false</span><span class="token comment" spellcheck="true">    #修改心跳间隔是2秒，默认是90秒</span><span class="token attr-name">    eviction-intervall-timer-in-ms</span><span class="token punctuation">:</span> <span class="token attr-value">2000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Eureka客户端（服务端8001）的配置中添加如下修改</span><span class="token attr-name">instance</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">    #Eureka客户端向服务端发送心跳的时间间隔，单位为秒（默认是30秒）</span><span class="token attr-name">    lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span><span class="token attr-value">1</span><span class="token comment" spellcheck="true">    #Eureka服务端在收到最后一次心跳后等待时同上限，单位为秒（默认是90秒）超时将剔除服务</span><span class="token attr-name">    leasehexpiration-duration-in-seconds</span><span class="token punctuation">:</span><span class="token attr-value">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务注册与发现-Zookeeper"><a href="#服务注册与发现-Zookeeper" class="headerlink" title="服务注册与发现-Zookeeper"></a>服务注册与发现-Zookeeper</h2><p>Zookeeper是一个分布式协调工具，可以替代Eureka服务器实现注册中心的功能。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-zookeeper-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!--先排除自带的zookeeper3.5.3--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--添加zookeeper3.4.12版本，保证和自己虚拟机/服务器的zookeeper版本一致--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>zookeeper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">spring</span><span class="token punctuation">:</span><span class="token attr-name">  application</span><span class="token punctuation">:</span><span class="token attr-name">    name</span><span class="token punctuation">:</span> <span class="token attr-value">cloud-provider-payment</span><span class="token attr-name">  cloud</span><span class="token punctuation">:</span><span class="token attr-name">    zookeeper</span><span class="token punctuation">:</span><span class="token attr-name">      connect-string</span><span class="token punctuation">:</span> <span class="token attr-value">10.211.55.4:2181</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableDiscoveryClient</span> <span class="token comment" spellcheck="true">//该注解用于使用consul或者zookeeper作为注册中心时添加</span><span class="token comment" spellcheck="true">//主启动类...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="服务注册与发现-Consul"><a href="#服务注册与发现-Consul" class="headerlink" title="服务注册与发现-Consul"></a>服务注册与发现-Consul</h2><p>Consul是一开源的分布式服务 发现和配置管理系统，由HashiCorp公司用Go语言开发。</p><p>提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。</p><p>它具有很多优点包括：基于raft协议，比较简洁；支持健康检查，同时支持HTTP和DNS协议支持跨数据中心的WAN集群，提供图形界面，跨平台：支持Linux、Mac、 Windows。</p><h3 id="Consul能做什么"><a href="#Consul能做什么" class="headerlink" title="Consul能做什么"></a>Consul能做什么</h3><ul><li>服务发现：提供HTTP和DNS两种发现方式。</li><li>健康监测：支持多种方式，HTTP、TCP、 Docker、 Shell脚本定制化</li><li>KV存储：Key、Value的存储方式</li><li>多数据中心：Consul支持多数据中心</li><li>可视化web界面</li></ul><h2 id="以上三个注册中心的异同点"><a href="#以上三个注册中心的异同点" class="headerlink" title="以上三个注册中心的异同点"></a>以上三个注册中心的异同点</h2><table><thead><tr><th align="center">组件名</th><th align="center">语言</th><th align="center">CAP</th><th align="center">服务健康检查</th><th align="center">对外暴露接口</th><th align="center">Spring Cloud集成</th></tr></thead><tbody><tr><td align="center">Eureka</td><td align="center">Java</td><td align="center">AP</td><td align="center">可配支持</td><td align="center">HTTP</td><td align="center">已集成</td></tr><tr><td align="center">Zookeeper</td><td align="center">Java</td><td align="center">CP</td><td align="center">支持</td><td align="center">客户端</td><td align="center">已集成</td></tr><tr><td align="center">Consul</td><td align="center">Go</td><td align="center">CP</td><td align="center">支持</td><td align="center">HTTP/DNS</td><td align="center">已集成</td></tr></tbody></table><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li>C：<strong>Consistency 强一致性</strong></li><li>A：<strong>Availability 高可用性</strong></li><li>P：<strong>Partition tolerance 分区容错性</strong></li></ul><p>CAP理论关注的重点是<strong>数据</strong>，最多只能同时较好的满足两个。</p><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求。因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：</p><p>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</p><p>CP - 满足强一致性，分区容错性的系统，通常性能不是特别高。</p><p>AP - 满足高可用性，分区容错性的系统，通常对一致性要求低些。</p><h2 id="服务调用-Ribbon-RestTemplate"><a href="#服务调用-Ribbon-RestTemplate" class="headerlink" title="服务调用-Ribbon+RestTemplate"></a>服务调用-Ribbon+RestTemplate</h2><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡</strong>的工具。</p><p>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer (简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询,随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><h3 id="Ribbon能做什么"><a href="#Ribbon能做什么" class="headerlink" title="Ribbon能做什么"></a>Ribbon能做什么</h3><p><strong>一句话：客户端的一套负载均衡工具，结合RestTemplate使用。</strong></p><p>LB负载均衡(Load Balance)是什么？</p><p>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高可用)。<br>常见的负载均衡有软件Nginx, LVS, 硬件F5等。</p><p>Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别？</p><ul><li>Nginx是服务负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。</li><li>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。</li></ul><p><strong>集中式LB</strong></p><p>即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件,如F5, 也可以是软件,如nginx), 由该设施负把访问请求通过某种策略转发至服务的提供方。 </p><p><strong>进程内LB</strong></p><p>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p><p>Ribbon就属于进程内LB，它只是一个库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p><h3 id="Ribbon架构说明"><a href="#Ribbon架构说明" class="headerlink" title="Ribbon架构说明"></a>Ribbon架构说明</h3><p>Ribbon其实就是一个软负载均衡的客户端组件,<br>他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdnmsietw4j31bi0rch6r.jpg" alt="Ribbon架构图" style="zoom: 33%;"><p>Ribbon在工作时分成两步</p><p>第一步先选择EurekaServer，它优先选择在同一个区域内负载较少的server.。</p><p>第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。</p><p>其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。</p><h3 id="Ribbon核心组件-IRule"><a href="#Ribbon核心组件-IRule" class="headerlink" title="Ribbon核心组件-IRule"></a>Ribbon核心组件-IRule</h3><p>根据特定算法中从服务列表中选取一个要访问的服务。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdnnpcsy55j319m0ggq8n.jpg" alt="IRule接口的实现类"></p><p>常用负载均衡策略</p><ul><li><p><strong>com.netflix.loadbalancer.RoundRobinRule</strong>：轮询（默认）</p></li><li><p><strong>com.netflix.loadbalancer.RandomRule</strong>：随机</p></li><li><p><strong>com.netflix.loadbalancer.RetryRule</strong>：重试</p><p>先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务。</p></li><li><p><strong>WeightedResponseTimeRule</strong></p><p>对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择。</p></li><li><p><strong>BestAvailableRule</strong>：选择一个最好的服务。</p><p>会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。</p></li><li><p><strong>AvailabilityFilteringRule</strong></p><p>先过滤掉故障实例，再选择并发较小的实例。</p></li><li><p><strong>ZoneAvoidanceRule</strong></p><p>默认规则，复合判断server所在区域的性能和server的可用性选择服务器。</p></li></ul><p><strong>如何配置不同的LB策略</strong></p><p>官方文档明确给出了警告:<br>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribblon客户端所共享，达不到特殊化定制的目的了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cherry<span class="token punctuation">.</span>myrule<span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyselfRule</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> IRule <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自定义LB为随机</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//在主启动类OrderMain80中添加如下注解</span><span class="token annotation punctuation">@RibbonClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"CLOUD-PAYMENT-SERVICE"</span><span class="token punctuation">,</span>configuration <span class="token operator">=</span> MyselfRule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Ribbon默认轮询负载均衡算法原理</strong></p><p>负载均衡算法: rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始。</p><p>List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(“CLOUD-PAYMENT-SERVICE”);</p><p>如：List [0] instances = 127.0.0.1:8002</p><p>​        List [1] instances = 127.0.0.1:8001</p><p>8001+ 8002组合成为集群，它们共计2台机器，集群总数为2，按照轮询算法原理:</p><ol><li>当总请求数为1时: 1 % 2 = 1 对应下标位置为1，则获得服务地址为127.0.0.1:8001</li><li>当总请求数位2时: 2 % 2 = 0 对应下标位置为0，则获得服务地址为127.0.0.1:8002</li><li>当总请求数位3时: 3 % 2 = 1 对应下标位置为1，则获得服务地址为127.0.0.1:8001</li><li>当总请求数位4时: 4 % 2 = 0 对应下标位置为0，则获得服务地址为127.0.0.1:8002</li></ol><p>如此类推……</p><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>通过Dash应用查看说明文档。使用restTemplate访问restful接口非常的简单粗暴无脑。</p><p>(urI, requestMap, ResponseBean.class)这三个参数分别代表REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>getForObject()/getForEntity()</strong></p><ul><li><p>如果使用的是getForObject()，返回对象为Json；</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/consumer/payment/get/{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> CommonResult<span class="token operator">&lt;</span>Payment<span class="token operator">></span> <span class="token function">getPayment</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> Long id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//log.info("");</span>    <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>PAYMENT_URL<span class="token operator">+</span><span class="token string">"/payment/get/"</span><span class="token operator">+</span>id<span class="token punctuation">,</span>CommonResult<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果使用的是getForEntity()，返回对象为ResponseEntity对象(包含了响应中一些重要信息响应头,响应状态码,响应体等)。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdnnd12irij313u0b849r.jpg" alt="ResponseEntity"></p></li></ul><p><strong>postForObject()/postForEntity()</strong></p><ul><li><p>如果使用的是postForObject()，返回对象为Json；</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/consumer/payment/create"</span><span class="token punctuation">)</span><span class="token keyword">public</span> CommonResult<span class="token operator">&lt;</span>Payment<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Payment payment<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//log.info("");</span>    <span class="token keyword">return</span> restTemplate<span class="token punctuation">.</span><span class="token function">postForObject</span><span class="token punctuation">(</span>PAYMENT_URL<span class="token operator">+</span><span class="token string">"/payment/create"</span><span class="token punctuation">,</span>payment<span class="token punctuation">,</span>CommonResult<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果使用的是postForEntity()，返回对象为ResponseEntity。</p></li></ul><p><strong>综上，如果返回值需要详细的信息，可使用xxForEntity，如果只是返回简单的Json，可使用xxForObject，推荐使用后者。</strong></p><h2 id="服务调用-OpenFeign"><a href="#服务调用-OpenFeign" class="headerlink" title="服务调用-OpenFeign"></a>服务调用-OpenFeign</h2><p>Feign是一个声明式 Webservice客户端。使用 Feign能让编写 Web service客户端更加简单。它的使用方法是<strong>定义一个服务接口然后在上面添加注解</strong>。 Feign也支持可拔插式的编码器和解码器。 Spring Cloud 对 Feign进行了封装使其支持了 Spring Mvc 标准注解和 Httpmessage Converters。 Feign可以与 Eureka 和 Ribbon 组合使用以支持负载均衡。</p><h3 id="OpenFeign能做什么"><a href="#OpenFeign能做什么" class="headerlink" title="OpenFeign能做什么"></a>OpenFeign能做什么</h3><p><strong>一句话：只需创建一个接口并在接口上添加注解即可。</strong></p><p>Feign旨在使编写 Java Http 客户端变得更容易。</p><p>前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封裝处理，形成了一套模版化的调用方法。但是在实际开发<br>中，由于对服务依赖的调用可能不止一处，往往个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装<br>这些依赖服务的调用。所以Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在 Feign 的实现下，<strong>我们只需创建一个接口并使用注解的方式来配置它</strong>(以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可，即可完成对服务提供方的接口绑定，简化了使用 Spring cloud Ribbon 时，自动封装服务调用客户端的开发量。</p><h3 id="OpenFeign集成了Ribbon"><a href="#OpenFeign集成了Ribbon" class="headerlink" title="OpenFeign集成了Ribbon"></a>OpenFeign集成了Ribbon</h3><p>利用Ribbon维护了Payment的服务列表信息，粗通过轮询实现了户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</p><table><thead><tr><th align="center">Feign</th><th align="center">OpenFeign</th></tr></thead><tbody><tr><td align="center">Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端。Feign内置了Ribbon，用来做客户端负载均衡去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口就可以调用服务注册中心的服务。</td><td align="center">OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。 OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>接口+注解：<strong>微服务调用接口+@FeignClient</strong>    (别忘了在<strong>主启动类上添加@EnableFeignClients</strong>开启Feign)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"CLOUD-PAYMENT-SERVICE"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PaymentFeignService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/payment/get/{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> CommonResult <span class="token function">getPaymentById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/payment/feign/timeout"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">paymentFeignTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OpenFeign超时控制"><a href="#OpenFeign超时控制" class="headerlink" title="OpenFeign超时控制"></a>OpenFeign超时控制</h3><p>OpenFeign默认等待1秒钟，超过后报错。为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#设置feign客户端超时时间(OpenFeign默认支持ribbon)</span><span class="token attr-name">ribbon</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">  #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间</span><span class="token attr-name">  ReadTimeout</span><span class="token punctuation">:</span> <span class="token attr-value">5000</span><span class="token comment" spellcheck="true">  #指的是建立连接后从服务器读取到可用资源所用的时间</span><span class="token attr-name">  ConnectTimeout</span><span class="token punctuation">:</span> <span class="token attr-value">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="OpenFeign日志打印"><a href="#OpenFeign日志打印" class="headerlink" title="OpenFeign日志打印"></a>OpenFeign日志打印</h3><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节。说白了就是对Feign接口的调用情况进行监控和输出。</p><p><strong>日志级别</strong></p><ul><li>NONE：默认的，不显示任何日志；</li><li>BASIC：仅记录请求方法、URL、 响应状态码及执行时间；</li><li>HEADERS：除了BASIC定义的信息之外，还有请求和响应的头信息；</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</li></ul><p><strong>配置日志级别</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cherry<span class="token punctuation">.</span>springcloud<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> feign<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    Logger<span class="token punctuation">.</span>Level <span class="token function">feignLoggerLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Logger<span class="token punctuation">.</span>Level<span class="token punctuation">.</span>FULL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">logging</span><span class="token punctuation">:</span><span class="token attr-name">  level</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">    #feign日志以什么级别监控哪个接口</span><span class="token attr-name">    com.cherry.springcloud.service.PaymentFeignService</span><span class="token punctuation">:</span> <span class="token attr-value">debug</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务降级-Hystrix"><a href="#服务降级-Hystrix" class="headerlink" title="服务降级-Hystrix"></a>服务降级-Hystrix</h2><h3 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h3><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败。</p><p>服务雪崩：多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“<strong>扇出</strong>”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p><p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。怎么办？？？</p><h3 id="Hystrix问世"><a href="#Hystrix问世" class="headerlink" title="Hystrix问世"></a>Hystrix问世</h3><p>Hystrix是一个用于处理分布式系统的<strong>延迟和容错</strong>的开源库，在分布式系统里，许多依赖不可避兔的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，<strong>不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</strong>。</p><p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控(类似熔断保险丝)，<strong>向调用方返回一个符合预期的、可处理的备选响应(FallBack) ，而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><h3 id="Hystrix能做什么"><a href="#Hystrix能做什么" class="headerlink" title="Hystrix能做什么"></a>Hystrix能做什么</h3><ul><li><strong>降级</strong>：服务器不可用时返回一个兜底的方案，不要长时间等也不要错误页面；返回友情提示页或者应急处理方案。</li><li><strong>熔断</strong>：系统后端的依赖出现了故障，比如某后台服务器挂掉了，每次请求都报错，后续请求不接收了，稍后再试。</li><li><strong>限流</strong>：高并发流量进来，比如QPS突然飙升到100万，服务会崩溃，限流可以做到10万QPS进入系统，其他90万被拒绝。</li><li><strong>运维监控</strong>：监控+报警+优化。各种异常情况，有问题就及时报警，优化系统的配置和参数。</li><li><strong>资源隔离</strong>：设置某块代码最多只能使用10个线程，不能再多，限定好资源的使用，避免有故障时出现资源被抢占光的情况。</li></ul><p>官方资料：<a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p><h3 id="Hystrix重要概念"><a href="#Hystrix重要概念" class="headerlink" title="Hystrix重要概念"></a>Hystrix重要概念</h3><h4 id="服务降级-fallback"><a href="#服务降级-fallback" class="headerlink" title="服务降级-fallback"></a>服务降级-fallback</h4><blockquote><p><strong>哪些情况会触发服务降级？</strong></p><ul><li>程序异常</li><li>请求超时</li><li>服务熔断</li><li>线程池/信号量打满</li></ul></blockquote><h4 id="服务熔断-break"><a href="#服务熔断-break" class="headerlink" title="服务熔断-break"></a>服务熔断-break</h4><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<br>当检测到该节点微服务调用响应正常后，恢复调用链路。<br>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败,就会启动熔断机制。熔断机制的注解是@HystrixCommand。</p><p>服务熔断类似<strong>保险丝</strong>，当访问次数达到某种限制后，服务降级 -&gt; 服务熔断 -&gt; 逐渐恢复调用链路。</p><blockquote><p><strong>熔断类型</strong></p><ul><li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR (平均故障处理时间)，当打开时长达到所设时钟则进入半熔断状态。</li><li>熔断关闭：熔断关闭不会对服务进行熔断。（相当于保险丝是闭合状态）</li><li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断。</li></ul></blockquote><p><strong>断路器的三个重要参数</strong></p><p>快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</p><p>请求总数阀值：在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用次数不足20次，即使所有的请求都超时或其他原因失败，断路器都不会打开。</p><p>错误百分比阀值：当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</p><blockquote><p><strong>断路器开启和关闭的条件</strong></p><ol><li>当满足一定的阀值的时候( 默认10秒内超过20个请求次数)</li><li>当失败率达到一定的时候(默认10秒内超过50%的请求失败)</li><li>到达以上阀值，<strong>断路器将会开启，此时所有请求都不会走主逻辑，而是让降级逻辑临时代替</strong>。</li><li>一段时间之后(默认是5秒)，这个时候断路器是<strong>半开状态，释放一次请求到原来的主逻辑上</strong>。</li><li>如果成功，断路器会关闭，若失败，继续开启。重复4和5。</li></ol></blockquote><h4 id="服务限流-flowlimit"><a href="#服务限流-flowlimit" class="headerlink" title="服务限流-flowlimit"></a>服务限流-flowlimit</h4><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行。<strong>（alibaba的Sentinel是重点）</strong></p><h3 id="Hystrix实现服务降级"><a href="#Hystrix实现服务降级" class="headerlink" title="Hystrix实现服务降级"></a>Hystrix实现服务降级</h3><p>超时不再等待，出错要有兜底。服务器压力上来后，访问速度变慢，如何解决？</p><ul><li>对方服务(8001)超时或者宕机了，调用者(80)不能一直卡死等待，必须有8001服务降级。</li><li>如果对方服务(8001)OK，调用者(80)自己出故障或有自我要求(自己的等待时间小于服务提供者)，80自己处理降级。</li></ul><h4 id="落地实现"><a href="#落地实现" class="headerlink" title="落地实现"></a>落地实现</h4><p>主启动类激活：@EnableCircuitBreaker</p><p>业务类启用：@HystrixCommand</p><p><strong>服务端降级处理（推荐配置在80客户端）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdopy00dthj31so0gmniu.jpg" alt="服务降级"></p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>方案一<strong>全局配置</strong>：通过以上方式对方法进行1对1配置，技术上可以，但是会造成代码膨胀严重，这时可以引入<strong>@DefaultProperties</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@DefaultProperties</span><span class="token punctuation">(</span>defaultFallback <span class="token operator">=</span> <span class="token string">"paymentGlobalFallbackMethod"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderHystrixController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@HystrixCommand</span>    <span class="token keyword">public</span> String <span class="token function">paymentInfo_Timeout</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span><span class="token punctuation">{</span>        String result <span class="token operator">=</span> paymentHystrixService<span class="token punctuation">.</span><span class="token function">paymentInfo_Timeout</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//全局fallback方法</span>    <span class="token keyword">public</span> String <span class="token function">paymentGlobalFallbackMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"80客户端Global服务降级处理,对方支付系统繁忙,请稍后再试~ \t o(╥﹏╥)o"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方案二<strong>重写接口</strong>：上面的方式还是有缺点，全局fallback方法和Controller在同一个类中，逻辑混乱，下面进一步优化</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在80客户端service接口上添加如下注释</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"CLOUD-PROVIDER-HYSTRIX-PAYMENT"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> PaymentFallbackService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//新建PaymentFallbackService类继承PaymentHystrixService，重写其方法</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PaymentFallbackService</span> <span class="token keyword">implements</span> <span class="token class-name">PaymentHystrixService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">paymentInfo_OK</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"-----PaymentFallbackService fallback paymentInfo_OK o(╥﹏╥)o"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">paymentInfo_Timeout</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"-----PaymentFallbackService fallback paymentInfo_Timeout o(╥﹏╥)o"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Hystrix实现服务熔断"><a href="#Hystrix实现服务熔断" class="headerlink" title="Hystrix实现服务熔断"></a>Hystrix实现服务熔断</h3><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"paymentCircuitBreaker_fallback"</span><span class="token punctuation">,</span>commandProperties <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@HystrixProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"circuitBreaker.enabled"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//是否开启断路器</span>            <span class="token annotation punctuation">@HystrixProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"circuitBreaker.sleepWindowInMilliseconds"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"10000"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//时间窗口期</span>            <span class="token annotation punctuation">@HystrixProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"circuitBreaker.requestVolumeThreshold"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//请求次数</span>            <span class="token annotation punctuation">@HystrixProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"circuitBreaker.errorThresholdPercentage"</span><span class="token punctuation">,</span>value <span class="token operator">=</span> <span class="token string">"60"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//失败率达到多少后跳闸</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">paymentCircuitBreaker</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"********** id 不能为负数"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String serialNumber <span class="token operator">=</span> IdUtil<span class="token punctuation">.</span><span class="token function">simpleUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价于 UUID.randomUUID();</span>        <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token operator">+</span><span class="token string">"调用成功,流水号:"</span><span class="token operator">+</span>serialNumber<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//服务降级,友好返回</span>    <span class="token keyword">public</span> String <span class="token function">paymentCircuitBreaker_fallback</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"id 不能为负数,请返回重试.o(╥﹏╥)o ~~~ id:"</span><span class="token operator">+</span>id<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HystrixDashboard-服务监控"><a href="#HystrixDashboard-服务监控" class="headerlink" title="HystrixDashboard-服务监控"></a>HystrixDashboard-服务监控</h3><p>除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控(Hystrix Dashboard)，Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求，多少成功，多少失败等。</p><p>Netflix通过<br>hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。</p><h4 id="配置监控"><a href="#配置监控" class="headerlink" title="配置监控"></a>配置监控</h4><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-hystrix-dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token annotation punctuation">@EnableCircuitBreaker</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PaymentHystrixMain8001</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>PaymentHystrixMain8001<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*此配置是为了服务监控而配置，与服务容错本身无关， springcloud 升级后的坑     *ServletRegistrationBean因为springboot的默认路径不是"/hystrix.stream",     *只要在自己的项目里配置上下面的servlet就可以了*/</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ServletRegistrationBean <span class="token function">getServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        HystrixMetricsStreamServlet streamServlet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HystrixMetricsStreamServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ServletRegistrationBean registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span>streamServlet<span class="token punctuation">)</span><span class="token punctuation">;</span>        registrationBean<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registrationBean<span class="token punctuation">.</span><span class="token function">addUrlMappings</span><span class="token punctuation">(</span><span class="token string">"/hystrix.stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registrationBean<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"HystrixMetricsStreamServlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="开启监控"><a href="#开启监控" class="headerlink" title="开启监控"></a>开启监控</h4><p>监控地址：<a href="http://localhost:9001/hystrix" target="_blank" rel="noopener">http://localhost:9001/hystrix</a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdp4m3zijjj31c80tmgwy.jpg" alt="启动监控"></p><h4 id="如何查看"><a href="#如何查看" class="headerlink" title="如何查看"></a>如何查看</h4><p><strong>7色</strong>：7种颜色表示7个状态。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdp4rlfhrqj310e014tae.jpg" alt="7种颜色"></p><p><strong>1圈</strong>：共有两种含义。</p><ul><li>它通过颜色的变化代表了实例的健康程度，它的健康度从绿色&lt;黄色&lt;橙色&lt;红色递减。</li><li>它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。</li></ul><p>所以通过该实心圆的展示，就可以在大量的实例中快速的发现<strong>故障实例和高压力实例</strong>。</p><p><strong>1线</strong>：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的升和下降趋势。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdp4xnsbuvj31rc0qsb0v.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdp4z8qqomj31sk08wdr2.jpg" alt></p><h2 id="服务网关-GateWay"><a href="#服务网关-GateWay" class="headerlink" title="服务网关-GateWay"></a>服务网关-GateWay</h2><p>Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和Project Reactor等技术。<br>Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，例如：熔断、限流、重试等。</p><p>为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底<strong>层则使用了高性能的Reactor模式通信框架Netty</strong>。Spring Cloud Gateway的目标提供统一的路由方式且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/指标和限流。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdqu3ygpy7j310w0pse0a.jpg" alt style="zoom: 50%;"><h3 id="GateWay能做什么"><a href="#GateWay能做什么" class="headerlink" title="GateWay能做什么"></a>GateWay能做什么</h3><ul><li>反向代理</li><li>鉴权</li><li>流量控制</li><li>熔断</li><li>日志监控</li></ul><h3 id="为什么选择Gateway"><a href="#为什么选择Gateway" class="headerlink" title="为什么选择Gateway"></a>为什么选择Gateway</h3><ul><li><p>netflix不太靠谱，zuul2.0一直跳票，迟迟不发布。</p></li><li><p>SpringCloud Gateway具有以下特性：</p><blockquote><p>基于Spring Framework 5，Project Reactor和Spring Boot 2.0进行构建；</p><p>动态路由：能够匹配任何请求属性，可以对路由指定Predicate (断言)和Filter (过滤器)；</p><p>集成Hystrix的断路器功能；</p><p>集成Spring Cloud服务发现功能；</p><p>易于编写的Predicate (断言)和Filter (过滤器)；</p><p>请求限流功能；</p><p>支持路径重写。</p></blockquote></li><li><p>SpringCloud Gateway与Zuul的区别</p><blockquote><ol><li>Zuul 1.x是个基于阻塞I/O的API Gateway。</li><li>Zuul 1.x基于Servlet 2. 5使用阻塞架构它不支持任何长连接(如WebSocket)。Zuul的设计模式和Nginx较像，每次I/O操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul 用Java实现，而JVM本身会有第一次加载较慢的情况，使得Zuul 的性能相对较差。</li><li>Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul 2.x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS (每秒请求数) Zuul的1.6倍。</li><li>Spring Cloud Gateway建立在Spring Framework，Project Reactor和Spring Boot2之上，使用非阻塞API。</li><li>Spring Cloud Gateway还支持WebSocket，組与Spring紧密集成拥有更好的开发体验。</li></ol></blockquote></li></ul><h3 id="Gateway的三大核心概念"><a href="#Gateway的三大核心概念" class="headerlink" title="Gateway的三大核心概念"></a>Gateway的三大核心概念</h3><p>Route(路由)：路由是构建网关的基本模块，它由ID，目标URI，一系列的<strong>断言</strong>和<strong>过滤器</strong>组成，如果断言为true则匹配该路由。</p><p>Predicate(断言)：开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由。 </p><p>Filter(过滤)：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</p><p>总而言之，web请求通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行些精细化控制。predicate就是我们的匹配条件；而filter就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri就可以实现一个具体的路由了。</p><h3 id="Gateway的工作流程"><a href="#Gateway的工作流程" class="headerlink" title="Gateway的工作流程"></a>Gateway的工作流程</h3><p><strong>路由转发 + 执行过滤链</strong></p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdquv7ak2fj30n80n6mzm.jpg" style="zoom:50%;"><p>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway Web Handler。<br>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。<br>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前( “pre” )或之后( “post” )执行业务逻辑。</p><p>Filter在”pre” 类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等。</p><p>在”post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p><h3 id="Predicate应用示例"><a href="#Predicate应用示例" class="headerlink" title="Predicate应用示例"></a>Predicate应用示例</h3><ul><li>After Route Predicate：在某某时间之后才生效。（时间格式在9527测试类中生成）</li><li>Before Route Predicate：在某某时间之前生效。</li><li>Between Route Predicate：在两个时间之间生效，两个时间用逗号隔开。</li><li>Cookie Route Predicate：需要两个参数，一个是cookie name，一个是KV键值对或者正则表达式。</li><li>Header Route Predicate：需要两个参数，一个是属性名称和正则表达式，属性值和正则匹配才执行。</li><li>Host Route Predicate：接收一组参数，一组匹配的域名列表，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。</li><li>Method Route Predicate：指定请求方式。</li><li>Path Route Predicate：指定请求路径。</li><li>Query Route Predicate：携带查询条件。</li></ul><p>示例</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">spring</span><span class="token punctuation">:</span><span class="token attr-name">  application</span><span class="token punctuation">:</span><span class="token attr-name">    name</span><span class="token punctuation">:</span> <span class="token attr-value">cloud-gateway</span><span class="token attr-name">  cloud</span><span class="token punctuation">:</span><span class="token attr-name">    gateway</span><span class="token punctuation">:</span><span class="token attr-name">      discovery</span><span class="token punctuation">:</span><span class="token attr-name">        locator</span><span class="token punctuation">:</span><span class="token attr-name">          enabled</span><span class="token punctuation">:</span> <span class="token attr-value">true #开启从注册中心动态创建路由的功能,利用微服务名进行路由</span><span class="token attr-name">      routes</span><span class="token punctuation">:</span><span class="token attr-name">        -</span> <span class="token attr-value">id: payment_route #路由的ID,没有固定规则但要求唯一,建议配合服务名</span><span class="token comment" spellcheck="true">#          uri: http://localhost:8001</span><span class="token attr-name">          uri</span><span class="token punctuation">:</span> <span class="token attr-value">lb://cloud-payment-service #匹配后提供服务的路由地址</span><span class="token attr-name">          predicates</span><span class="token punctuation">:</span><span class="token attr-name">            -</span> <span class="token attr-value">Path=/payment/get/** #路径相匹配的进行路由</span><span class="token comment" spellcheck="true">#            - After=2020-04-13T11:32:47.584+08:00[Asia/Shanghai] #在该时间后生效</span><span class="token comment" spellcheck="true">#            - Cookie=username,cherry #要携带cookie且名称和值匹配才允许访问</span><span class="token comment" spellcheck="true">#            - Header=X-Request-Id, \d+ #请求头要带有X-Request-Id参数,并且属性值为整数的正则</span><span class="token comment" spellcheck="true">#            - Host=**.lishaojie.top #前面无论是www还是blog都可以访问,其他的不行</span><span class="token comment" spellcheck="true">#            - Method=GET #GET请求才允许访问</span><span class="token comment" spellcheck="true">#            - Query=username, \d+ #要有参数名username并且值还要求为整数才允许访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。</p><h3 id="自定义全局GlobalFilter"><a href="#自定义全局GlobalFilter" class="headerlink" title="自定义全局GlobalFilter"></a>自定义全局GlobalFilter</h3><p>两个主要接口：implements GlobalFilter，Ordered</p><p>可以做全局日志记录，统一网关鉴权等。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLogGateWayFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span><span class="token punctuation">,</span> Ordered <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"*************come in MyLogGateWayFilter:"</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String uname <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"uname"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>uname <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"*******用户名为null,非法用户.o(╥﹏╥)o"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>NOT_ACCEPTABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置中心-Config"><a href="#配置中心-Config" class="headerlink" title="配置中心-Config"></a>配置中心-Config</h2><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、 动态的配置管理设施是必不可少的。</p><p>SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gds4yloggrj31lk0keqfp.jpg" alt="SpringCloud Config" style="zoom: 33%;"><p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为<strong>各个不同微服务应用</strong>的所有环境提供了一个<strong>中心化的外部配置</strong>。</p><h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><p>SpringCloud Config分为服务端和客户端两部分。</p><ul><li>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。</li><li>客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具紡便的管理和访问配置内容。</li></ul><h3 id="Config能做什么"><a href="#Config能做什么" class="headerlink" title="Config能做什么"></a>Config能做什么</h3><ul><li>集中管理配置文件</li><li>不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release</li><li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li><li>当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置</li><li>将配置信息以REST接口的形式暴露</li></ul><blockquote><p>常用形式：/{label}/{name}-{profiles}.yml</p><p>label：分支</p><p>name：服务名</p><p>profiles：环境（dev/test/prod）</p></blockquote><p>applicaiton. yml是用户级的资源配置项</p><p>bootstrap. yml是系统级的，优先级更加高</p><p>Spring Cloud会创建一个”Bootstrap Context”，作为Spring应用的 Application Context的父上下文。初始化时BootstrapContext负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。</p><p>Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.ymI文件，保证Bootstrap Context和Application Context配置的分离。</p><p>要将Client模块下的application.yml文件改为bootstrap:yml，这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">server</span><span class="token punctuation">:</span><span class="token attr-name">  port</span><span class="token punctuation">:</span> <span class="token attr-value">3355</span><span class="token attr-name">spring</span><span class="token punctuation">:</span><span class="token attr-name">  application</span><span class="token punctuation">:</span><span class="token attr-name">    name</span><span class="token punctuation">:</span> <span class="token attr-value">cloud-config-client</span><span class="token attr-name">  cloud</span><span class="token punctuation">:</span><span class="token attr-name">    config</span><span class="token punctuation">:</span><span class="token attr-name">      label</span><span class="token punctuation">:</span> <span class="token attr-value">master #分支</span><span class="token attr-name">      name</span><span class="token punctuation">:</span> <span class="token attr-value">config #配置文件名称</span><span class="token attr-name">      profile</span><span class="token punctuation">:</span> <span class="token attr-value">dev #读取后缀名称</span><span class="token attr-name">      uri</span><span class="token punctuation">:</span> <span class="token attr-value">http://localhost:3344 #配置中心地址</span><span class="token attr-name">eureka</span><span class="token punctuation">:</span><span class="token attr-name">  client</span><span class="token punctuation">:</span><span class="token attr-name">    service-url</span><span class="token punctuation">:</span><span class="token attr-name">      defaultZone</span><span class="token punctuation">:</span> <span class="token attr-value">http://localhost:7001/eureka</span><span class="token comment" spellcheck="true">#暴露监控端口</span><span class="token attr-name">management</span><span class="token punctuation">:</span><span class="token attr-name">  endpoints</span><span class="token punctuation">:</span><span class="token attr-name">    web</span><span class="token punctuation">:</span><span class="token attr-name">      exposure</span><span class="token punctuation">:</span><span class="token attr-name">        include</span><span class="token punctuation">:</span> <span class="token attr-value">"*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让运维人员多发送一个刷新命令，手动刷新。</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X POST <span class="token string">"http://localhost:3355/actuator/refresh"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="消息总线-Bus"><a href="#消息总线-Bus" class="headerlink" title="消息总线-Bus"></a>消息总线-Bus</h2><p>如果想实现分布式<strong>自动刷新配置功能</strong>，需要引入Spring Cloud Bus，配合Spring Cloud Config使用可以实现配置的动态刷新。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gds9xz1ocwj310m0io43t.jpg" alt="Bus"></p><p>Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。Bus目前支持两种消息代理：RabbitMQ和Kafka。</p><h3 id="SpringCloud-Bus能做什么"><a href="#SpringCloud-Bus能做什么" class="headerlink" title="SpringCloud Bus能做什么"></a>SpringCloud Bus能做什么</h3><p>Spring Cloud Bus能管理和传播分布式系统闸的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。</p><h3 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h3><p>在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线I在总线上的各个实例，都可以方便地广播-些需要让其他连接在该主题上的实例都知道的消息。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol><li><p>利用消息总线触发一个客户端/bus/refresh，从而刷新所有客户端的配置</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsh8kiqd1j31bm0run7u.jpg" alt="设计思想1" style="zoom:33%;"></li><li><p>利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，从而刷新所有客户端的配置<strong>（推荐）</strong></p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdshbw0mhwj31720skds1.jpg" alt="设计思想2" style="zoom:33%;"></li></ol><p><strong>设计思想2更合适，1不合适的原因如下：</strong></p><ul><li>打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。</li><li>破坏了微服务各节点的对等性。例如利用A通知BC，ABC三个应用是订单集群，这样A和BC的组成不同。</li><li>有一定的局限性。有一-定的局限性。例如微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改。</li></ul><p>全部通知：3344是配置中心的地址</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X POST "http://localhost:3344/actuator/bus-refresh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定点通知，精确通知：cloud-config-client:3355 是应用名称+端口号</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X POST <span class="token string">"http://localhost:3344/actuator/bus-refresh/cloud-config-client:3355"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsizjbmo3j321a0k6498.jpg" alt="总结图" style="zoom:50%;"><h2 id="消息驱动-Stream"><a href="#消息驱动-Stream" class="headerlink" title="消息驱动-Stream"></a>消息驱动-Stream</h2><p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架。</p><p>应用程序通过inputs或者outputs与Spring Cloud Stream中binder对象交互。通过我们配置来绑定，而Spring Cloud Stream的<strong>Binder</strong>对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。</p><p>目前仅支持RabbitMQ、Kafka。</p><h3 id="为什么要用Cloud-Stream"><a href="#为什么要用Cloud-Stream" class="headerlink" title="为什么要用Cloud Stream"></a>为什么要用Cloud Stream</h3><p>为了屏蔽底层消息中间件的差异，降低切换成本，实现统一消息的编程模型。比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange， kafka有Topic和Partitions分区，这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候springcloud Stream给我们提供了一种解耦合的方式。</p><h3 id="如何屏蔽底层差异"><a href="#如何屏蔽底层差异" class="headerlink" title="如何屏蔽底层差异"></a>如何屏蔽底层差异</h3><p><strong>通过定义绑定器Binder作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离</strong>。<br>通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件的具体实现。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsjrv9hlfj30ru0ocgsg.jpg" alt="Binder" style="zoom:33%;"><p>Binder：INPUT对应消费者，OUTPUT对应生产者。</p><p>Stream中的消息通信方式遵循了发布-订阅模式，使用Topic主题进行广播，在RabbitMQ就是Exchange，在Kafka中就是Topic。</p><h3 id="Cloud-Stream的标准流程"><a href="#Cloud-Stream的标准流程" class="headerlink" title="Cloud Stream的标准流程"></a>Cloud Stream的标准流程</h3><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsk2ex98vj316x0u0wn9.jpg" alt="标准流程" style="zoom: 50%;"><ul><li>Binder：很方便的连接中间件，屏蔽差异。</li><li>Channel：通道是队列Queue的一种抽象，在消息通信系统中就是实现存储和转发的媒介，通过Channel对队列进行设置。</li><li>Source和Sink：简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入。</li></ul><p><strong>编码API和常用注解</strong></p><table><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>Middleware</td><td>中间件，目前只支持RabbitMQ和Kafka</td></tr><tr><td>Binder</td><td>Binder是应用与消息中间件之间的封装，目前实行了Kafka和RabitMQ的Binder,，通过Binder可以很方便的连接中间件，可以动态的改变消息类型(对应于Kafka的topic，RabbitMQ的exchange)，这些都可以通过配置文件来实现</td></tr><tr><td>@Input</td><td>注解标识输入通道，通过该输入通道接收到的消息进入应用程序</td></tr><tr><td>@Output</td><td>注解标识输出通道，发布的消息将通过该通道离开应用程序</td></tr><tr><td>@StreamListener</td><td>监听队列，用于消费者的队列的消息接收</td></tr><tr><td>@EnableBinding</td><td>指信道channeI和exchange绑定在一起</td></tr></tbody></table><h3 id="如何解决重复消费"><a href="#如何解决重复消费" class="headerlink" title="如何解决重复消费"></a>如何解决重复消费</h3><p>比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。<strong>这时我们就可以使用Stream中的消息分组group来解决</strong>。</p><p><strong>故障现象</strong>：重复消费</p><p><strong>导致原因</strong>：默认分组group是不同的，组流水号不一样，被认为不同组。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdsmeniygvj31860mcjwo.jpg" alt="案例说明" style="zoom: 33%;"><p>注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。</p><p><strong>不同组是可以全面消费的(重复消费)，同一组内会发生竞争，只有其中一个可以消费。</strong></p><h3 id="如何防止丢失消息"><a href="#如何防止丢失消息" class="headerlink" title="如何防止丢失消息"></a>如何防止丢失消息</h3><p>现在就体现出group的强大之处了，分组既可以解决重复消费的问题，还可以在<strong>设置分组的消费者启动时自动获取丢失的消息</strong>。</p><h2 id="请求链路追踪-Sleuth"><a href="#请求链路追踪-Sleuth" class="headerlink" title="请求链路追踪-Sleuth"></a>请求链路追踪-Sleuth</h2><p>在微服务框架中，一个由客户端发 起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引|起整个请求最后的失败。</p><p>Spring Cloud Sleuth 提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin视图。</p><p>zipkin下载地址：<a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/2.12.9/" target="_blank" rel="noopener">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/2.12.9/</a></p><p>运行：java -jar zipkin-server-2.12.9-exec.jar</p><p>访问地址：localhost:9411/zipkin</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdt3homikpj31am0fatd2.jpg" alt="调用链路" style="zoom: 50%;"><p>一条链路通过Trace Id唯一标识，Span标识发起的请求信息，各span通过parent id关联起来，整条链路的依赖关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdt3j5xd61j31l20a240g.jpg" alt="依赖关系"></p><p>Trace：类似于树结构的Span集合，表示一条调用链路，存在唯一标识。</p><p>Span：表示调用链路来源，通俗的理解span就是一次请求信息。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>导入jar包</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--sleuth+zipkin--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-zipkin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写yml</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">  #sleuth+zipkin</span><span class="token attr-name">  zipkin</span><span class="token punctuation">:</span><span class="token attr-name">    base-url</span><span class="token punctuation">:</span> <span class="token attr-value">http://localhost:9411 #监控</span><span class="token attr-name">  sleuth</span><span class="token punctuation">:</span><span class="token attr-name">    sampler</span><span class="token punctuation">:</span><span class="token attr-name">      probability</span><span class="token punctuation">:</span> <span class="token attr-value">1 #采样率值介于0~1之间,1表示全部采集</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdt4o7c4ecj31n70u0158.jpg" alt="zipkin视图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能的web服务器-nginx</title>
      <link href="/2020/04/06/nginx/"/>
      <url>/2020/04/06/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="nginx重要概念"><a href="#nginx重要概念" class="headerlink" title="nginx重要概念"></a>nginx重要概念</h2><h3 id="什么是nginx"><a href="#什么是nginx" class="headerlink" title="什么是nginx"></a>什么是nginx</h3><ul><li>nginx是一个高性能的HTTP(服务器)和反向代理服务器，特点是<strong>占有内存少，并发能力强</strong>，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</li><li>nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl、php等。但是不支持Java，Java程序只能通过与tomcat配合完成。</li><li>nginx专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50,000个并发连接数。</li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><strong>正向代理</strong>：在客户端(浏览器)配置代理服务器，通过代理服务器进行互联网访问。比如国内访问Google需要正向代理。</p><p><strong>反向代理</strong>：其实客户端对反向代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器，获取数据后再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p>区别：正向代理的对象是客户端，反向代理的对象是服务器。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>由于并发量的提升，单个服务器解决不了，我们需要增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。不过nginx不是单纯的物理分离，而是把动态请求和静态请求分开，静态页面交给nginx，Tomcat来处理动态页面，下面会详细介绍。</p><h2 id="nginx的安装配置"><a href="#nginx的安装配置" class="headerlink" title="nginx的安装配置"></a>nginx的安装配置</h2><p>安装教程：<a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/linux/nginx-install-setup.html</a></p><p><strong>常用的web服务器</strong>：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等</p><p><strong>nginx的常用命令(进入/usr/local/webserver/nginx/sbin目录中)</strong></p><ul><li><code>./nginx -v</code>查看nginx版本号</li><li><code>./nginx -t</code>检查nginx.conf文件格式</li><li><code>./nginx</code>启动nginx</li><li><code>./nginx -s stop</code>停止nginx</li><li><code>./nginx -s reload</code>重新加载nginx.config</li></ul><h2 id="nginx的配置文件"><a href="#nginx的配置文件" class="headerlink" title="nginx的配置文件"></a>nginx的配置文件</h2><p>配置文件的目录：<code>/usr/local/webserver/nginx/conf/nginx.conf</code></p><h3 id="第一部分：全局块"><a href="#第一部分：全局块" class="headerlink" title="第一部分：全局块"></a>第一部分：全局块</h3><p>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行nginx服务器的用户(组)、允许生成的worker process数、进程PID存放路径、日志存放路径和类型以及配置文件的引入等。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_processes 1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是nginx服务器并发处理服务的关键配置，worker processes值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</p><h3 id="第二部分：events块"><a href="#第二部分：events块" class="headerlink" title="第二部分：events块"></a>第二部分：events块</h3><p>events块涉及的指令主要影响nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个wordprocess可以同时支持的最大连接数等。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_connections 1024<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这表示每个work process支持的最大连接数为1024，这部分的配置对nginx的性能影响较大，在实际中应该灵活配置。</p><h3 id="第三部分：http块"><a href="#第三部分：http块" class="headerlink" title="第三部分：http块"></a>第三部分：http块</h3><p>这算是nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是http块又包括http全局块和server块。</p><ol><li><p><strong>http全局块</strong></p><p>http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p></li><li><p><strong>server块</strong></p><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个http块可以包括多个server 块，而每个server 块就相当于一个虚拟主机。而每个server块也分为全局server块，同时包含多个locaton块。</p></li></ol><h2 id="location的匹配规则"><a href="#location的匹配规则" class="headerlink" title="location的匹配规则"></a>location的匹配规则</h2><p>基础语法有三种：</p><ul><li>location pattern {}    一般匹配</li><li>location <code>=</code> pattern {}    精准匹配</li><li>location <code>~</code> pattern {}    正则匹配</li></ul><blockquote><p><code>=</code> 用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p><p><code>~</code> 用于表示uri包含正则表达式，并且<strong>区分大小写</strong>。（一般使用区分的）</p><p><code>~*</code> 用于表示uri包含正则表达式，并且<strong>不区分大小写</strong>。</p><p><code>^~</code> 用于不含正则表达式的uri前，要求nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。</p></blockquote><p>注意：如果uri包含正则表达式，则必须要有 ~ 或者 ~* 标识。</p><h2 id="nginx配置反向代理"><a href="#nginx配置反向代理" class="headerlink" title="nginx配置反向代理"></a>nginx配置反向代理</h2><p>通过以下配置访问 10.211.55.4 可以被转发到 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 实现反向代理效果。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      80;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 10.211.55.4;</span><span class="token comment" spellcheck="true">        #charset koi8-r;</span><span class="token comment" spellcheck="true">        #access_log  logs/host.access.log  main;</span><span class="token attr-name">        location</span> <span class="token attr-value">/ {</span><span class="token attr-name">            root</span> <span class="token attr-value">  html;</span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">http://127.0.0.1:8080;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;</span>        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了测试效果，在虚拟机中创建Tomcat集群，需要修改如下3个端口号：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">&lt;Server</span> <span class="token attr-value">port="8006" shutdown="SHUTDOWN"></span><span class="token attr-name">&lt;Connector</span> <span class="token attr-value">port="8081" protocol="HTTP/1.1"</span><span class="token attr-name">               connectionTimeout</span><span class="token punctuation">=</span><span class="token attr-value">"20000"</span><span class="token attr-name">               redirectPort</span><span class="token punctuation">=</span><span class="token attr-value">"8443" /></span><span class="token attr-name">&lt;Connector</span> <span class="token attr-value">port="8010" protocol="AJP/1.3" redirectPort="8443" /></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试location的匹配规则，在Tomcat1的webapp目录下新建edu文件夹，放入a.html文件。在Tomcat2的webapp目录下新建vod文件夹，放入b.html文件。在nginx中做如下配置，通过location正则匹配，实现访问 10.211.55.4:9001 的不同路径来切换访问服务器。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">server</span> <span class="token attr-value">{</span><span class="token attr-name">    listen</span> <span class="token attr-value">       9001;</span><span class="token attr-name">    server_name</span> <span class="token attr-value">  10.211.55.4;</span><span class="token attr-name">    location</span> <span class="token attr-value">~ /edu/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://127.0.0.1:8081;</span>    }<span class="token attr-name">    location</span> <span class="token attr-value">~ /vod/ {</span><span class="token attr-name">        proxy_pass</span> <span class="token attr-value">http://127.0.0.1:8082;</span>    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nginx配置负载均衡"><a href="#nginx配置负载均衡" class="headerlink" title="nginx配置负载均衡"></a>nginx配置负载均衡</h2><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">    upstream</span> <span class="token attr-value">myserver {</span><span class="token attr-name">        server</span> <span class="token attr-value">10.211.55.4:8081 weight=1;</span><span class="token attr-name">        server</span> <span class="token attr-value">10.211.55.4:8082 weight=1;</span><span class="token comment" spellcheck="true">        #ip_hash;</span><span class="token comment" spellcheck="true">        #fair;</span><span class="token comment" spellcheck="true">        #least_conn;</span>    }<span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      80;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 10.211.55.4;</span><span class="token attr-name">        location</span> <span class="token attr-value">/ {</span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">http://myserver;</span><span class="token attr-name">            root</span> <span class="token attr-value">  html;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;</span><span class="token attr-name">        }</span> <span class="token attr-value"> </span><span class="token attr-name">    ........</span>     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nginx的负载均衡策略"><a href="#nginx的负载均衡策略" class="headerlink" title="nginx的负载均衡策略"></a>nginx的负载均衡策略</h3><ol><li><strong>轮询(默认)</strong>：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</li><li><strong>weight(权重)</strong>：默认为1，权重越高被分配的客户端越多。</li><li><strong>ip_hash</strong>：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，好处是不需要考虑session跨域。</li><li><strong>fair(第三方)</strong>：按照后端服务器的响应时间来分配请求，响应时间短的优先分配。</li><li><strong>url_hash</strong>：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</li><li><strong>least_conn</strong>：把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下least_conn就可以达到更好的负载均衡效果。</li></ol><p>默认的轮询策略提供如下参数：</p><table><thead><tr><th align="center">参数</th><th>作用</th></tr></thead><tbody><tr><td align="center">fail_timeout</td><td>与max_fails结合使用，表示max_fails次失败后服务器暂停的时间。</td></tr><tr><td align="center">max_fails</td><td>设置在fail_timeout参数设置的时间内最大失败次数，默认是1，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了，返回proxy_next_upstream模块定义的错误。</td></tr><tr><td align="center">fail_time</td><td>服务器会被认为停机的时间长度,默认为10s。</td></tr><tr><td align="center">backup</td><td>标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里，当其他所有的非backup机器down掉或者繁忙的时候才会请求backup服务器，因此这台机器压力会最低。</td></tr><tr><td align="center">down</td><td>标记服务器永久停机了，表示当前的server暂时不参与负载。</td></tr><tr><td align="center">weight</td><td>负载的权重，默认为1。weight越大，表示这台服务器被访问的几率就越大。</td></tr></tbody></table><h2 id="nginx配置动静分离"><a href="#nginx配置动静分离" class="headerlink" title="nginx配置动静分离"></a>nginx配置动静分离</h2><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gebtngozutj315s0p6tdq.jpg" alt style="zoom: 33%;"><p>动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过nginx来分开。</p><p>通过location指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。<strong>具体Expires定义：给一个资源设定一个过期时间</strong>，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。(如果经常更新的文件，不建议使用Expires来缓存)，比如设置3d，表示在这3天之内访问这个URL，发送一个请求，对比服务器该文件的最后更新时间有无变化，如果没有变化，则不会从服务器抓取，直接获取静态资源并返回状态码304(提示此为缓存资源)，如果有修改，则直接从服务器重新下载，返回状态码200。 </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在服务器的根目录中创建data文件夹，在data中创建www和image文件夹分别用来存放网页和图片，并做如下配置。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">     server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      80;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 10.211.55.4;</span><span class="token attr-name">        location</span> <span class="token attr-value">/www/ {</span><span class="token attr-name">            root</span> <span class="token attr-value">  /data/;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;</span>        }<span class="token attr-name">        location</span> <span class="token attr-value">/image/ {</span><span class="token attr-name">            root</span> <span class="token attr-value">  /data/;</span><span class="token attr-name">            autoindex</span> <span class="token attr-value">on;</span>        }<span class="token attr-name">    ........</span>     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>autoindex on; 是开启一个目录效果，在访问 <a href="http://10.211.55.4/data/image" target="_blank" rel="noopener">http://10.211.55.4/data/image</a> 时可以看到图片文件列表。</p><h2 id="nginx配置高可用集群"><a href="#nginx配置高可用集群" class="headerlink" title="nginx配置高可用集群"></a>nginx配置高可用集群</h2><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gebv84sw12j31o20jwn90.jpg" style="zoom:33%;"><p>两台nginx服务器都需要安装keepalived</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> keepalived -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 <code>rpm -q -a keepalived</code> 查看是否安装成功。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>安装完成后进入到 <code>/etc/keepalived/</code> 下有 <code>keepalived.conf</code> 文件。</p><ol><li><p>修改keepalived.conf文件</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#全局配置</span><span class="token attr-name">global_defs</span> <span class="token attr-value">{</span>    ...<span class="token attr-name">    router_id</span> <span class="token attr-value">10.211.55.4 #可以写ip或别名(host)，访问到主机</span>}<span class="token comment" spellcheck="true">#检测脚本的配置</span><span class="token attr-name">vrrp_script</span> <span class="token attr-value">chk_http_port {</span><span class="token attr-name">    script</span> <span class="token attr-value">"/usr/local/src/nginx_check.sh"</span><span class="token attr-name">    interval</span> <span class="token attr-value">2    #检测脚本执行间隔2秒</span><span class="token attr-name">    weight</span> <span class="token attr-value">2      #权重</span>}<span class="token comment" spellcheck="true">#虚拟IP的配置</span><span class="token attr-name">vrrp_instance</span> <span class="token attr-value">VI_1 {</span>    ...<span class="token attr-name">    state</span> <span class="token attr-value">MASTER         #主服务器是MASTER，备份服务器为BACKUP</span><span class="token attr-name">    interface</span> <span class="token attr-value">ens33      #绑定网卡，可以通过ifconfig查看</span><span class="token attr-name">    virtual_router_id</span> <span class="token attr-value">51 #主、备机的virtual_router_id必须相同</span><span class="token attr-name">    priority</span> <span class="token attr-value">100         #主、备机取不同的优先级，主机大于备份机</span><span class="token attr-name">    advert_int</span> <span class="token attr-value">1         #心跳检测，每隔1秒发送一次心跳</span><span class="token attr-name">    authentication</span> <span class="token attr-value">{     #权限校验方式</span><span class="token attr-name">        auth_type</span> <span class="token attr-value">PASS   #方式为密码</span><span class="token attr-name">        auth_pass</span> <span class="token attr-value">1111   #密码为1111</span>    }<span class="token attr-name">    virtual_ipaddress</span> <span class="token attr-value">{</span><span class="token attr-name">        10.211.55.99</span> <span class="token attr-value">    #虚拟IP</span>    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在/usr/local/src添加检测脚本，如果主nginx服务器挂掉了，启动备份服务器。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>A<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">ps</span> -C nginx -no-header <span class="token operator">|</span><span class="token function">wc</span> -l<span class="token variable">`</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$A</span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>    /usr/local/webserver/nginx/sbin/nginx    <span class="token function">sleep</span> 2    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ps</span> -C nginx --no-header <span class="token operator">|</span><span class="token function">wc</span> -l<span class="token variable">`</span></span> -eq 0 <span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>        <span class="token function">killall</span> keepalived    <span class="token keyword">fi</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>因为提前加入了检测nginx脚本，索引先启动nginx再启动keepalived。</p><p>启动keepalived命令： <code>systemctl start keepalived.service</code></p><p>停止的话先停keepalived，再停nginx <code>systemctl stop keepalived.service</code></p><h2 id="nginx原理与优化"><a href="#nginx原理与优化" class="headerlink" title="nginx原理与优化"></a>nginx原理与优化</h2><p>基本流程：首先客户端发送请求到nginx的master，相当于管理员，master得到任务后通知下面的worker，worker通过争抢机制得到任务后通过反向代理Tomcat来完成操作。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gebx87re57j318i0lgtn4.jpg" alt></p><h3 id="worker-processes工作线程数"><a href="#worker-processes工作线程数" class="headerlink" title="worker_processes工作线程数"></a>worker_processes工作线程数</h3><ul><li><p><strong>一个master多个worker有什么好处呢？</strong></p><ul><li>可以使用 <code>./nginx -s reload</code> 实现热部署。</li><li>对于每个worker都是独立的进程，保证服务不会中断，降低服务器风险。</li></ul></li><li><p><strong>nginx设置多少个worker才合适？</strong></p><p>nginx和redis类似都采用了io多路复用机制，每个worker都是一个独立的进程， 但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以<strong>worker数和服务器的cpu数相等是最为适宜的</strong>。设少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。</p></li></ul><h3 id="work-connection连接数"><a href="#work-connection连接数" class="headerlink" title="work_connection连接数"></a>work_connection连接数</h3><ul><li><p><strong>发送一个请求占用了worker多少连接数？</strong></p><p>2个或4个，如果请求的是静态资源，直接返回就是占用2个连接数。如果访问的请求需要查询数据库则需要占用4个连接数。</p></li><li><p><strong>假如nginx有1个master，4个worker，每个woker支持的最大连接数是1024，那么它支持的最大并发数是多少呢？</strong></p><p>静态资源访问的最大并发数是：worker_connection * worker_processes / 2 = 2048个</p><p>如果是HTTP作为反向代理来说：worker_connection * worker_processes / 4 = 1024个</p></li></ul><h3 id="Buffers缓存"><a href="#Buffers缓存" class="headerlink" title="Buffers缓存"></a>Buffers缓存</h3><p>如果buffer太小，nginx会不停的写一些临时文件，这样会导致磁盘不停的去读写，下面是buffer的一些相关参数：</p><ul><li><strong>client_body_buffer_size</strong>：允许客户端请求的最大单个文件字节数</li><li><strong>client_header_buffer_size</strong>：用于设置客户端请求的Header头缓冲区大小，大部分情况1KB大小足够</li><li><strong>client_max_body_size</strong>：设置客户端能够上传的文件大小，默认为1m</li><li><strong>large_client_header_buffers</strong>：该指令用于设置客户端请求的Header头缓冲区大小</li></ul><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">client_body_buffer_size</span> <span class="token attr-value">10K;</span><span class="token attr-name">client_header_buffer_size</span> <span class="token attr-value">1k;</span><span class="token attr-name">client_max_body_size</span> <span class="token attr-value">8m;</span><span class="token attr-name">large_client_header_buffers</span> <span class="token attr-value">2 1k;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Timeouts超时时间"><a href="#Timeouts超时时间" class="headerlink" title="Timeouts超时时间"></a>Timeouts超时时间</h3><ul><li><code>client_header_timeout</code>和<code>client_body_timeout</code>设置请求头和请求体(各自)的超时时间，如果没有发送请求头和请求体，nginx服务器会返回408错误或者request time out。</li><li><code>keepalive_timeout</code>给客户端分配<code>keep-alive</code>链接超时时间。服务器将在这个超时时间过后关闭链接，我们将它设置低些可以让nginx持续工作的时间更长。</li><li><code>send_timeout</code>指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接。</li></ul><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">client_body_timeout</span> <span class="token attr-value">12;</span><span class="token attr-name">client_header_timeout</span> <span class="token attr-value">12;</span><span class="token attr-name">keepalive_timeout</span> <span class="token attr-value">15;</span><span class="token attr-name">send_timeout</span> <span class="token attr-value">10;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="开启Gzip"><a href="#开启Gzip" class="headerlink" title="开启Gzip"></a>开启Gzip</h3><p>gzip可以帮助nginx减少大量的网络传输工作，另外要注意gzip_comp_level的设置，太高的话，nginx服务会浪费CPU的执行周期。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">gzip</span> <span class="token attr-value">on;</span><span class="token attr-name">gzip_comp_level</span> <span class="token attr-value"> 2;</span><span class="token attr-name">gzip_min_length</span> <span class="token attr-value"> 1000;</span><span class="token attr-name">gzip_proxied</span> <span class="token attr-value">    expired no-cache no-store private auth;</span><span class="token attr-name">gzip_types</span> <span class="token attr-value">      text/plain application/x-javascript text/xml text/css application/xml;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nginx日志切分"><a href="#nginx日志切分" class="headerlink" title="nginx日志切分"></a>nginx日志切分</h2><p>第一步：分析如何去实现日志切分，编写shell脚本，记得要给脚本赋予可执行权限。</p><p>第二步：启动定时任务对脚本进行调度：crontab -e</p><p>定时任务格式：</p><pre class="line-numbers language-bash"><code class="language-bash">*/1 * * * * sh /usr/local/webserver/nginx/logs/access.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三步：新增split_log.sh文件，并给其增加权限，chmod 777 文件名</p><p><strong>split_log.sh</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1garbdepmokj30ik0mm4ev.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步非阻塞-NIO</title>
      <link href="/2020/04/03/nio/"/>
      <url>/2020/04/03/nio/</url>
      
        <content type="html"><![CDATA[<h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>同步(Synchronization)和异步(Asynchronous)的方式：同步和异步都是基于应用程序和操作系统处理IO事件所采用的方式。</p><p><strong>同步</strong>：是应用程序要直接参与IO读写的操作。</p><p><strong>异步</strong>：所有的IO读写交给操作系统去处理，应用程序只需要等待通知。</p><p>同步方式在处理IO事件的时候，必须阻塞在某个方法上面等待我们的IO事件完成(阻塞IO事件或者通过轮询IO事件的方式)，对于异步来说，所有的IO读写都交给了操作系统。这个时候，我们可以去做其他的事情，并不需要去完成真正的IO操作，当操作完成IO后，会给我们的应用程序一个通知。</p><p><strong>同步的缺陷</strong></p><p>阻塞到IO事件，阻塞到read或则write。 这个时候我们就完全不能做自己的事情。让读写方法加入到线程里面，然后阻塞线程来实现，对线程的性能开销比较大。</p><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞(Block)和非阻塞(Non-Block)：阻塞和非阻塞是进程在访问数据的时候，数据是否准备就绪的一种处理方式。</p><p><strong>阻塞</strong>：当一个线程调用read()或write()方法时，直到数据被完全读取或写入，此期间不能做任何事。</p><p><strong>非阻塞</strong>：如果缓冲区的数据没有准备好则直接返回，不会等待。如果数据已经准备好，也直接返回。</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>BIO是一种传统的网络通讯模型，<strong>同步阻塞IO</strong>。谁用谁接收，必须等待数据接收完毕后才能处理业务逻辑。</p><p>它其实就是服务端创建一个ServerSocket， 然后客户端用一个Socket去连接服务端的ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟客户端的Socket进行通讯。接着客户端和服务端就进行阻塞式的通信，客户端发送一个请求，服务端Socket进行处理后返回响应。在响应返回前，客户端那边就阻塞等待，什么事情也做不了。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1geacy57ninj311g0hitam.jpg" alt="BIO流程图"></p><p>采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，接收到客户端连接之后为客户端连接创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的<strong>一请求一应答模型（Acceptor）</strong>。</p><p>这种方式的缺点：每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端。这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO是一种<strong>同步非阻塞IO</strong>，基于Reactor模型实现。（反应堆）</p><p>其实相当于就是一个线程处理大量的客户端的请求，通过一个线程轮询大量的channel，每次就获取一批有事件的channel，然后对每个请求启动一个线程处理即可。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1geadoo90l2j31100e0abn.jpg" alt="NIO流程图"></p><p>NIO的核心就是非阻塞，就是用一个selector线程就可以不停轮询channel，所有客户端请求都不会阻塞，面向缓冲区，不需要等待，直接就可以进来，大不了就是等待一会排下队而已。</p><p>NIO相较于BIO优化的核心是，一个客户端并不是时时刻刻都有数据进行交互，没有必要死耗着一个线程不放，所以客户端选择了让线程歇一歇，只有客户端有相应的操作的时候才发起通知，创建一个线程来处理请求。</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO是一种<strong>异步非阻塞IO</strong>，基于Proactor模型实现。</p><p>每个连接发送过来的请求，都会绑定一个Buffer，然后通知操作系统去完成异步的读，这个时间你就可以去做其他的事情，等到操作系统完成读之后，就会调用你的接口，给你操作系统异步读完的数据。这个时候你就可以拿到数据进行处理，将数据往回写。在往回写的过程，同样是给操作系统一个Buffer，让操作系统去完成写，写完了来通知你。这俩个过程都有buffer存在，数据都是通过buffer来完成读写。这里面的主要的区别在于将数据写入的缓冲区后，就不去管它，剩下的去交给操作系统去完成。操作系统写回数据也是一样，写到Buffer里面，写完后通知客户端来进行读取数据。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1geaedjoufbj311y0jm0us.jpg" alt="AIO流程图"></p><h3 id="面向流与面向缓冲区"><a href="#面向流与面向缓冲区" class="headerlink" title="面向流与面向缓冲区"></a>面向流与面向缓冲区</h3><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。</p><p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p><p>Java NIO是将数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9ox59wooj31k90u0e81.jpg" style="zoom: 50%;"><h2 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h2><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，它也是写入到缓冲区中的；任何时候访问NIO中的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。</p><p>在NIO中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer，对于Java中的基本类型，基本都有一个具体Buffer类型与之相对应，它们之间的继承关系如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge98z7oixzj31ii0ca75b.jpg" alt></p><h3 id="深入剖析Buffer"><a href="#深入剖析Buffer" class="headerlink" title="深入剖析Buffer"></a>深入剖析Buffer</h3><p>在谈到缓冲区时，我们说缓冲区对象本质上是一个数组，但它其实是一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用<code>get()</code>方法从缓冲区获取数据或者使用<code>put()</code>方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p><p>在缓冲区中，最重要的属性有下面三个，它们一起合作完成对缓冲区内部状态的变化跟踪：</p><ul><li><strong>position</strong>：指定了下一个将要被写入或者读取的元素索引，它的值由<code>get()/put()</code>方法自动更新，在新创建一个Buffer对象时，position 被初始化为0。</li><li><strong>limit</strong>：指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</li><li><strong>capacity</strong>：指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。</li><li>mark标记，调用mark()来设置mark=position，再调用reset()可以让position恢复到标记的位置。</li></ul><p>以上三个属性值之间有一些相对大小的关系:<code>0 &lt;= position &lt;= limit &lt;= capacity</code>。 如果我们创建一个新的容量大小为10的ByteBuffer对象，在初始化的时候position设置为0，limit和capacity被设置为10，在以后使用ByteBuffer对象过程中，capacity 的值不会再发生变化，而其它两个个将会随着使用而变化。四个属性值分别如图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge99r5d805j31840f842s.jpg" alt></p><p>现在我们可以从通道中读取一些数据到缓冲区中，注意从通道读取数据，相当于往缓冲区中写入数据。如果读取4个自己的数据，则此时position的值为4，即下一个将要被写入的字节索引为4，而limit仍然是10，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge99rjnxexj31820ewjvi.jpg" alt></p><p>下一步把读取的数据写入到输出通道中，相当于从缓冲区中读取数据，在此之前，必须调用<code>flip()</code>方法，该方法将会完成两件事情：</p><ol><li>把limit设置为当前的position值</li><li>把position设置为0</li></ol><p>由于position被设置为0，所以可以保证在下一步输出时读取到的是缓冲区中的第一个字节，而limit被设置为当前的position，可以保证读取的数据正好是之前写入到缓冲区中的数据，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge99u8uhuoj31840f0zoq.jpg" alt></p><p>现在调用<code>get()</code>方法从缓冲区中读取数据写入到输出通道，这会导致position的增加而limit保持不变，但position不会超过limit的值，所以在读取我们之前写入到缓冲区中的4个自己之后，position和limit的值都为4，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge99y2in5ej317w0ewn21.jpg" alt></p><p>在从缓冲区中读取数据完毕后，limit 的值仍然保持在我们调用<code>flip()</code>方法时的值，调用<code>clear()</code>方法能够把所有的状态变化设置为初始化时的值，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge99zh2zvij318o0esgpv.jpg" alt></p><h3 id="缓冲区分配"><a href="#缓冲区分配" class="headerlink" title="缓冲区分配"></a>缓冲区分配</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//分配指定大小的缓冲区</span>ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将现有数组包装成缓冲区</span><span class="token keyword">byte</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h3><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用<code>slice()</code>方法可以创建一个子缓冲区，让我们通过例子来看一下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BufferSlice</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化并赋值</span>        IntBuffer buffer <span class="token operator">=</span> IntBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建子缓冲区</span>        buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//子缓冲区的内容是3，4，5，6</span>        IntBuffer slice <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//改变子缓冲区的内容</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>slice<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> slice<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            b <span class="token operator">=</span> b<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>            slice<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//返回缓冲区</span>        buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果</span><span class="token number">0</span>  <span class="token number">1</span>  <span class="token number">2</span>  <span class="token number">30</span>  <span class="token number">40</span>  <span class="token number">50</span>  <span class="token number">60</span>  <span class="token number">7</span>  <span class="token number">8</span>  <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h3><p>只读缓冲区非常简单，可以读取但是不能写入数据。可以通过调用缓冲区的<code>asRead0nlyBuffer()</code>方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadOnlyBuffer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化并赋值</span>        IntBuffer buffer <span class="token operator">=</span> IntBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建只读冲区</span>        IntBuffer readOnly <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">asReadOnlyBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//改变原缓冲区的内容</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            b <span class="token operator">=</span> b<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//指定只读缓冲区视图</span>        readOnly<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        readOnly<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//只读缓冲区的内容也随之改变</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>readOnly<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>readOnly<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h3><p>直接缓冲区是为加快I/O速度，使用一种特殊方式为其分配内存的缓冲区，JDK 文档中的描述为：给定一个直接字节缓冲区，Java虚拟机将尽最大努力直接对它执行本机I/O操作。也就是说，它会在每一次调用底层操作系统的本机I/O操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中或者从一个中间缓冲区中拷贝数据。要分配直接缓冲区，需要调用<code>allocateDirect()</code>方法，而不是<code>allocate()</code>方法，使用方式与普通缓冲区并无区别，如下面的拷贝文件示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用allocateDirect()，而不是allocate()</span>ByteBuffer directBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>零拷贝</strong>：要想复制一个数据，它可以跨越JVM之外，在操作系统中直接分配内存，达到一个更高效的操作。</p><h3 id="内存映射文件I-O"><a href="#内存映射文件I-O" class="headerlink" title="内存映射文件I/O"></a>内存映射文件I/O</h3><p>内存映射文件I/O是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。内存映射文件I/O是通过使文件中的数据出现为内存数组的内容来完成的，这起初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。如下面的示例代码：</p><p>通俗的讲，就是<strong>把硬盘中的数据映射到内存中，通过修改内存中的缓存来直接修改硬盘中的数据。</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MappedBuffer</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        RandomAccessFile raf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"/Users/lishaojie/IdeaProjects/test.txt"</span><span class="token punctuation">,</span><span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileChannel fc <span class="token operator">=</span> raf<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MappedByteBuffer mbb <span class="token operator">=</span> fc<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>FileChannel<span class="token punctuation">.</span>MapMode<span class="token punctuation">.</span>READ_WRITE<span class="token punctuation">,</span>start<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        mbb<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mbb<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">122</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        raf<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h2><p>通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。在NIO中，提供了多种通道对象，而所有的通道对象都实现了Channel 接口。它们之间的继承关系如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9cbetf3bj31js0sgn08.jpg" alt></p><p>在前面我们说过，任何时候读取/写入数据，都不是直接从通道读取/写入，而是从通道读取/写入到缓冲区。</p><h3 id="使用NIO读取数据"><a href="#使用NIO读取数据" class="headerlink" title="使用NIO读取数据"></a>使用NIO读取数据</h3><ol><li>从FileInputStream获取Channel</li><li>创建Buffer</li><li>将数据从Channel读取到Buffer中</li></ol><p>下面是一个简单的使用NIO从文件中读取数据的例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileInputProgram</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        FileInputStream fi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"/Users/lishaojie/IdeaProjects/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取通道</span>        FileChannel channel <span class="token operator">=</span> fi<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//分配与文件尺寸等大的缓冲区</span>        <span class="token comment" spellcheck="true">//ByteBuffer buffer = ByteBuffer.allocate((int)channel.size());</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//读取数据到缓冲区</span>        channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fi<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用NIO写入数据"><a href="#使用NIO写入数据" class="headerlink" title="使用NIO写入数据"></a>使用NIO写入数据</h3><ol><li>从FileInputStream获取Channel</li><li>创建Buffer</li><li>将数据从Channel 写入到Buffer中</li></ol><p>下面是一个简单的使用NIO向文件中写入数据的例子：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FileOutputProgram</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0~9</span>    <span class="token comment" spellcheck="true">//将目标数据先转换为字节再写入</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        FileOutputStream fo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"/Users/lishaojie/IdeaProjects/test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileChannel channel <span class="token operator">=</span> fo<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> message<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>message<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        fo<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反应堆Reactor"><a href="#反应堆Reactor" class="headerlink" title="反应堆Reactor"></a>反应堆Reactor</h2><h3 id="阻塞I-O通信模型"><a href="#阻塞I-O通信模型" class="headerlink" title="阻塞I/O通信模型"></a>阻塞I/O通信模型</h3><p>假如现在你对阻塞I/O已有了一定了解，我们知道阻塞I/O在调用<code>InputStream.read()</code>方法时是阻塞的，它会一直等到数据到来时(或超时)才会返回；同样，在调用<code>ServerSocket.accept()</code>方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。阻塞I/O的通信模型示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9ellchxpj31fy0lgdss.jpg" alt></p><h3 id="阻塞I-O的缺点"><a href="#阻塞I-O的缺点" class="headerlink" title="阻塞I/O的缺点"></a>阻塞I/O的缺点</h3><ol><li>当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些CPU时间。</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</li></ol><h3 id="NIO原理及通信模型"><a href="#NIO原理及通信模型" class="headerlink" title="NIO原理及通信模型"></a>NIO原理及通信模型</h3><p>Java NIO是在jdk1.4开始使用的，它既可以说成“新I/O”，也可以说成非阻塞式I/O。下面是NIO的工作原理：</p><ol><li>由一个专门的线程来处理所有的IO事件，并负责分发，<strong>处理线程的数量不受客户端影响</strong>。</li><li>事件驱动机制：事件到的时候触发，而不是同步的去监视事件，引入<strong>排队机制</strong>。</li><li>线程通讯：线程之间通过wait,notify 等方式通讯，保证每次上下文切换都是有意义的，减少无谓的线程切换。</li></ol><p><strong>NIO的底层原理是反应堆</strong>，反应堆的工作原理图如下：</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9es3l3nnj31bu0jsndt.jpg" style="zoom:50%;"><h2 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h2><p>传统的Server/Client模式会基于TPR (Thread per Request)，服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这又带来了新的问题，如果线程池中有200个线程，而有200个用户都在进行大文件下载，会导致第201个用户的请求无法及时处理，即便第201个用户只想请求一个几KB大小的页面。</p><p><strong>NIO中非阻塞I/O采用了基于Reactor模式的工作方式</strong>，I/O 调用不会被阻塞，相反是注册感兴趣的特定I/O事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对象就是Selector，Selector 就是注册各种I/O事件地方，而且当那些事件发生时，就是这个对象告诉我们所发生的事件，如下图所示:</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge9f56l19tj30z50u011f.jpg" style="zoom: 33%;"><p>从图中可以看出，当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectionKey，同时从SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。</p><p>使用NIO中非阻塞I/O编写服务器处理程序，大体上可以分为下面三个步骤：</p><ol><li>向Selector对象注册感兴趣的事件</li><li>从Selector中获取感兴趣的事件</li><li>根据不同的事件进行相应的处理</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//注册事件</span><span class="token keyword">private</span> Selector <span class="token function">getSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建Selector对象</span>    Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建可选择通道，并配置为非阻塞模式</span>    ServerSocketChannel server <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    server<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//绑定通道到指定端口</span>    ServerSocket client <span class="token operator">=</span> server<span class="token punctuation">.</span>socket<span class="token punctuation">;</span>    InetSocketAddress address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//向Selector中注册感兴趣的事件</span>    server<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span>SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> selector<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了ServerSocketChannel对象，并调用configureBlocking()方法，配置为非阻塞模式，接下来的三行代码把该通道绑定到指定端口，最后向Selector中注册事件，此处指定的是参数是OP_ACCEPT，即指定我们想要监听accept事件，也就是新的连接发生时所产生的事件，对于ServerSocketChannel通道来说，我们唯一可以指定的参数就是OP_ACCEPT。</p><p>从Selector中获取感兴趣的事件，即开始监听，进入内部循环：(自定义监听方法)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//得到目前正在排队的事件</span>        <span class="token keyword">int</span> wait <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wait <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果无事件排队,进行下次轮询</span>        <span class="token comment" spellcheck="true">//将获取到的排队事件放入Set集合</span>        Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> iterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SelectionKey key <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">process</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//处理逻辑</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在非阻塞I/O中，内部循环模式基本都是遵循这种方式。首先调用<code>select()</code>方法，该方法会阻塞，直到至少有一个事件发生，然后再使用<code>selectedKeys()</code>方法获取发生事件的SelectionKey，再使用迭代器进行循环。<br>最后一步就是根据不同的事件，编写相应的处理代码：接受请求事件、读数据事件、写数据事件的不同处理。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>SelectionKey key<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//处理来自客户端的接入事件</span>        ServerSocketChannel server <span class="token operator">=</span> <span class="token punctuation">(</span>ServerSocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SocketChannel client <span class="token operator">=</span> server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设置为非阻塞模式</span>        <span class="token comment" spellcheck="true">//注册选择器,并设置为读取模式</span>        client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//处理来自客户端的读取请求</span>        SocketChannel client <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//往缓存区中读数据</span>        ByteBuffer buff <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buff<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String content <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buff<span class="token punctuation">.</span>array<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>            SelectionKey sKey <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span>SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>            sKey<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SocketChannel client <span class="token operator">=</span> <span class="token punctuation">(</span>SocketChannel<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer block <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="为什么说BIO是同步阻塞的呢？"><a href="#为什么说BIO是同步阻塞的呢？" class="headerlink" title="为什么说BIO是同步阻塞的呢？"></a>为什么说BIO是同步阻塞的呢？</h3><p>其实这里说的不是针对网络通讯模型而言，而是针对磁盘文件读写IO操作来说的。因为用BIO的流读写文件，例如FileInputStrem，是说你发起个IO请求直接hang死，卡在那里，必须等着搞完了这次IO才能返回。</p><h3 id="为什么说NIO是同步非阻塞？"><a href="#为什么说NIO是同步非阻塞？" class="headerlink" title="为什么说NIO是同步非阻塞？"></a>为什么说NIO是同步非阻塞？</h3><p>因为无论多少客户端都可以接入服务端，客户端接入并不会耗费一个线程，只会创建一个连接然后注册到selector上去，这样你就可以去干其他你想干的其他事情了。</p><p>一个selector线程不断的轮询所有的socket连接，发现有事件了就通知服务端，然后服务端就启动一个线程处理一个请求即可，这个过程就是<strong>非阻塞</strong>的。但是这个处理的过程中，还是要先读取数据，处理，再返回的，这是个<strong>同步</strong>的过程。</p><h3 id="为什么说AIO是异步非阻塞？"><a href="#为什么说AIO是异步非阻塞？" class="headerlink" title="为什么说AIO是异步非阻塞？"></a>为什么说AIO是异步非阻塞？</h3><p>通过AIO发起个文件IO操作之后，你立马就返回可以干别的事儿了，接下来就啥也不用管了，操作系统自己干完了IO之后，告诉你说ok了。</p><p>当你基于AIO的api去读写文件时， 当你发起一个请求之后，剩下的事情就是交给了操作系统。当读写完成后， 操作系统会来回调你的接口， 告诉你操作完成。在这期间不需要等待， 也不需要去轮询判断操作系统完成的状态，你可以去干其他的事情。同步就是自己还得主动去轮询操作系统，<strong>异步就是操作系统反过来通知你</strong>。所以来说， AIO就是异步非阻塞的。</p><h3 id="为什么传统的socket不支持海量连接？"><a href="#为什么传统的socket不支持海量连接？" class="headerlink" title="为什么传统的socket不支持海量连接？"></a>为什么传统的socket不支持海量连接？</h3><p>每次一个客户端接入，都是要在服务端创建一个线程来服务这个客户端的。这会导致大量的客户端的时候，服务端的线程数量可能达到几千甚至几万，几十万，这会导致服务器端程序负载过高，不堪重负，最终系统崩溃死掉。</p><h3 id="NIO多路复用机制如何支持海量连接？"><a href="#NIO多路复用机制如何支持海量连接？" class="headerlink" title="NIO多路复用机制如何支持海量连接？"></a>NIO多路复用机制如何支持海量连接？</h3><p>NIO是基于操作系统底层的Select通知机制的，一个Selector线程不断轮询多个Channel，这样避免了创建多个线程。只有当某个Channel有对应的请求事件的时候才会创建线程，可能说1000个请求， 只有100个请求是有数据交互的。这个时候可能server端就提供10个线程就能够处理这些请求。这样的话就可以避免了创建大量的线程。</p><h3 id="NIO中的Buffer是什么？"><a href="#NIO中的Buffer是什么？" class="headerlink" title="NIO中的Buffer是什么？"></a>NIO中的Buffer是什么？</h3><p>一般来说，如果你要通过NIO写数据到文件或者网络，或者是从文件和网络读取数据出来此时就需要通过Buffer缓冲区来进行。Buffer的使用一般有如下几个步骤：写入数据到Buffer，调用flip()方法，从Buffer中读取数据，调用clear()方法或者compact()方法。</p><h3 id="Buffer中的重要参数有哪些？"><a href="#Buffer中的重要参数有哪些？" class="headerlink" title="Buffer中的重要参数有哪些？"></a>Buffer中的重要参数有哪些？</h3><ul><li>capacity：缓冲区容量的大小，就是里面包含的数据大小。</li><li>limit：对buffer缓冲区使用的一个限制，从这个index开始就不能读取数据了。</li><li>position：代表着数组中可以开始读写的index， 不能大于limit。</li><li>mark：是类似路标的东西，在某个position的时候，设置一下mark，此时就可以设置一个标记。后续调用reset()方法可以把position复位到当时设置的那个mark上。去把position或limit调整为小于mark的值时，就丢弃这个mark。</li></ul><p>如果使用的是Direct模式创建的Buffer的话，就会减少中间缓冲直接使用DirectorBuffer来进行数据的存储。</p><h3 id="NIO中的Channel是什么？"><a href="#NIO中的Channel是什么？" class="headerlink" title="NIO中的Channel是什么？"></a>NIO中的Channel是什么？</h3><p>Channel是NIO中的数据通道，类似流，但是又有些不同。</p><p>Channel既可从中读取数据，又可以写数据到通道中，但是流的读写通常是单向的。</p><p>Channel可以异步的读写。Channel中的数据总是要先读到一个Buffer中，或者从缓冲区中将数据写到通道中。</p><h3 id="FileChannel的作用是什么？"><a href="#FileChannel的作用是什么？" class="headerlink" title="FileChannel的作用是什么？"></a>FileChannel的作用是什么？</h3><p>Buffer有不同的类型，同样Channel也有好几种类型</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。而FileChannel就是文件IO对应的管道，在读取文件的时候会用到这个管道。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式-Prototype Pattern</title>
      <link href="/2020/03/08/prototype/"/>
      <url>/2020/03/08/prototype/</url>
      
        <content type="html"><![CDATA[<h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><h3 id="传统方式复制对象"><a href="#传统方式复制对象" class="headerlink" title="传统方式复制对象"></a>传统方式复制对象</h3><pre class="line-numbers language-java"><code class="language-java">Sheep sheep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span><span class="token string">"Marry"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"白色"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sheep sheep2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span>sheep<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sheep sheep3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span>sheep<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sheep sheep4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span>sheep<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Sheep sheep5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sheep</span><span class="token punctuation">(</span>sheep<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>sheep<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="传统方式的优缺点"><a href="#传统方式的优缺点" class="headerlink" title="传统方式的优缺点"></a>传统方式的优缺点</h3><ol><li>优点是比较好理解，简单易操作。</li><li>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低。</li><li>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活。</li></ol><p><strong>解决方案</strong>：Java中Object类是所有类的根类，Object类提供 了一个clone()方法，该方法可以将一个Java对象复制一份，但是被clone的Java类必须要实现一个Cloneable接口，该接口表示该类能够复制且具有复制的能力——原型模式。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="原型模式介绍"><a href="#原型模式介绍" class="headerlink" title="原型模式介绍"></a>原型模式介绍</h3><ul><li>原型模式(Prototype)是指用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道创建的细节。</li><li>工作原理是通过将一个原型对象传给那个要发起创建的对象，这个要发起创建的对象通过请求原型对象拷贝它们自己来实施创建，即 <strong>对象.clone()</strong>。</li><li>原型模式的优点是让程序具有更高的效率和扩展性。</li></ul><h3 id="原型模式在spring中的应用"><a href="#原型模式在spring中的应用" class="headerlink" title="原型模式在spring中的应用"></a>原型模式在spring中的应用</h3><p>Bean的创建使用到了原型模式。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>people<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.cherry.bean.People<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prototype<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 一步步跟进去可以看到isPrototype(),这里使用了原型模式 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><strong>浅拷贝</strong></p><ol><li>对于数据类型是<strong>基本数据类型和String</strong>的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给<strong>新的对象</strong>。</li><li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行<strong>引用传递</strong>，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li><li>浅拷贝是使用默认的clone()方法来实现<br>sheep = (Sheep) super.clone();</li></ol><p><strong>深拷贝</strong></p><ol><li><p>复制对象的所有基本数据类型和String的成员变量值。</p></li><li><p>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。</p></li><li><p>深拷贝实现方式1：<strong>重写clone方法来实现深拷贝</strong>。</p></li><li><p>深拷贝实现方式2：<strong>通过对象序列化实现深拷贝(推荐)</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeepProtoType</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span>Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//……省略类的属性信息</span>    <span class="token comment" spellcheck="true">//方式1：重写被克隆类的clone()方法</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        object deep <span class="token operator">=</span> nu1l<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//这里完成对基本数据类型(属性)和String的克隆</span>        deep <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对引用类型的属性,进行单独处理</span>        DeepProtoType deepProtoType <span class="token operator">=</span> <span class="token punctuation">(</span>DeepProtoType<span class="token punctuation">)</span>deep<span class="token punctuation">;</span>        deepProtoType<span class="token punctuation">.</span>deepCloneableTarget <span class="token operator">=</span> <span class="token punctuation">(</span>DeepCloneableTarget<span class="token punctuation">)</span>deepCloneableTarget<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> deepProtoType<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//方式2：在被克隆的类中创建序列化方法</span>    <span class="token keyword">public</span> Object <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建流对象</span>        ByteArrayOutputStream bos <span class="token operator">=</span> null<span class="token punctuation">;</span>        ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>        ByteArrayInputStream bis <span class="token operator">=</span> null<span class="token punctuation">;</span>        ObjectInputStream ois <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//序列化</span>            bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">;</span>            oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前这个对象以对象流的方式输出</span>            <span class="token comment" spellcheck="true">//反序列化</span>            bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>            DeepProtoType copyObj <span class="token operator">=</span> <span class="token punctuation">(</span>DeepProtoType<span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> copyObj<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//try catch</span>            bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="原型模式的注意事项"><a href="#原型模式的注意事项" class="headerlink" title="原型模式的注意事项"></a>原型模式的注意事项</h3><ol><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态。</li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码。</li><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其原代码，违背了ocp原则。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM底层原理与性能优化</title>
      <link href="/2020/03/06/jvm/"/>
      <url>/2020/03/06/jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="1、JVM内存结构"><a href="#1、JVM内存结构" class="headerlink" title="1、JVM内存结构"></a>1、JVM内存结构</h2><h4 id="JVM由哪些部分组成？"><a href="#JVM由哪些部分组成？" class="headerlink" title="JVM由哪些部分组成？"></a>JVM由哪些部分组成？</h4><ol><li><strong>类加载器</strong>（ClassLoader）</li><li><strong>运行时数据区</strong>（Runtime Data Area）</li><li><strong>执行引擎</strong>（Execution Engine）</li><li><strong>本地库接口</strong>（Native Interface）</li></ol><h4 id="各组成部分的用途？"><a href="#各组成部分的用途？" class="headerlink" title="各组成部分的用途？"></a>各组成部分的用途？</h4><p>程序在执行之前先要把java代码转换成字节码(class文件)，jvm需要把字节码通过<strong>类加载器</strong>把文件加载到内存中<strong>(运行时数据区)</strong>，而字节码文件是jvm的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器<strong>(执行引擎)</strong>将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口<strong>(本地库接口)</strong>来实现整个程序的功能。</p><h4 id="类加载器是什么？"><a href="#类加载器是什么？" class="headerlink" title="类加载器是什么？"></a>类加载器是什么？</h4><p>通过一个类的全限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ul><li>启动类加载器(Bootstrap ClassLoader)：用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(Extension ClassLoader)：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>应用类加载器(Application ClassLoader)：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它，所以也称为系统类加载器。</li><li>用户自定义类加载器：通过继承 java.lang.ClassLoader类的方式实现。</li></ul><p>类加载器把 Java 字节码转换成 java.lang.Class 类的一个实例。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><ol><li><p>加载：程序运行之前jvm通过<strong>类加载器</strong>把编译完成的.class二进制文件加载到内存，供程序使用。</p></li><li><p>连接：</p><ul><li>验证：确保类加载的正确性。（可能有的class文件是通过其他方式编译出来的）</li><li>准备：为类的<strong>静态变量</strong>分配内存，将其初始化为<strong>默认值</strong> 。（int为0，boolean为false）</li><li>解析：把类中的符号引用转化为直接引用。（比如把方法名改为方法的内存地址）</li></ul></li><li><p>初始化：为类的静态变量赋予正确的初始值。（程序编写的值是真正的初始值）</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb1tmkh5oj30hl05j3zc.jpg" alt></p><h4 id="类加载器的双亲委派模型"><a href="#类加载器的双亲委派模型" class="headerlink" title="类加载器的双亲委派模型"></a>类加载器的双亲委派模型</h4><ol><li><p><strong>什么是双亲委派模型？</strong></p><p>双亲委派模型会保证父类加载器先加载类。（延伸：jvm判定两个类相同，不仅类名一致，还要被同一类加载器加载）</p></li><li><p><strong>双亲委派模型的工作过程？</strong></p><ul><li><p>当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p></li><li><p>当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.</p></li><li><p>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</p></li></ul></li><li><p><strong>从ClassLoader的源码来看看双亲委派模式</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检查该类是否加载过了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//没加载过的情况</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//如果自定义的类加载器的parent不为null,就调用parent的loadClass进行加载类 </span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//否则就去找bootstrap ClassLoader</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>               <span class="token comment" spellcheck="true">// to find the class.</span>               <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>               sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>               sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>               sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//从上面的代码来看，使用指定名称加载类分为以下3步：</span><span class="token comment" spellcheck="true">//调用findLoadedClass(String)来检查类是否已经被加载；</span><span class="token comment" spellcheck="true">//调用父类的loadClass方法，如果父类为空，就调用虚拟机内置的引导类加载器加载；</span><span class="token comment" spellcheck="true">//调用findClass(String)来查找该类。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>为什么这样设计(双亲委派的好处)？</strong></p><p>主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException。</p></li></ol><h2 id="2、Java内存模型"><a href="#2、Java内存模型" class="headerlink" title="2、Java内存模型"></a>2、Java内存模型</h2><h3 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h3><ul><li>Java内存模型本身是一种抽象的概念，并不真实存在，它描述的是一种规范，定义了程序中各个变量的访问方式。</li><li>线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了共享变量的副本。</li></ul><h3 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h3><p>线程通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p><ul><li><p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来<strong>隐式</strong>进行通信，典型的共享内存通信方式就是通过<strong>共享对象</strong>进行通信。</p></li><li><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来<strong>显式</strong>进行通信，在java中典型的消息传递方式就是wait()和notify()。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb0wr021kj30c80akt92.jpg" alt></p><h3 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h3><ol><li><p><strong>程序计数器</strong></p><p>程序计数器是一块较小的内存空间，可以看作当前线程正在执行的字节码的行号指示器。</p><p>程序计数器有两个作用：实现<strong>流程控制</strong>(循环、异常处理)和<strong>记录执行位置</strong>(多线程切换)。</p><p>线程私有，是唯一一个不会出现OutOfMemoryError的内存区域。</p><p>注意：如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。</p></li><li><p><strong>Java虚拟机栈</strong></p><p>描述Java方法运行过程的内存模型。</p><p>Java虚拟机栈会为每一个即将运行的方法创建<strong>“栈帧”(局部变量表、操作数栈、动态链接、方法出口)</strong>。</p><p>当Java方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。</p><p>线程私有，会出现StackOverFlowError和OutOfMemoryError两种异常。</p><p>注意：人们常说“堆”用来存放对象，“栈”用来存放局部变量不完全正确，只体现了栈的局部变量表部分。</p></li><li><p><strong>本地方法栈</strong></p><p>描述本地方法运行的内存模型。</p><p>本地方法被执行的时候，步骤和Java方法类似，执行完毕后相应的栈帧也会出栈并释放内存空间。</p></li><li><p><strong>堆</strong></p><p>用来<strong>存储对象</strong>的内存模型。</p><p>线程共享，堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。</p><p>可以进一步细分为：新生代、老年代。 新生代又可被分为：Eden、From Survior、To Survior。 </p><p>堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，不够用会抛出OutOfMemoryError。 </p></li><li><p><strong>方法区</strong></p><p>是堆的一个逻辑部分，用于存储被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等。 </p><p><strong>运行时常量池：是方法区的一部分</strong>，用于存放编译器生成的各种字面量和符号引用。</p></li></ol><p><strong>总结</strong>：</p><ul><li><p>程序计数器、Java虚拟机栈、本地方法栈是<strong>线程私有</strong>的，生命周期随着线程的创建而创建，随着线程的结束而死亡。 </p></li><li><p>堆、方法区是<strong>线程共享</strong>的，在JVM中只有一个堆、一个方法区。在JVM启动的时候就创建，JVM停止才销毁。</p></li><li><p><strong>StackOverFlowError</strong>： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 </p></li><li><p><strong>OutOfMemoryError</strong>： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li><li><p><strong>StackOverFlowError和OutOfMemoryError的异同？</strong> </p><p>StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。 而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 </p></li></ul><h3 id="内存溢出-out-of-memory"><a href="#内存溢出-out-of-memory" class="headerlink" title="内存溢出-out of memory"></a>内存溢出-out of memory</h3><p>是指程序在申请内存时，没有足够的内存空间供其使用，出现 OutOfMemory。</p><p>OOM详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2020/03/02/OOM/">内存溢出-OOM</a></p><h4 id="内存溢出的解决方案"><a href="#内存溢出的解决方案" class="headerlink" title="内存溢出的解决方案"></a>内存溢出的解决方案</h4><ol><li><p>修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p></li><li><p>检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p></li><li><p>对代码进行走查和分析，找出可能发生内存溢出的位置。</p><blockquote><p><strong>重点排查以下几点</strong></p><ul><li>检查对数据库查询中，是否有一次获得全部数据的查询。</li><li>检查代码中是否有死循环或递归调用。</li><li>检查是否有大循环重复产生新对象实体。</li><li>检查对数据库查询中，是否有一次获得全部数据的查询。</li><li>检查List、MAP等集合对象是否有使用完后，未清除的问题。</li></ul></blockquote></li><li><p>使用内存查看工具动态查看内存使用情况。</p></li></ol><h3 id="内存泄漏-memory-leak"><a href="#内存泄漏-memory-leak" class="headerlink" title="内存泄漏-memory leak"></a>内存泄漏-memory leak</h3><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p><blockquote><ul><li>常发性内存泄漏：发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。</li><li>偶发性内存泄漏：发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。</li><li>一次性内存泄漏：发生内存泄漏的代码只会被执行一次，比如泄漏发生在构造函数中。</li><li>隐式内存泄漏：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。</li></ul></blockquote><p>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。<br>真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。</p><h3 id="各个版本内存区域的变化"><a href="#各个版本内存区域的变化" class="headerlink" title="各个版本内存区域的变化"></a>各个版本内存区域的变化</h3><p>在Java7之前，HotSpot虚拟机中将GC分代收集扩展到了方法区，使用永久代来实现了方法区。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。但是在之后的HotSpot虚拟机实现中，逐渐开始将方法区从永久代移除。Java7中已经将运行时常量池从永久代移除，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。而在Java8中，已经彻底没有了永久代，将方法区直接放在一个与堆不相连的本地内存区域，这个区域被叫做元空间。</p><h2 id="3、JVM垃圾收集算法与收集器"><a href="#3、JVM垃圾收集算法与收集器" class="headerlink" title="3、JVM垃圾收集算法与收集器"></a>3、JVM垃圾收集算法与收集器</h2><p>垃圾收集算法与收集器涉及到的内容比较多，详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2020/03/04/GC/">垃圾回收-GC</a></p><h2 id="4、JVM生产问题的排查与解决"><a href="#4、JVM生产问题的排查与解决" class="headerlink" title="4、JVM生产问题的排查与解决"></a>4、JVM生产问题的排查与解决</h2><h3 id="JVM的参数类型"><a href="#JVM的参数类型" class="headerlink" title="JVM的参数类型"></a>JVM的参数类型</h3><h4 id="标配参数"><a href="#标配参数" class="headerlink" title="标配参数"></a>标配参数</h4><ul><li>-version</li><li>-help</li><li>java -showversion</li></ul><h4 id="X参数（了解）"><a href="#X参数（了解）" class="headerlink" title="X参数（了解）"></a>X参数（了解）</h4><ul><li>-Xint：解释执行（java -Xint -version）</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式（先编译再执行）默认</li></ul><h4 id="XX参数（重点掌握）"><a href="#XX参数（重点掌握）" class="headerlink" title="XX参数（重点掌握）"></a>XX参数（重点掌握）</h4><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><ul><li>公式<ul><li>-XX:+或者-某个属性（+表示开启｜-表示关闭）</li></ul></li><li>Case<ul><li>是否打印GC的收集细节：-XX:+PrintGCDetails 或 -XX:-PrintGCDetails</li><li>是否使用串行垃圾收集器：-XX:+UseSerialGC 或 -XX:-SerialGC</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcs8t3ec2uj30j409s7a4.jpg" style="zoom:50%;"><h5 id="KV设值类型"><a href="#KV设值类型" class="headerlink" title="KV设值类型"></a>KV设值类型</h5><ul><li>公式<ul><li>-XX:属性key=属性值value</li></ul></li><li>Case<ul><li>-XX:MetaspaceSize=128m（设置元空间的大小）</li><li>-XX:MaxTenuringThreshold=15（年轻代复制算法的最大年龄限制）</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcs940eaisj30jw09mdlt.jpg" style="zoom:50%;"><ul><li>两个经典参数（<strong>属于XX参数</strong>）<ul><li>-Xms：等价于-XX:InitialHeapSize</li><li>-Xmx：等价于-XX:MaxHeapSize</li></ul></li></ul><h3 id="如何查看JVM参数（重点）"><a href="#如何查看JVM参数（重点）" class="headerlink" title="如何查看JVM参数（重点）"></a>如何查看JVM参数（重点）</h3><ul><li><strong>java -XX:+PrintFlagsInitial</strong>：查看初始默认值</li><li><strong>java -XX:+PrintFlagsFinal</strong>：查看修改更新，“=”是默认加载的，带“:”的是用户或者JVM修改过的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcsa2u9s1hj31a40dktnn.jpg" alt></p><ul><li><p><strong>java -XX:+PrintCommandLineFlags -version</strong>：打印命令行参数，可以查看默认的垃圾回收器。</p><pre class="line-numbers language-bash"><code class="language-bash">➜  <span class="token variable"><span class="token variable">`</span>demo<span class="token variable">`</span></span> java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize<span class="token operator">=</span>134217728 -XX:MaxHeapSize<span class="token operator">=</span>2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version <span class="token string">"1.8.0_191"</span>Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token punctuation">(</span>build 1.8.0_191-b12<span class="token punctuation">)</span>Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> 64-Bit Server VM <span class="token punctuation">(</span>build 25.191-b12, mixed mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="JVM常用的配置参数"><a href="#JVM常用的配置参数" class="headerlink" title="JVM常用的配置参数"></a>JVM常用的配置参数</h3><p>-Xms：初始内存大小，默认为物理内存1/64，等价于-XX:InitialHeapSize。</p><p>-Xmx：最大分配内存，默认为物理内存1/4，等价于-XX:MaxHeapSize。</p><p>-Xss：设置单个线程栈的大小，一般默认为512k～1024k，等价于-XX:ThreadStackSize。</p><p>-Xmn：设置新声嗲的大小。</p><p>-XX:MetaspaceSize：设置元空间大小。（-Xms10 -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal）</p><p>-XX:+PrintGCDetails：显示GC日志。</p><p>-XX:SurvivorRatio：设置新生代中eden和s0和s1空间的比例。-XX:SurvivorRatio=8(默认)</p><p>-XX:NewRatio：配置老年代在堆中的占比，剩下1给新生代。-XX:NewRatio=2(新生代占1/3，老年代占2/3)</p><p>-XX:MaxTenuringThreshld：设置对象在新生代中的最大年龄。默认是15.</p><p><strong>典型案例设置</strong></p><p>-Xms128m -Xmx4096 -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseG1GC</p><hr><h3 id="生产服务器变慢怎么办"><a href="#生产服务器变慢怎么办" class="headerlink" title="生产服务器变慢怎么办"></a>生产服务器变慢怎么办</h3><blockquote><p>整机：<strong>top</strong> 先查看一下整机性能，主要看cpu mem id(idle):空闲率，还有load average，也可以使用uptime(低配版查看性能)</p><p>CPU：<strong>vmstat -n 2 3</strong></p><p>内存：free | free -g | free -m <strong>(推荐使用free -m)</strong>查看内存的使用和空闲情况，单位是MB</p><p>硬盘：<strong>df -h</strong> (disk free)</p><p>磁盘IO：iostat -xdk 2 3</p><p>网络IO：ifstat</p></blockquote><ul><li><p>整机：<code>top</code></p><ul><li>右上角<strong>load average</strong>：3个值代表1分钟，5分钟，15分钟系统的平均负载值，3个值相加除以3乘以100%，如果结果高于60%，说明系统的负载压力很大。（也可以直接输入uptime查看负载精简版）</li><li>查看<strong>%CPU</strong>和内存<strong>%MEM</strong>的占用比例。</li></ul></li><li><p>CPU：<code>vmstat -n 2 3</code></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb49fonjej3148064gne.jpg" alt></p><blockquote><p>一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数单位是秒，第二个参数是采样的次数。查看参数主要看两方面，一前一后，前面看procs，后面看cpu。</p><p>procs</p><ul><li>r：运行和等待CPU时间片的进程数，原则上1核的CPU的运行队列不要超过2，整个系统的运行队列不能超过总核数的2倍，<br>否则代表系统压力过大</li><li>b：等待资源的进程数，比如正在等待磁盘I/O、网络I/O等。</li></ul><p>cpu</p><ul><li><p><strong>us</strong>：用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序；</p></li><li><p><strong>sy</strong>：内核进程消耗的CPU时间百分比；</p></li><li><p><strong>us + sy</strong> 参考值为80%， 如果us + sy大于80%， 说明可能存在CPU不足。</p></li><li><p>id：处于空闲的CPU百分比；越高越好。</p></li><li><p>wa：系统等待IO的CPU时间百分比；</p></li><li><p>st：来自于一个虚拟机偷取的CPU时间的百分比。</p></li></ul></blockquote></li><li><p>内存：<code>free -m</code><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb849y0dcj314u0c442f.jpg" alt></p><p>查看额外：pidstat -p 进程号 -r 采样间隔秒数<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gcb86vzxduj30sw070tc6.jpg" alt></p></li><li><p>硬盘：<code>df -h</code><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcb93btg9wj30y00d27o5.jpg" alt></p></li><li><p>磁盘IO：<code>iostat -xdk 2 3</code></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbap9iegoj31po0ke4iz.jpg" alt></p><blockquote><p><strong>磁盘块设备分布</strong></p><ul><li>rkB/s 每秒读取数据量kB；</li><li>wkB/s 每秒写入数据量kB；</li><li>svctm I/O 请求的平均服务时间，单位毫秒；</li><li>await I/O 请求的平均等待时间，单位毫秒；值越小，性能越好；</li><li>util 一秒中有百分几的时间用于I/O操作。接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘；</li><li>rkB/s、wkB/s根据系统应用不同会有不同的值，但有规律遵循：长期、超大数据读写，肯定不正常，需要优化程序读取。svctm的值与await的值很接近，表示几乎没有I/O等待，磁盘性能好，如果await的值远高于svctm的值，则表示I/O队列等待太长，需要优化程序或更换更快磁盘。</li></ul></blockquote><p><strong>查看额外：pidstat -d 采样间隔秒数 -p 进程号</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbau03v5mj314e0awdpt.jpg" alt></p></li></ul><ul><li><p>网络IO：<code>ifstat</code></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbb07rl5uj312s09wgq6.jpg" alt></p></li></ul><h3 id="生产环境CPU占用过高怎么办"><a href="#生产环境CPU占用过高怎么办" class="headerlink" title="生产环境CPU占用过高怎么办"></a>生产环境CPU占用过高怎么办</h3><ol><li><p>先用top命令找出CPU占比最高的。</p></li><li><p>ps -ef | grep java | grep -v grep 或者 jps -l 进一步定位，得知是什么应用程序——PID。</p></li><li><p><strong>定位到具体线程或者代码。(ps -mp 进程号 -o THREAD,tid,time)</strong>——tid线程ID。</p><p>-m：显示所有的<strong>线程</strong>、-p：进程使用的CPU时间、-o：该参数后是用户自定义格式。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbbei6igzj30nq06ugqb.jpg" alt></p></li><li><p>将需要的线程ID转换为16进制格式（<strong>英文小写格式</strong>）</p></li><li><p><strong>jstack 进程ID | grep tid (16进制线程ID) -A60</strong>（打印60行）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcbbop4eloj30z40hfwqd.jpg" alt></p></li><li><p>成功定位到异常代码在JavaDemo02.java中——第10行，查看代码分析原因并修复。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收-GC</title>
      <link href="/2020/03/04/GC/"/>
      <url>/2020/03/04/GC/</url>
      
        <content type="html"><![CDATA[<h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a>如何确定垃圾</h2><ul><li><p><strong>引用计数算法</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p><strong>可达性分析算法</strong>：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p><strong>GC Root</strong>：虚拟机栈(局部变量表)中引用的对象、方法区中类的静态属性引用的对象、方法区中常量引用的对象、本地方法栈中引用的对象。<a id="more"></a></p></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li><p><strong>复制算法</strong>：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。</p><p>优点：效率高，不会产生碎片。</p><p>缺点：可用内存变为原来的一半，存活对象多时效率低（复制成本大）。</p></li><li><p><strong>标记-清除算法</strong>：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</p><p>优点：相比与复制算法来说不浪费内存。</p><p>缺点：会产生内存碎片，效率低（需要扫描两次）。</p></li><li><p><strong>标记-整理算法</strong>：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。</p><p>优点：避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。</p><p>缺点：效率比复制算法低，需要多维护一个链表使幸存对象连续。</p></li><li><p><strong>分代收集算法</strong>：一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p></li></ul><h2 id="GC什么时候开始？"><a href="#GC什么时候开始？" class="headerlink" title="GC什么时候开始？"></a>GC什么时候开始？</h2><p>GC经常发生的区域是堆区，堆区还可以细分为新生代1/3、老年代2/3，新生代还分为一个Eden区8/10和两个Survivor1/10区。</p><ul><li><p><strong>Minor GC</strong>，发生在新生代的GC，对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快;</p></li><li><p><strong>Full GC</strong>，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝;</p></li><li><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</p></li></ul><h2 id="引用-强软弱虚"><a href="#引用-强软弱虚" class="headerlink" title="引用-强软弱虚"></a>引用-强软弱虚</h2><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gctibb8vs6j30pu050wh2.jpg" alt></p><ul><li><p><strong>强引用</strong>：通过new出来的引用，只要强引用还存在，则不会回收。</p></li><li><p><strong>软引用</strong>：在内存不足的情况下，会被jvm回收。通过SoftReference类来实现。</p></li><li><p><strong>弱引用</strong>：非必须对象，只要已发生GC就会把它干掉。通过WeakReference类来实现。</p></li><li><p><strong>虚引用</strong>：相当于没有引用，被jvm干掉会收到系统通知。通过PhantomReference类来实现。</p></li></ul><h2 id="查看方式"><a href="#查看方式" class="headerlink" title="查看方式"></a>查看方式</h2><p><strong>java -XX:+PrintCommandLineFlags -version</strong></p><pre class="line-numbers language-bash"><code class="language-bash">➜  <span class="token variable"><span class="token variable">`</span>demo<span class="token variable">`</span></span> java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize<span class="token operator">=</span>134217728 -XX:MaxHeapSize<span class="token operator">=</span>2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC java version <span class="token string">"1.8.0_191"</span>Java<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> SE Runtime Environment <span class="token punctuation">(</span>build 1.8.0_191-b12<span class="token punctuation">)</span>Java HotSpot<span class="token punctuation">(</span>TM<span class="token punctuation">)</span> 64-Bit Server VM <span class="token punctuation">(</span>build 25.191-b12, mixed mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过以上参数<strong>-XX:+UseParallelGC</strong>：可以看出使用并行垃圾收集器。</p><p>垃圾收集器的种类：<strong>串行｜并行｜并发｜G1</strong></p><p><strong>UseSerialGC｜UseParallelGC｜UseConcMarkSweepGC｜UseParNewGC｜UseParallelOldGC｜UseG1GC</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloGC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloGC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过设置参数修改默认垃圾收集器：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcrgjz2dowj31d20kiauo.jpg" alt></p><p>在程序运行时进入Terminal，通过<code>jps</code>查看进程号，再使用<code>jinfo -flag 垃圾收集器 进程号</code>查看，“+”代表使用。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcrgm07mr8j30k00bs0zp.jpg" style="zoom:50%;"><h2 id="部分参数说明"><a href="#部分参数说明" class="headerlink" title="部分参数说明"></a>部分参数说明</h2><ul><li>DefNew：Default New Generation</li><li>Tenured：Serial Old</li><li>ParNew：Parallel New Generation</li><li>PSYoungGen：Parallel Scavenge Young Generation</li><li>ParOldGen：Parallel Old Generation</li></ul><h2 id="Server-Client模式"><a href="#Server-Client模式" class="headerlink" title="Server/Client模式"></a>Server/Client模式</h2><p>只需要掌握Server模式即可，Client模式基本用不到。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcrhnxxi48j30ps03wgnz.jpg" alt></p><p>操作系统：</p><ul><li>32位Windows操作系统，不论硬件如何都默认使用Client的JVM模式。</li><li>32位其他操作系统，2G内存+2个CPU以上的配置都用Server模式，低于该配置的还是Client模式。</li><li>64位的操作系统Only Server模式。</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>一个单线程的<strong>串行收集器</strong>，在垃圾收集时会(STW)暂停其他所有工作线程直到它收集结束。</p><p>串行收集器是最古老、最稳定以及效率高的收集器，可能会产生<strong>较长时间的停顿</strong>。</p><ul><li>新生代收集器</li><li>采用“复制”算法</li><li>单线程收集</li><li>高效：没有线程交互的开销</li></ul><p>用途：Java虚拟机运行在<strong>Client</strong>模式下默认的<strong>新生代</strong>垃圾收集器。</p><p>对应的JVM参数：-XX:+UseSerialGC，开启后默认使用<code>Serial+Serial Old</code>组合。</p><blockquote><p>关于自动激活另一个年代收集器的说明，C++源码中有解释：</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">bool Arguments::check_gc_consistency(){  bool status = true;  uint i = 0;  if(UseSerialGC)                       i++;  if(UseConcMarkSweepGC || UseParNewGC) i++;  if(UseParallelGC || UseParallelOldGC) i++;  if(UseG1GC)                           i++;  if(i > 1) {......}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新生代、老年代都会使用<code>串行</code>垃圾收集器。</p><p>新生代使用“复制”算法，老年代使用“标记-整理”算法。</p><hr><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>使用多个垃圾收集线程的<strong>并行垃圾收集器</strong>，在垃圾收集时会(STW)暂停其他所有工作线程直到它收集结束。</p><p>ParNew是Serial收集器的多线程版本，最常见的是配合CMS工作，也会(STW)暂停其他工作线程。</p><ul><li>新生代收集器</li><li>采用“复制”算法</li><li>多线程收集</li></ul><p>用途：Java虚拟机运行在<strong>Server</strong>模式下默认的<strong>新生代</strong>垃圾收集器。</p><p>对应的JVM参数：-XX:+UseParNewGC，开启后默认使用<code>ParNew+Serial Old</code>组合（<strong>不推荐</strong>）。</p><blockquote><p>-XX:ParallelGCThreads    限制线程数量，默认开启和CPU相同的线程数。</p></blockquote><p>新生代使用<code>并行</code>收集器，老年代使用<code>串行</code>收集器。</p><p>新生代使用“复制”算法，老年代使用“标记-整理”算法。</p><blockquote><p>Java HotSpot(TM) 64-Bit Server VM warning: Using the ParNew young collector with the Serial old collector is deprecated and will likely be removed in a future release.</p><p>翻译：Java HotSpot（TM）64位服务器虚拟机警告：不推荐将ParNew 新生代收集器与Serial old串行收集器一起使用，并可能在将来的版本中删除。</p></blockquote><hr><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>使用多个垃圾收集线程的<strong>并行垃圾收集器</strong>，即串行收集器在新生代和老年代的并行化，俗称“吞吐量优先”收集器。</p><ul><li>新生代收集器</li><li>采用“复制”算法</li><li>多线程收集</li></ul><p>Parallel Scavenge关注两个重点：</p><ol><li><code>可控制的吞吐量</code>：比如程序运行100分钟，垃圾收集时间1分钟，吞吐量就是99%。高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。</li><li><code>自适应调节策略</code>：虚拟机会根据当前的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。</li></ol><p>用途：适用于科学计算、大数据处理等弱交互场景。</p><p>对应JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC(<strong>JDK1.8可相互激活</strong>)开启后使用<code>Parallel+Parallel Old</code>组合。</p><p>新生代和老年代都使用<code>并行</code>收集器。(<strong>Java8默认的垃圾收集器：PSYoungGen+ParOldGen</strong>)</p><p>新生代使用“复制”算法，老年代使用“标记-整理”算法。 </p><blockquote><p>-XX:ParallelGCThreads=数字N    表示启动多少个GC线程。</p><p>CPU&gt;8：N=5/8</p><p>CPU&lt;8：N=CPU的实际个数</p></blockquote><hr><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="(Serial Old)"></a>(Serial Old)</h3><ul><li>老年代收集器</li><li>采用“标记-整理”算法</li><li>单线程收集</li></ul><p>Serial的老年代版本，Java8以后被废弃了，<strong>不推荐使用</strong>。</p><ol><li>在JDK1.5之前版本与新生代的Parallel Scavenge收集器搭配使用。</li><li>作为老年代版本中CMS收集器的后备垃圾收集方案。</li></ol><blockquote><p><strong>如要配置：-XX:+UseSerialOldGC，则会出现如下错误。</strong></p><p>Error：Could not create the Java Virtual Machine.</p><p>Error：A fatal exception has occurred. Program will exit.</p><p>Unrecongnized VM option ‘UseSerialOldGC’</p><p>Did you mean ‘(+/-)UseSerialGC’？</p><hr><p>错误：无法创建Java虚拟机。</p><p>错误：发生了致命的异常。程序将退出。</p><p>未编译的VM选项“UseSerialOldGC”</p><p>你是不是想使用“（+/-）UseSerialGC”？</p></blockquote><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><ul><li>老年代收集器</li><li>采用“标记-整理”算法</li><li>多线程收集</li></ul><p>Parallel Scavenge的老年代版本，在上面解释了，这里不在赘述。</p><hr><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS是一种以获取最短回收停顿时间为目标的收集器，适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。CMS非常适合堆内存大，CPU核数多的服务器端应用，是G1出现前大型应用的首选。</p><ul><li>老年代收集器</li><li>采用“标记-清除”算法</li><li>并发收集，低停顿</li></ul><blockquote><p><strong>优点：并发收集、低停顿，并发指的是和用户线程一起执行。</strong></p><p><strong>缺点：产生大量空间碎片、并发阶段CPU压力很大，会降低吞吐量。</strong></p></blockquote><p>用途：用户线程和垃圾收集线程同时执行，有时候不需要停顿用户线程，适用对响应时间有要求的场景（强交互）。</p><p>对应JVM参数：-XX:+UseConcMarkSweepGC，开启后使用<code>ParNew+CMS+Serial Old(担保机制)</code></p><ol><li>初始标记：只是标记一下GCRoot能直接关联的对象，速度很快，仍然需要<code>(STW)</code>暂停所有工作线程。</li><li>并发标记：进行GCRoot的跟踪过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。</li><li>重新标记：由于并发标记的同时用户线程依然运行，因此正式清理前，再做修正，仍然需要<code>(STW)</code>暂停工作线程。</li><li>并发清除：清除GCRoot不可达的对象，和用户线程一起工作，不需要暂停工作线程，基于标记结果直接清理。</li></ol><blockquote><p>由于耗时最长的<strong>并发标记</strong>和<strong>并发清除</strong>都是跟用户线程一起并发工作的，所以总体上来看CMS收集器的内存回收和用户线程是一起并发执行的，也因此可以做到停顿时间短，响应速度快。</p><p>由于并发进行，CMS的收集线程与应用线程会同时增加对堆内存的占用，也就是说，<strong>CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将会触发担保机制</strong>，串行老年代回收器将会以STW的方式进行一次GC，造成较大停顿。</p></blockquote><hr><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>想了解G1，我们先总结下以前收集器的特点：</p><ol><li>年轻代和老年代都是各自独立且连续的内存块</li><li>年轻代的收集都使用“复制”算法</li><li>老年代的收集必须扫描整个老年代区域</li><li>都是以尽可能少而快速的执行GC为设计原则</li></ol><p>G1(Garbage First)收集器是一款面向服务端应用的垃圾收集器。适用于多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的缩短垃圾收集器暂停时间。另外还有以下特性：</p><ul><li>与CMS类似，与应用线程并发执行</li><li>更快的整理空闲空间</li><li>需要更多的时间来预测GC停顿时间</li><li>不希望牺牲大量的吞吐性能</li><li>不需要更大的Java Heap</li></ul><p>G1收集器的设计目标是取代CMS收集器，它与CMS相比，在以下方面表现的更为出色：</p><blockquote><p>G1是一个有整理内存过程的垃圾收集器，不会产生内存碎片。</p><p>G1的STW更可控，G1在停顿时间上添加了预测机制，用户可以指定停顿时间。</p></blockquote><p>G1将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分(可以不连续)Region的集合——最大的好处是化整为零，避免全盘扫描，只需要按照区域来进行扫描即可。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcs3gh4vwej30jy0bwh0w.jpg" style="zoom:50%;"><p>在G1中还有一种特殊的区域，叫Humongous(巨大的)区域，它专门用来存放巨型对象，如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储，为了能找到连续的H区，有时候不得不启动Full GC。</p><hr><p><strong>G1收集器下的Yong GC</strong></p><p>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片。</p><ul><li>Eden区的数据移动到Survivor区，假如出现了Survivor区空间不够，Eden区数据会晋升到Old区。</li><li>Survivor区的数据移动到新的Survivor区，部分数据晋升到Old区。</li><li>最后Eden区收拾干净了，GC结束，用户的应用程序继续执行。</li></ul><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcs3y7ikhxj30zc0bg4nr.jpg" style="zoom: 50%;"><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcs3xte3dej30zu0cuqu5.jpg" style="zoom:50%;"><hr><p>G1参数配置</p><ul><li>-XX:+UseG1GC</li><li>-XX:G1HeapRegionSize=n：可指定分区大小（1M～32M，且必须是2的幂），默认将整堆划分为2048个分区。也就是说能够支持的最大内存是：32M*2048=65536M=64G内存。</li><li>-XX:MaxGCPauseMillis=n：最大GC停顿时间单位是毫秒，这个是软目标，JVM将尽可能（不保证）停顿时间小于这个时间。</li><li>-XX:InitiatingHeapOccupancyPercent=n：堆占用多少百分比的时候就触发GC，默认为45%。</li><li>-XX:ConcGCThreads=n：并发GC使用的线程数。</li><li>-XX:G1ReservePercent=n：设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险，默认值是10%。</li></ul><p>G1收集器把堆内存划分为大小固定的几个独立区域，并发的进行垃圾收集，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p><blockquote><p><strong>空间整合，G1收集器采用”标记-整理“算法，局部通过”复制“算法，不会产生内存碎片。</strong></p><p><strong>可预测停顿，在不牺牲吞吐量的前提下，实现低停顿垃圾回收。</strong></p></blockquote><hr><p>小总结：</p><table><thead><tr><th align="center">参数</th><th align="center">新生代收集器</th><th align="center">新生代算法</th><th align="center">老年代收集器</th><th align="center">老年代算法</th></tr></thead><tbody><tr><td align="center">-XX:+UseSerialGC</td><td align="center">Serial</td><td align="center">复制</td><td align="center">Serial Old</td><td align="center">标记-整理</td></tr><tr><td align="center">-XX:+UseParNewGC</td><td align="center">ParNew</td><td align="center">复制</td><td align="center">Serial Old</td><td align="center">标记-整理</td></tr><tr><td align="center">-XX:+UseParallelGC<br>-XX:+UseParallelOldGC</td><td align="center">Parallel Scavenge</td><td align="center">复制</td><td align="center">Parallel Old</td><td align="center">标记-整理</td></tr><tr><td align="center">-XX:+UseConcMarkSweepGC</td><td align="center">ParNew</td><td align="center">复制</td><td align="center">CMS+SerialOld(担保)</td><td align="center"><strong>标记-清除</strong></td></tr><tr><td align="center">-XX:+UseG1GC</td><td align="center">没有年代划分</td><td align="center">整体上采用标记-整理算法</td><td align="center">局部是通过复制算法</td><td align="center">不会产生内存碎片</td></tr></tbody></table><h2 id="如何选择收集器"><a href="#如何选择收集器" class="headerlink" title="如何选择收集器"></a>如何选择收集器</h2><ul><li><p>单CPU或小内存，单机程序（现在基本用不到）</p><p>-XX:+UseSerialGC</p></li><li><p>多CPU，需要最大吞吐量，如后台计算的弱交互型应用</p><p>-XX:+UseParallelGC 或 -XX:+UseParallelOldGC 均可。</p></li><li><p>多CPU，追求低停顿时间，需要快速响应的互联网应用</p><p>-XX:+UseConcMarkSweepGC</p></li></ul><h3 id="生产部署和调参优化"><a href="#生产部署和调参优化" class="headerlink" title="生产部署和调参优化"></a>生产部署和调参优化</h3><p>定制化诉求：java -server -Xms1024m -Xmx1024m -XX:+UseG1GC -jar <code>jar包/war包</code></p><h3 id="查看日志参数-XX-PrintGCDetails"><a href="#查看日志参数-XX-PrintGCDetails" class="headerlink" title="查看日志参数-XX:+PrintGCDetails"></a>查看日志参数-XX:+PrintGCDetails</h3><p><strong>YoungGC</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gctgwjxsv3j316c0dax31.jpg" alt></p><p><strong>FullGC</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcthckmrgyj32u60ngnpf.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存溢出-OOM</title>
      <link href="/2020/03/02/OOM/"/>
      <url>/2020/03/02/OOM/</url>
      
        <content type="html"><![CDATA[<h2 id="OOM架构"><a href="#OOM架构" class="headerlink" title="OOM架构"></a>OOM架构</h2><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcr5s7fjhtj30us0gqwou.jpg" alt></p><h2 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h2><p>此错误为<strong>栈内存溢出</strong>，出现原因是深度的方法调用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">testDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">testDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Exception in thread "main" java.lang.StackOverflowError</span><span class="token comment" spellcheck="true">//    at StackOverflowDemo.testDemo(StackOverflowDemo.java:6)</span><span class="token comment" spellcheck="true">//    at StackOverflowDemo.testDemo(StackOverflowDemo.java:6)</span><span class="token comment" spellcheck="true">//    at StackOverflowDemo.testDemo(StackOverflowDemo.java:6)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="java-lang-OutOfMemoryError"><a href="#java-lang-OutOfMemoryError" class="headerlink" title="java.lang.OutOfMemoryError"></a>java.lang.OutOfMemoryError</h2><h3 id="Java-heap-space"><a href="#Java-heap-space" class="headerlink" title="Java heap space"></a>Java heap space</h3><blockquote><p>由于<strong>对象太多</strong>导致内存溢出。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavaHeapSpaceDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">80</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//80MB</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//修改运行时虚拟机参数：Run ➞ Edit Configurations ➞ VM options：-Xms10m -Xmx10m</span><span class="token comment" spellcheck="true">//Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><span class="token comment" spellcheck="true">//    at JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java:3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h3><blockquote><p>由于<strong>GC回收时间过长</strong>导致内存溢出。</p></blockquote><p>过长的定义是：超过98%的时间用来做GC并且回收了不到2%的堆内存，连续多次GC都只回收了不到2%内存的极端情况下才会出现此错误。假如不抛出GC overhead limit exceeded会出现什么情况呢？那就是GC清理出的那点内存很快会再次被填满，迫使再次执行GC，恶性循环。CPU使用率一直是100%但是GC却没有明显效果。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCOverHeadDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//修改运行时虚拟机参数：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span><span class="token comment" spellcheck="true">//java.lang.OutOfMemoryError: GC overhead limit exceeded</span><span class="token comment" spellcheck="true">//    at java.lang.Integer.toString(Integer.java:401)</span><span class="token comment" spellcheck="true">//    at java.lang.String.valueOf(String.java:3099)</span><span class="token comment" spellcheck="true">//    at GCOverHeadDemo.main(GCOverHeadDemo.java:10)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Direct-buffer-memory"><a href="#Direct-buffer-memory" class="headerlink" title="Direct buffer memory"></a>Direct buffer memory</h3><blockquote><p>由于<strong>本地内存不足</strong>导致内存溢出。</p></blockquote><p>写NIO程序经常使用ByteBuffer对象来读取或者写入数据，这是一种基于通道(Channel)与缓冲区(Buffer)的I/O方式。它可以使用Native函数库<strong>直接分配堆外内存</strong>，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免了在Java堆和Native堆中来回复制数据。</p><ul><li><p>ByteBuffer.allocate(capability)：这种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢。</p></li><li><p>ByteBuffer.allocateDirect(capability)：这种方式是<strong>分配系统本地内存</strong>，不属于GC管辖范围，不需要内存拷贝速度快。</p></li></ul><p>但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收。这时候虽然堆内存充足，但是本地内存已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectBufferMemoryDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"配置的最大直接内存："</span><span class="token operator">+</span><span class="token punctuation">(</span>sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">maxDirectMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"MB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer bb <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//6MB</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//修改运行时虚拟机参数：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</span><span class="token comment" spellcheck="true">//配置的最大直接内存：5.0MB</span><span class="token comment" spellcheck="true">//Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory</span><span class="token comment" spellcheck="true">//    at java.nio.Bits.reserveMemory(Bits.java:694)</span><span class="token comment" spellcheck="true">//    at java.nio.DirectByteBuffer.&lt;init>(DirectByteBuffer.java:123)</span><span class="token comment" spellcheck="true">//    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><span class="token comment" spellcheck="true">//    at DirectBufferMemoryDemo.main(DirectBufferMemoryDemo.java:6)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="unable-to-create-newnative-thread"><a href="#unable-to-create-newnative-thread" class="headerlink" title="unable to create newnative thread"></a>unable to create newnative thread</h3><blockquote><p>由于应用程序<strong>创建太多线程超过系统承载极限</strong>导致内存溢出。</p></blockquote><p>这个错误在高并发请求服务器时比较常见，linux系统默认允许单个进程可以创建1024个线程（1024是理论数据，一般到900多就会抛异常），如果超过这个数量就会报OutOfMemoryError:unable to create newnative thread。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnableCreateNewThreadDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//注意for循环中没有配置范围</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//linux下创建940个线程后抛出异常</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread</span><span class="token comment" spellcheck="true">//    at java.lang.Thread.start0(Native Method)</span><span class="token comment" spellcheck="true">//    at java.lang.Thread.start(Thread.java:717)</span><span class="token comment" spellcheck="true">//    at UnableCreateNewThreadDemo.main(UnableCreateNewThreadDemo.java:11)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方案无非两种：降低应用程序创建线程的数量、修改linux系统的服务器配置扩大限制。</p><p>在linux的普通用户下：$ ulimit -u</p><p>得到的返回结果是：$ 1024 </p><p>$ vim /etc/security/limits.d/90-nproc.conf</p><pre class="line-numbers language-bash"><code class="language-bash">*        soft        nproc        1024root     soft        nproc        unlimited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如必要扩大限制，可以在root用户下添加普通用户并设置线程数量，不要直接修改 *</p><hr><h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3><blockquote><p>由于元空间满了导致内存溢出。</p></blockquote><p>Java8以后使用Metaspace来替代永久代。查看元空间的初始大小的方式如下：</p><p>➜ <code>demo</code> java -XX:+PrintFlagsInitial</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcra0rclwrj31ak0bqk4w.jpg" alt></p><p>永久代（元空间）存放了以下信息：</p><ul><li><p>虚拟机加载的类信息</p></li><li><p>常量池</p></li><li><p>静态变量</p></li><li><p>即时编译后的代码</p></li></ul><p>Metaspace元空间与永久代最大的区别在于：Metaspace并不在虚拟机内存中，而是使用本地内存。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetaSpaceDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OOMTest</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//静态内部类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>OOMTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                enhancer<span class="token punctuation">.</span><span class="token function">setUseCache</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> Object <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                        <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">"次后发生异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//修改运行时虚拟机参数：-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</span><span class="token comment" spellcheck="true">//362次后发生异常</span><span class="token comment" spellcheck="true">//Caused by: java.lang.OutOfMemoryError: Metaspace</span><span class="token comment" spellcheck="true">//    at java.lang.ClassLoader.defineClass1(Native Method)</span><span class="token comment" spellcheck="true">//    at java.lang.ClassLoader.defineClass(ClassLoader.java:763)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA快捷键（Mac版）</title>
      <link href="/2020/03/01/idea-hotkey/"/>
      <url>/2020/03/01/idea-hotkey/</url>
      
        <content type="html"><![CDATA[<h3 id="最常使用"><a href="#最常使用" class="headerlink" title="最常使用"></a>最常使用</h3><p><code>Ctrl + O</code>：快捷覆写方法</p><p><code>Ctrl+Enter</code>：Generate界面，快速生成Get，Set方法</p><p><code>Shift+Enter</code>：换到下一行</p><p><code>Command+R</code>：字符替换</p><p><code>Command+Shift+R</code>：可以在整个工程或着某个目录下面替换变量</p><p><code>Command+R</code>：运行当前工程</p><p><code>Command+Y</code>：查看选中当前源码</p><p><code>Command+D</code>：向下复制一行</p><p><code>Command+backspace</code>：删除一行</p><p><code>Ctrl+Shift+J</code>：把多行连接成一行，会去掉空格的行</p><p><code>Command+J</code>：可以生成一些自动代码，比如for循环</p><p><code>Command+B</code>：追踪变量的来源</p><p><code>Ctrl+Shift+B</code>：进入变量所属的类的源码</p><p><code>Command+Shift+F</code>：可以在整个工程或着某个目录下面查找变量</p><p><code>Command+E</code>：最近打开的文件</p><p><code>Alt+Enter</code>：导入包，自动修改</p><p><code>Command+Alt+L</code>：格式化代码</p><p><code>Command+P</code>：方法参数提示</p><p><code>Command+Alt+T</code>：Surround With，被选定代码块包裹</p><p><code>Command+/</code>：注释一行或着多行</p><p><code>Command+Shift+/</code>：多行注释</p><p><code>Command+Alt+左/右箭头</code>：返回上次编辑的位置</p><p><code>Command+左/右箭头</code>：光标跳到该行代码的最左边/最右边</p><p><code>Alt + F1</code>：快捷选择</p><p><code>Shift+F6</code>：文件重命名</p><p><code>Alt+F7</code>：查找变量方法使用过的地方</p><p><code>Command+Shift+上下箭头</code>：把代码上移或着下移</p><p><code>Command+F12</code>：可以显示当前文件的结构</p><p><code>Command+Alt+B</code>：可以导航到一个抽象方法的实现代码</p><p><code>Command+,</code>：呼出偏好设置</p><h3 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h3><ul><li>⌘ Command</li><li>⇧ Shift</li><li>⌥ Option</li><li>⌃ Ctrl</li><li>↩︎ Return/Enter</li><li>⌫ BackSpace</li><li>⌦ 向前删除键（Fn+BackSpace）</li><li>↑ 上箭头</li><li>↓ 下箭头</li><li>← 左箭头</li><li>→ 右箭头</li><li>⇞ Page Up（Fn+↑）</li><li>⇟ Page Down（Fn+↓）</li><li>Home Fn + ←</li><li>End Fn + →</li><li>⇥ 右制表符（Tab键）</li><li>⇤ 左制表符（Shift+Tab）</li><li>⎋ Escape (Esc)</li></ul><h3 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h3><ul><li>⌃Space 基本的代码补全（补全任何类、方法、变量）</li><li>⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型）</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌘P 显示方法的参数信息</li><li>⌃J, Mid. button click 快速查看文档</li><li>⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li>⌘+鼠标放在代码上 显示代码简要信息</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌃O 覆盖方法（重写父类方法）</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）</li><li>⌘/ 注释/取消注释与行注释</li><li>⌘⌥/ 注释/取消注释与块注释</li><li>⌥↑ 连续选中代码块</li><li>⌥↓ 减少当前选中的代码块</li><li>⌃⇧Q 显示上下文信息</li><li>⌥↩ 显示意向动作和快速修复代码</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⌃⌥I 自动缩进线</li><li>⇥ / ⇧⇥ 缩进代码 / 反缩进代码</li><li>⌘X 剪切当前行或选定的块到剪贴板</li><li>⌘C 复制当前行或选定的块到剪贴板</li><li>⌘V 从剪贴板粘贴</li><li>⌘⇧V 从最近的缓冲区粘贴</li><li>⌘D 复制当前行或选定的块</li><li>⌘⌫ 删除当前行或选定的块的行</li><li>⌃⇧J 智能的将代码拼接成一行</li><li>⌘↩ 智能的拆分拼接的行</li><li>⇧↩ 开始新的一行</li><li>⌘⇧U 大小写切换</li><li>⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始</li><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ / ⌘- 展开 / 折叠代码块</li><li>⌘⇧+ 展开所以代码块</li><li>⌘⇧- 折叠所有代码块</li><li>⌘W 关闭活动的编辑器选项卡</li></ul><h3 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h3><ul><li>Double ⇧ 查询任何东西</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li><li>⌘R 文件内替换</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘⇧R 全局替换（根据路径）</li><li>⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li>⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h3 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h3><ul><li>⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法</li><li>⌘⇧F7 在文件中突出显示的用法</li><li>⌘⌥F7 显示用法</li></ul><h3 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h3><ul><li>⌘F9 编译Project</li><li>⌘⇧F9 编译选择的文件、包或模块</li><li>⌃⌥R 弹出 Run 的可选择菜单</li><li>⌃⌥D 弹出 Debug 的可选择菜单</li><li>⌃R 运行</li><li>⌃D 调试</li><li>⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置</li></ul><h3 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h3><ul><li>F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li>F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</li><li>⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li>⇧F8 跳出</li><li>⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点</li><li>⌥F8 计算表达式（可以更改变量值使其生效）</li><li>⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li>⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li>⌘⇧F8 查看断点信息</li></ul><h3 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h3><ul><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>⌘⌥O 前往指定的变量 / 方法</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>⌘⇧F4 关闭活动run/messages/find/… tab</li><li>⌘L 在当前文件跳转到某一行的指定处</li><li>⌘E 显示最近打开的文件记录列表</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li>⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</li><li>⌃⇧B 跳转到类型声明处</li><li>⌘U 前往当前光标所在方法的父类的方法 / 接口定义</li><li>⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li>⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li>⌃H 显示当前类的层次结构</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置</li><li>F4 / ⌘↓ 编辑/查看代码源</li><li>⌥ Home 显示到当前文件的导航条</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li></ul><h3 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h3><ul><li>F5 复制文件到指定目录</li><li>F6 移动文件到指定目录</li><li>⌘⌫ 在文件上为安全删除文件，弹出确认框</li><li>⇧F6 重命名文件</li><li>⌘F6 更改签名</li><li>⌘⌥N 一致性</li><li>⌘⌥M 将选中的代码提取为方法</li><li>⌘⌥V 提取变量</li><li>⌘⌥F 提取字段</li><li>⌘⌥C 提取常量</li><li>⌘⌥P 提取参数</li></ul><h3 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h3><ul><li>⌘K 提交代码到版本控制器</li><li>⌘T 从版本控制器更新代码</li><li>⌥⇧C 查看最近的变更记录</li><li>⌃C 快速弹出版本控制器操作面板</li></ul><h3 id="Live-Templates（动态代码模板）"><a href="#Live-Templates（动态代码模板）" class="headerlink" title="Live Templates（动态代码模板）"></a>Live Templates（动态代码模板）</h3><ul><li>⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li>⌘J 插入自定义动态代码模板</li></ul><h3 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h3><ul><li>⌘⌥Y 同步、刷新</li><li>⌃⌘F 切换全屏模式</li><li>⌘⇧F12 切换最大化编辑器</li><li>⌥⇧F 添加到收藏夹</li><li>⌥⇧I 检查当前文件与当前的配置文件</li><li>⌘, 打开IDEA系统设置（Preferences）</li><li>⌘; 打开项目结构对话框（Project Structure）</li><li>⇧⌘A 查找动作（可设置相关选项）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hotkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java锁-Sync&amp;Lock</title>
      <link href="/2020/02/29/lock/"/>
      <url>/2020/02/29/lock/</url>
      
        <content type="html"><![CDATA[<h2 id="乐观锁｜悲观锁"><a href="#乐观锁｜悲观锁" class="headerlink" title="乐观锁｜悲观锁"></a>乐观锁｜悲观锁</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</p><p>java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2019/02/28/CAS/">CAS算法原理</a></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。java 中的悲观锁就是 Synchronized，AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到，才会转换为悲观锁，如 ReentrantLock。</p><h2 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁-SpinLock"></a>自旋锁-SpinLock</h2><p>自旋锁原理非常简单， 如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换（进入阻塞挂起状态等待被唤醒），它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<a id="more"></a></p><p>详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2020/02/21/SpinLock/">自旋锁-SpinLock</a></p><h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h2><p>指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程外层方法获取锁的时候，在进入内层方法会自动获取锁。也就是说，<strong>线程可以进入任何一个它已经拥有的锁所同步着的代码块</strong>。</p><p><strong>ReentrantLock</strong>和<strong>Synchronized</strong>都是可重入锁，可重入锁的最大作用在于避免死锁。</p><ul><li><p><strong>Synchronized实现原理</strong></p><p>每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁并调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p><blockquote><p>每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。synchronized 是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。</p><p>synchronized 进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀；</p></blockquote></li><li><p><strong>ReentrantLock实现原理</strong></p><p>ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p>ReentrantLock主要利用了AQS原理，简单可理解为：</p><pre class="line-numbers language-java"><code class="language-java">lock aqs<span class="token punctuation">{</span>  自旋  <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  CAS<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2020/02/23/AQS/">ReentrantLock源码解析-AQS</a></p><h2 id="公平锁｜非公平锁"><a href="#公平锁｜非公平锁" class="headerlink" title="公平锁｜非公平锁"></a>公平锁｜非公平锁</h2><p><strong>公平锁</strong>：是指多个线程按照申请锁的顺序来获取锁，性能下降，但是顺序得到保障，讲究先来后到。</p><p><strong>非公平锁</strong>：是指多个线程获取锁的顺序并不是按照申请锁的顺序，先抢先得，抢不到再排队。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//可重入锁的空构造方法默认使用ReentrantLock(false)</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有boolean类型参数的构造方法,fair=true为公平锁，false为不公平锁</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>  sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<strong>ReentrantLock</strong>而言，可以通过构造函数指定该锁是公平锁还是非公平锁，默认无参构造是非公平锁。</p><p>对于<strong>Synchronized</strong>而言，也是一种<strong>非公平锁</strong>。</p><p>非公平锁的优点在于吞吐量比公平锁大,性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列；缺点是在高并发的情况下，有可能造成<strong>优先级反转</strong>或者<strong>饥饿现象</strong>。</p><h2 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁-ReadWriteLock"></a>读写锁-ReadWriteLock</h2><p>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。</p><h3 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h3><p>如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁。</p><h3 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h3><p>如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！</p><p>Java 中读写锁有个接 口 java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantReadWriteLock<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ReentrantReadWriteLock rwLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 写方法，包含写锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t writing..."</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t finish writing!"</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            rwLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 读方法，包含读锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t reading..."</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            Object result <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t finish reading!"</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            rwLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 线程操纵类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantReadWriteLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyCache myCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tempInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">,</span>tempInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                myCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tempInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//1     writing...1</span><span class="token comment" spellcheck="true">//1     finish writing!1</span><span class="token comment" spellcheck="true">//2     writing...2</span><span class="token comment" spellcheck="true">//2     finish writing!2</span><span class="token comment" spellcheck="true">//3     writing...3</span><span class="token comment" spellcheck="true">//3     finish writing!3</span><span class="token comment" spellcheck="true">//4     writing...4</span><span class="token comment" spellcheck="true">//4     finish writing!4</span><span class="token comment" spellcheck="true">//5     writing...5</span><span class="token comment" spellcheck="true">//5     finish writing!5</span><span class="token comment" spellcheck="true">//1     reading...1</span><span class="token comment" spellcheck="true">//1     finish reading!1</span><span class="token comment" spellcheck="true">//3     reading...3</span><span class="token comment" spellcheck="true">//5     reading...5</span><span class="token comment" spellcheck="true">//5     finish reading!5</span><span class="token comment" spellcheck="true">//4     reading...4</span><span class="token comment" spellcheck="true">//2     reading...2</span><span class="token comment" spellcheck="true">//2     finish reading!2</span><span class="token comment" spellcheck="true">//4     finish reading!4</span><span class="token comment" spellcheck="true">//3     finish reading!3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="独占锁｜共享锁"><a href="#独占锁｜共享锁" class="headerlink" title="独占锁｜共享锁"></a>独占锁｜共享锁</h2><p><strong>独占锁</strong>：该锁一次只能被一个线程锁持有。ReentrantLock和Synchronized都是独占锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p><strong>共享锁</strong>：该锁可被多个线程同时持有。ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁。共享锁可保证并发读诗非常高效的，读写，写读，写写的过程是互斥的。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态， 这个成本非常高， 状态之间的转换需要相对比较长的时间， 这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。</p><p>JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后， 为了减少获得锁和释放锁所带来的性能消耗， 提高性能，引入了“轻量级锁”和“偏向锁”。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前， 先明白一点，轻量级锁所适应的场景是线程<strong>交替执行</strong>同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</p><p>锁的状态总共有四种：<strong>无锁状态、偏向锁、轻量级锁和重量级锁</strong>。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。</p><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径， 因为轻量级锁的获取及释放依赖多次 CAS 原子指令， 而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p><blockquote><p>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</p></blockquote><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁并非一种实际的锁，而是一种思想。ConcurrentHashMap 是学习分段锁的最好实践。</p><p>详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2019/03/19/ConcurrentHashMap/">ConcurrentHashMap底层实现</a></p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><h3 id="减少锁持有时间"><a href="#减少锁持有时间" class="headerlink" title="减少锁持有时间"></a>减少锁持有时间</h3><p>只用在有线程安全要求的程序上加锁。</p><h3 id="减小锁粒度"><a href="#减小锁粒度" class="headerlink" title="减小锁粒度"></a>减小锁粒度</h3><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。</p><p>降低了锁的竞争， 偏向锁， 轻量级锁成功率才会提高。 最最典型的减小锁粒度的案例就是ConcurrentHashMap。</p><h3 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h3><p>最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度， 如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉它们都将无法推进下去。如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci5y7k0boj30q60ce7cy.jpg" style="zoom:50%;"><h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ol><li>系统资源不足</li><li>进程运行推进的顺序不合适</li><li>资源分配不当</li></ol><h3 id="手写一个死锁"><a href="#手写一个死锁" class="headerlink" title="手写一个死锁"></a>手写一个死锁</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HoldLockThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockA<span class="token punctuation">;</span>    <span class="token keyword">private</span> String lockB<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">HoldLockThread</span><span class="token punctuation">(</span>String lockA<span class="token punctuation">,</span> String lockB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockA <span class="token operator">=</span> lockA<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockB <span class="token operator">=</span> lockB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 自己持有："</span> <span class="token operator">+</span> lockA <span class="token operator">+</span> <span class="token string">"\t 尝试获得："</span> <span class="token operator">+</span> lockB<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lockB<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 自己持有："</span> <span class="token operator">+</span> lockB <span class="token operator">+</span> <span class="token string">"\t 尝试获得："</span> <span class="token operator">+</span> lockA<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String lockA <span class="token operator">=</span> <span class="token string">"lockA"</span><span class="token punctuation">;</span>        String lockB <span class="token operator">=</span> <span class="token string">"lockB"</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HoldLockThread</span><span class="token punctuation">(</span>lockA<span class="token punctuation">,</span> lockB<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HoldLockThread</span><span class="token punctuation">(</span>lockB<span class="token punctuation">,</span> lockA<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何排查死锁"><a href="#如何排查死锁" class="headerlink" title="如何排查死锁"></a>如何排查死锁</h3><h4 id="jps命令定位进程号"><a href="#jps命令定位进程号" class="headerlink" title="jps命令定位进程号"></a>jps命令定位进程号</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci6pdzjljj30jo05wtbm.jpg" alt></p><h4 id="jstack找到死锁查看"><a href="#jstack找到死锁查看" class="headerlink" title="jstack找到死锁查看"></a>jstack找到死锁查看</h4><p> <strong>jstack 23576</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci6qzpnwcj30ug0eetjr.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock源码-AQS</title>
      <link href="/2020/02/23/AQS/"/>
      <url>/2020/02/23/AQS/</url>
      
        <content type="html"><![CDATA[<h2 id="ReentrantLock源码解析"><a href="#ReentrantLock源码解析" class="headerlink" title="ReentrantLock源码解析"></a>ReentrantLock源码解析</h2><h3 id="AQS（AbstractQueuedSynchronizer）"><a href="#AQS（AbstractQueuedSynchronizer）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）"></a>AQS（AbstractQueuedSynchronizer）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队首</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队尾</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//锁状态，加锁成功则为1，重入+1，解锁为0</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Thread exclusiveOwnerThread<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//持有锁的线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Node类的设计"><a href="#Node类的设计" class="headerlink" title="Node类的设计"></a>Node类的设计</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>  <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>  <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="AQS队列示意图"><a href="#AQS队列示意图" class="headerlink" title="AQS队列示意图"></a>AQS队列示意图</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcp98gjlqoj30vk0iu42b.jpg" alt></p><h3 id="ReentrantLock简单应用"><a href="#ReentrantLock简单应用" class="headerlink" title="ReentrantLock简单应用"></a>ReentrantLock简单应用</h3><pre class="line-numbers language-java"><code class="language-java">ReentrantLock reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//源码如下（有两种实现类）</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略代码逻辑……</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="公平锁｜非公平锁"><a href="#公平锁｜非公平锁" class="headerlink" title="公平锁｜非公平锁"></a>公平锁｜非公平锁</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加锁成功之后改变的值</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>公平锁的上锁必须判断自己需不需要排队；而非公平锁是直接进行CAS修改计数器看能不能加锁成功；如果加锁不成功则乖乖排队(调用acquire)；所以不管公平还是不公平；只要进到了AQS队列当中那么就会排队。</p></blockquote><h2 id="acquire-方法源码分析"><a href="#acquire-方法源码分析" class="headerlink" title="acquire()方法源码分析"></a>acquire()方法源码分析</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">//①</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//②③</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//①tryAcquire()：尝试加锁，如果加锁失败就会调用acquireQueued()去排队，加锁成功就不会。</span><span class="token comment" spellcheck="true">//②addWaiter()：判断队列是否需要初始化，并把当前线程节点放入阻塞队列。</span><span class="token comment" spellcheck="true">//③acquireQueued()：当前线程如果排在第一位会请求获取锁，否则入队睡眠阻塞，后续线程修改睡眠状态，等待被唤醒。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="①tryAcquire"><a href="#①tryAcquire" class="headerlink" title="①tryAcquire()"></a>①tryAcquire()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前线程</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取lock对象的状态c=0自由态，如果被上锁则为1，大于1是重入</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token comment" spellcheck="true">//这里涉及到的情况比较多，下面详细讨论</span>            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置持有锁的线程是自己</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//如果C不等于0，判断当前线程是否为拥有锁的线程，如果不是则直接返回false，加锁失败。</span>    <span class="token comment" spellcheck="true">//如果是拥有锁的线程，则状态+1代表重入次数+1，返回true加锁成功。</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>    Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node s<span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">//这句代码涉及到的情况比较多，下面详细解释</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>第一种情况：队列没有初始化，head和taill都为null，所以h!=t不成立，后面短路不执行，直接返回false。<br>而又因为前面取反：if (!hasQueuedPredecessors()…)，所以不需要排队，直接去CAS，改变计数器上锁。</p></blockquote><blockquote><p>第二种情况：队列已经初始化了，但是有且只有一个数据，即h==t且s==null，表达式后面不执行，同上返回false不排队。什么时候会出现这种情况：当排队的队尾拿到锁的时候，此时队列中有且只有一个节点，它会把自己设置为h。因为这个线程已经拿到锁了，它不参与排队，所以需要设置为头节点。</p></blockquote><blockquote><p>第三种情况：队列已经初始化了，有大于1的多个节点，h!=t成立，s=null不成立，所以还要运行 s.thread != Thread.currentThread()，这里又分为两种情况：</p><ol><li><p>s.thread != Thread.currentThread()为true，即排队的第一个线程不是当前线程，表达式整体返回true，需要排队。</p></li><li><p>s.thread != Thread.currentThread()为false，即排队的第一个线程就是当前线程，表达式整体返回false，不需要排队。</p><p>不需要排队则调用 compareAndSetState(0, acquires) 去改变计数器尝试上锁，这里还分为两种情况：</p><ol><li>第一种情况是加锁成功，即持有锁的线程释放了锁，继续执行setExclusiveOwnerThread(current)，返回true。</li><li>第二种情况是加锁失败，即持有锁的线程还没有释放锁，直接返回false。</li></ol></li></ol></blockquote><h3 id="②addWaiter"><a href="#②addWaiter" class="headerlink" title="②addWaiter()"></a>②addWaiter()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//因为AQS队列中的元素为Node，所以把当前线程封装为一个Node对象</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把队尾赋值给临时节点pred</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//队列不为空的流程很简单，直接修改指针把节点放入队列</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前线程节点指向原来的队尾节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//赋值操作，即队尾⇨当前节点</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//原来队尾节点的指针指向当前节点</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列为空，初始化队列并进行入队操作</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="enq"><a href="#enq" class="headerlink" title="enq()"></a>enq()</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//死循环    </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队尾赋值给临时节点t</span>        <span class="token comment" spellcheck="true">//第一次循环（初始化队列）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//队列为空，需要初始化队列</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//实例化一个属性都为空的Node对象</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//队列中只有一个对象，头尾都指向它</span>        <span class="token comment" spellcheck="true">//第二次循环（当前线程节点入队）</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//⑴</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//⑵</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//⑶</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面123代表的是维护链表，即当前线程节点的入队操作</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="③acquireQueued"><a href="#③acquireQueued" class="headerlink" title="③acquireQueued()"></a>③acquireQueued()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把当前节点的上一个节点赋值给P</span>            <span class="token comment" spellcheck="true">//如果当前节点的前置节点是头节点，那么它会尝试去获取锁--自旋（第一个排队的）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//意图是尽量不睡眠，多询问一次</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//自旋获取锁失败后是否需要睡眠</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token comment" spellcheck="true">//给上一个节点修改状态</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//②当前线程调用park()阻塞</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取前置线程节点的状态</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断前置线程的状态是否为-1（已睡）</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳出方法后运行parkAndCheckInterrupt()当前线程睡眠</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//把前置节点的状态修改为-1，证明前置线程已睡</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳出方法后短路，再次自旋</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="synchronized和lock的区别"><a href="#synchronized和lock的区别" class="headerlink" title="synchronized和lock的区别"></a>synchronized和lock的区别</h3><ol><li><p>原始构成</p><p><code>synchronized</code>是关键字，属于<strong>JVM层面</strong>。底层是通过<code>monitor</code>对象来完成，<code>wait/notify</code>方法也依赖<code>moniter</code>对象并且只有在同步块或者同步方法中才能使用<code>wait/notity</code>等方法。monitorenter｜<strong>monitorexit｜monitorexit 正常退出和异常退出</strong>，不会死锁。</p><p><strong>lock</strong>是具体的类<code>java.util.concurrent.locks.lock</code>属于<strong>API层面</strong>。</p></li><li><p>使用方法</p><p><code>synchronized</code><strong>不需要</strong>用户去手动释放锁，当synchronized代码执行完后系统会自动让线程释放对锁的占用。</p><p><code>ReentrantLock</code><strong>需要</strong>用户去手动释放锁，如果没有主动释放锁就有可能导致死锁。需要<code>lock()</code>和<code>unlock()</code>配合<code>try/finally</code>来完成。</p></li><li><p>等待是否可中断</p><p><code>synchronized</code>不可中断，除非抛出异常或者正常运行完成。</p><p><code>ReentrantLock</code>可中断，相比synchronized更加灵活，有两种方式可以中断：</p><ul><li><p>设置超时方法<code>tryLock(long timeout,TimeUnit unit)</code></p></li><li><p><code>lockInterRuptibly()</code>放代码块中，调用<code>interrupt()</code>方法可中断。</p></li></ul></li><li><p>加锁是否公平</p><p><code>synchronized</code>是非公平锁。</p><p><code>ReentrantLock</code>两者都可以，默认非公平锁。构造方法可以传入boolean值，<strong>true</strong>为公平锁，<strong>false</strong>为非公平锁。</p></li><li><p>是否可绑定多个条件-<code>Condition</code></p><p><code>synchronized</code>不可以，要么随机唤醒一个线程，要么全部唤醒。</p><p><code>ReentrantLock</code>可以实现分组唤醒，达到精确唤醒。</p></li></ol><p>扩展：jdk1.6以前，如果线程是交替执行的话，Synchronized会调用OS函数，影响性能。ReentrantLock的交替执行是在jdk级别解决的，性能很快。如果是竞争执行的话会进入队列调用park()方法。1.8以后区别很小，ReentrantLock的API更丰富一些。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Lock </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自旋锁-SpinLock</title>
      <link href="/2020/02/21/SpinLock/"/>
      <url>/2020/02/21/SpinLock/</url>
      
        <content type="html"><![CDATA[<h2 id="自旋锁-SpinLock"><a href="#自旋锁-SpinLock" class="headerlink" title="自旋锁-SpinLock"></a>自旋锁-SpinLock</h2><p>指的是尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁。</p><h3 id="自旋实现同步"><a href="#自旋实现同步" class="headerlink" title="自旋实现同步"></a>自旋实现同步</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//标识，锁是否被线程占用</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> except<span class="token punctuation">,</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//CAS操作，修改status成功则返回true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作。</p><p>解决思路：让得不到锁的线程让出CPU。</p></blockquote><h3 id="yield-自旋"><a href="#yield-自旋" class="headerlink" title="yield()+自旋"></a>yield()+自旋</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自己实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>yield()方法能让出cpu资源，当线程竞争锁失败时，会调用yield方法让出cpu。不过自旋+yield的方式并没有完全解决问题，当系统只有两个线程竞争锁时，yield是有效的。</p><p>缺点：该方法只是当前让出cpu，有可能操作系统下次还是选择运行该线程，如果线程过多的话还是看不到很好的效果。</p></blockquote><h3 id="sleep-自旋"><a href="#sleep-自旋" class="headerlink" title="sleep()+自旋"></a>sleep()+自旋</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>缺点：睡多久是个问题，睡的短了还是会循环，睡的久了浪费时间。</p></blockquote><h3 id="park-自旋"><a href="#park-自旋" class="headerlink" title="park()+自旋"></a>park()+自旋</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//占用锁20s</span>  <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//将当前线程加入到等待队列</span>  parkQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将当前线程释放CPU</span>  <span class="token function">releaseCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  status <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">lock_notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">lock_notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//得到要唤醒的线程（队列的头部）</span>  Thread t <span class="token operator">=</span> parkQueue<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//唤醒等待线程</span>  <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//unpark()是UnSafe类的方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>park()+自旋的方式比较完美，ReentrantLock类的原理就是利用了这种机制。</p></blockquote><h3 id="自旋锁Demo"><a href="#自旋锁Demo" class="headerlink" title="自旋锁Demo"></a>自旋锁Demo</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicReference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpinLockDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 原子引用线程</span>    AtomicReference<span class="token operator">&lt;</span>Thread<span class="token operator">></span> atomicReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t invoked myLock()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 自旋（有线程先获取锁时循环等待）</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> thread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 释放锁</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        atomicReference<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t invoked myUnLock()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 线程操纵类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpinLockDemo spinLockDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpinLockDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建t1线程获取锁，持有5秒后释放锁</span>          <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//延迟1秒，保证t1线程先启动</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后创建t2线程，尝试获取锁</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            spinLockDemo<span class="token punctuation">.</span><span class="token function">myUnLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h3><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p><p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Lock </tag>
            
            <tag> SpinLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池-ThreadPool</title>
      <link href="/2020/02/19/Thread-Pool/"/>
      <url>/2020/02/19/Thread-Pool/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们常见的创建线程的方式有两种：继承Thread类和实现Runnable接口，后者用的多一些。</p><p>在这里我们详细介绍另外2两种通过调用API创建线程的方式。</p><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式： 实现 Callable 接口。</p><p>Callable 接口类似于 Runnable，但是 Runnable 不会返回结果，并且无法抛出经过检查的异常，而 Callable 依赖 FutureTask 类获取返回结果。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>FutureTask<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t come in Callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 逻辑代码</span>        <span class="token keyword">return</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> futureTask2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// t1，t2线程公用一个futureTask不可行，需要再创建</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//new Thread(futureTask,"t2").start();</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask2<span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// futureTask.get()获得Callable线程的计算结果，尽量放在后面，会阻塞线程的运行</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当某个请求需要在后端完成 N 次统计结果时，我们就可以使用该方式创建 N 个线程进行（并行）统计，而不需要同步等待其他统计操作完成后才统计另一个结果。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是通过Executor框架实现的，该框架用到了Executor、Executors、ExecutorService、<strong>ThreadPoolExecutor</strong>这几个类。</p><p>线程池的特点：线程复用、控制最大并发数、管理线程。</p><h3 id="线程池的架构"><a href="#线程池的架构" class="headerlink" title="线程池的架构"></a>线程池的架构</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gchx17f5qsj30pu0kktjt.jpg" alt></p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="三个简单线程池"><a href="#三个简单线程池" class="headerlink" title="三个简单线程池"></a>三个简单线程池</h3><ul><li>newFixedThreadPool：执行长期的任务，性能好很多。</li><li>newSingleThreadExecutor：一个任务一个任务的执行。</li><li>newCachedThreadPool：执行很多短期异步的小程序或者负载较轻的服务器。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Executors<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 一池5个工作线程（固定）</span><span class="token comment" spellcheck="true">//        ExecutorService executorService = Executors.newSingleThreadExecutor();// 一池1个工作线程</span><span class="token comment" spellcheck="true">//        ExecutorService executorService = Executors.newCachedThreadPool();//一池N个工作线程</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 办理业务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造方法一览"><a href="#构造方法一览" class="headerlink" title="构造方法一览"></a>构造方法一览</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span><span class="token comment" spellcheck="true">//corePoolSize和maximumPoolSize是相等的，使用的是LinkedBlockingQueue</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定的顺序执行。</span><span class="token comment" spellcheck="true">//corePoolSize和maximumPoolSize都是1，使用的是LinkedBlockingQueue</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个可缓存的线程池，如果线程池的长度超过处理需要，可灵活回收空闲线程，若无可收回则新建线程执行。</span><span class="token comment" spellcheck="true">//corePoolSize是0，maximumPoolSize为Integer.MAX_VALUE，使用的是SynchronousQueue</span><span class="token comment" spellcheck="true">//有任务就创建线程运行，当线程空闲超过60秒就销毁线程。</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                      60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程池的七大参数"><a href="#线程池的七大参数" class="headerlink" title="线程池的七大参数"></a>线程池的七大参数</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span>   <span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>   <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                                    <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>   TimeUnit unit<span class="token punctuation">,</span>   BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>   ThreadFactory threadFactory<span class="token punctuation">,</span>   RejectedExecutionHandler handler<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gci3qd3bcpj315s0u0kjl.jpg" style="zoom: 33%;"><ol><li><p><code>corePoolSize</code>（<strong>线程池的常驻大小</strong>）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p><code>maximumPoolSize</code>（<strong>线程池最大数量</strong>）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p><code>keepAliveTime</code>（<strong>多余空闲线程存活时间</strong>）：线程池的工作线程空闲后，保持存活的时间。线程空闲时间超过设置的存活时间后，线程池会判断当前运行的线程数是否大于corePoolSize，如果大于就会销毁多余的空闲线程，直到只剩下corePoolSize个线程为止。如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li><li><p><code>TimeUnit</code>（<strong>keepAliveTime的单位</strong>）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p></li><li><p><code>BlockingQueue</code>（<strong>阻塞队列</strong>）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p></li><li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p></li><li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p></li></ul></li><li><p><code>ThreadFactory</code>（<strong>线程工厂</strong>）：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。一般用默认，也可以使用开源框架guava提供的ThreadFactoryBuilder快速给线程池里的线程设置有意义的名字，代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"XX-task-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>RejectedExecutionHandler</code>（<strong>饱和策略</strong>）：当阻塞队列和最大线程数都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p><ul><li>AbortPolicy：直接抛出RejectedExecutionException异常。(默认，执行任务最少，最不友好)</li><li>CallerRunsPolicy：将任务分给调用线程来执行（如main线程，执行任务数最多）。</li><li>DiscardOldestPolicy：丢弃队列里等待最久的任务，并执行当前任务（相比DiscardPolicy丢弃的少）。</li><li>DiscardPolicy：丢弃当前任务，不处理（丢掉的任务最多）。</li></ul></li></ol><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 注意阻塞队列的范围和拒绝策略的选择 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadPoolDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService threadPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 1L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 办理业务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-4     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-5     办理业务</span><span class="token comment" spellcheck="true">//main     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-4     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-2     办理业务</span><span class="token comment" spellcheck="true">//main     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-3     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-5     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-1     办理业务</span><span class="token comment" spellcheck="true">//pool-1-thread-4     办理业务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合理配置线程数"><a href="#合理配置线程数" class="headerlink" title="合理配置线程数"></a>合理配置线程数</h3><ol><li><p>CPU密集型</p><p>意思是该任务需要大量的运算，没有阻塞，CPU一直全速运行。一般公式：CPU核数+1个线程的线程池。</p><p>运行System.out.println(Runtime.getRuntime().availableProcessors());查看CPU核数（线程数）。</p></li><li><p>IO密集型（有两种，自己到测试/生产环境试验）</p><ul><li><p>意思是该任务并不是一直在执行，可以配置尽可能多的线程，比如CPU核数*2。</p></li><li><p>IO密集时，大量的线程都在阻塞，参考公式：CPU/(1-阻塞系数)=8/(1-0.9)=80个线程。</p></li></ul></li></ol><hr><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为<code>execute()</code>和<code>submit()</code>方法。</p><ul><li><code>execute()</code>方法用于提交<strong>不需要返回值</strong>的任务;</li><li><code>submit()</code>方法用于提交<strong>需要返回值</strong>的任务。</li></ul><p><code>execute()</code>：用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过源码可知<code>execute()</code>方法输入的任务是一个Runnable类的实例。</p><pre class="line-numbers language-java"><code class="language-java">threadsPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>submit()</code>：线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用<code>get(long timeout,TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><pre class="line-numbers language-java"><code class="language-java">Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>haveReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    Object s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理中断异常</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 处理无法执行任务异常</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关闭线程池</span>    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul><li><code>shutdown()</code></li><li><code>shutdownNow()</code></li></ul><p>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt()</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，<code>isShutdown()</code>方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用<code>isTerminaed()</code>方法会返回true。</p><p>区别：</p><p><code>shutdownNow()</code>首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而<code>shutdown()</code>只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>总结：</p><p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调<code>shutdown()</code>方法来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow()</code>方法。</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ol><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<a id="more"></a></li></ol><p>对应到代码层面就是<code>ThreadPoolExecutor</code>执行<code>execute()</code>方法</p><ol><li>当<kbd>workerCount</kbd> &lt; <kbd>corePoolSize</kbd>，创建新线程执行任务。</li><li>当<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> &lt; <kbd>maximumPoolSize</kbd>，创建新线程执行任务。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。</li></ol><p>由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p><h3 id="线程池状态转换模型"><a href="#线程池状态转换模型" class="headerlink" title="线程池状态转换模型"></a>线程池状态转换模型</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg" alt></p><ul><li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li><li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li><li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li><li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li><li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li></ul><h2 id="线程池源码分析"><a href="#线程池源码分析" class="headerlink" title="线程池源码分析"></a>线程池源码分析</h2><p><strong>基于JDK1.8</strong></p><h3 id="ctl-变量"><a href="#ctl-变量" class="headerlink" title="ctl 变量"></a>ctl 变量</h3><p>后面<code>execute()</code>方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Packing and unpacking ctl</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><ul><li><code>if (! isRunning(recheck) &amp;&amp; remove(command))</code>这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。</li><li><code>addWorker(command, false)</code>：我们看到有<code>addWorker(command, true)</code>和<code>addWorker(command, false)</code>。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用<code>addWorker(command, true)</code>。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//如果提交了空的任务 抛出异常</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前线程池的状态</span>   <span class="token comment" spellcheck="true">//检查当前工作线程数量是否小于核心线程数量</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//通过addWorker方法提交任务</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token keyword">return</span><span class="token punctuation">;</span>   c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果提交失败 需要二次检查状态</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//向工作线程提交任务 </span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 再次检查状态</span>      <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//扩容失败 则拒绝任务</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker()方法"></a>addWorker()方法</h3><p>这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。</p><p>这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>       retry<span class="token operator">:</span>   <span class="token comment" spellcheck="true">//死循环更新状态</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取运行状态</span>       <span class="token comment" spellcheck="true">//检查线程池是否处于关闭状态</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>                  firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                  <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//获取当前工作线程数量</span>               <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果已经超过corePoolSize获取maximumPoolSize 返回false</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                   wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//CAS增加一个工作线程</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//再次获取状态</span>               c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>       <span class="token comment" spellcheck="true">//如果状态更新失败 则循环更新</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                   <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>           w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化一个工作线程</span>           <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获得锁</span>               <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>               mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                   <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                   <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                   <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                       <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//添加工作这到hashset中保存</span>                       workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                           largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                       workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                   mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//工作线程启动 执行第一个任务 就是新提交的任务</span>                   t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>               <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Worker的构造方法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */</span><span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker()方法"></a>runWorker()方法</h3><p>在<code>addWorker()</code>方法快要结束的地方，调用了<code>t.start()</code>方法，我们知道它实际执行的就是Worker对象的<code>run()</code>方法，而worker的<code>run()</code>方法是这样定义的：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>它实际上是将自己委托给线程池的runWorker方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//不断地从blockingQueue获取任务</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>               w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// If pool is stopping, ensure thread is interrupted;</span>               <span class="token comment" spellcheck="true">// if not, ensure thread is not interrupted.  This</span>               <span class="token comment" spellcheck="true">// requires a recheck in second case to deal with</span>               <span class="token comment" spellcheck="true">// shutdownNow race while clearing interrupt</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                     <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                   <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//执行beforeExecute方法</span>                   <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                   Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                   <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//调用Runable的run方法</span>                       task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                       thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 执行aferExecute方法</span>                       <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                   task <span class="token operator">=</span> null<span class="token punctuation">;</span>                   w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                   w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>           <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下<code>runWorker(Worker w)</code>方法的执行过程：</p><ol><li>while循环中，不断地通过<code>getTask()</code>方法从workerQueue中获取任务</li><li>如果线程池正在停止，则中断线程。否则调用3.</li><li>调用<code>task.run()</code>执行任务；</li><li>如果task为null则跳出循环，执行<code>processWorkerExit()</code>方法，销毁线程<code>workers.remove(w)</code>;</li></ol><p>它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。</p><h2 id="ExecutorService详解"><a href="#ExecutorService详解" class="headerlink" title="ExecutorService详解"></a>ExecutorService详解</h2><p><strong>创建线程池的5个方法：</strong></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>只有一个线程的线程池，因此所有提交的任务是<strong>顺序执行</strong>。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</p><p>返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><hr><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最少数量</span>                Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>                60L<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间，60秒</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">",执行第 "</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：3，执行第 1 次线程ID：4，执行第 1 次线程ID：2，执行第 1 次线程ID：5，执行第 1 次线程ID：1，执行第 1 次线程ID：2，执行第 2 次线程ID：3，执行第 2 次线程ID：4，执行第 2 次线程ID：1，执行第 2 次线程ID：5，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 3 次线程ID：4，执行第 3 次线程ID：5，执行第 3 次线程ID：1，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到执行结果是5个任务在交替进行的</p><p>newCachedThreadPool的总结：</p><ol><li>重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。</li><li>使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。</li><li>超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。</li><li>结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</li></ol><hr><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService fixedThreadPool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码：有两个重载方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                nThreads<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最少数量</span>                nThreads<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>                0L<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间</span>                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                      0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                      <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                      threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService exe <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID <span class="token operator">=</span> i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span> <span class="token operator">+</span> taskID <span class="token operator">+</span> <span class="token string">"，执行第 "</span> <span class="token operator">+</span> j <span class="token operator">+</span> <span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：2，执行第 1 次线程ID：1，执行第 1 次线程ID：3，执行第 1 次线程ID：2，执行第 2 次线程ID：3，执行第 2 次线程ID：1，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 3 次线程ID：1，执行第 3 次线程ID：4，执行第 1 次线程ID：5，执行第 1 次线程ID：4，执行第 2 次线程ID：5，执行第 2 次线程ID：4，执行第 3 次线程ID：5，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。<br>newFixedThreadPool的总结：</p><ol><li>重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。</li><li>固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li><li>超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。</li><li>使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。</li></ol><hr><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p><pre class="line-numbers language-java"><code class="language-java">ScheduledExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程池维护线程的最少数量</span>        Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池维护线程的最大数量</span>        <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 线程池维护线程所允许的空闲时间</span>        NANOSECONDS<span class="token punctuation">,</span><span class="token comment" spellcheck="true">//线程池维护线程所允许的空闲时间的单位</span>        <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ScheduledExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>                exe<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">",时间："</span><span class="token operator">+</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 执行一次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：</p><pre class="line-numbers language-xml"><code class="language-xml">线程：1,时间：2016-12-11T13:09:18.544 执行一次线程：2,时间：2016-12-11T13:09:18.544 执行一次线程：3,时间：2016-12-11T13:09:18.544 执行一次线程：5,时间：2016-12-11T13:09:20.557 执行一次线程：1,时间：2016-12-11T13:09:20.557 执行一次线程：4,时间：2016-12-11T13:09:20.557 执行一次线程：4,时间：2016-12-11T13:09:22.572 执行一次线程：2,时间：2016-12-11T13:09:22.572 执行一次线程：3,时间：2016-12-11T13:09:22.572 执行一次线程：5,时间：2016-12-11T13:09:24.586 执行一次线程：1,时间：2016-12-11T13:09:24.586 执行一次线程：2,时间：2016-12-11T13:09:24.586 执行一次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。</p><hr><h3 id="newSingleThreadScheduledPool"><a href="#newSingleThreadScheduledPool" class="headerlink" title="newSingleThreadScheduledPool"></a>newSingleThreadScheduledPool</h3><p>单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造方法源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                    0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ExecutorService exe<span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> taskID<span class="token operator">=</span>i<span class="token punctuation">;</span>            exe<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程ID："</span><span class="token operator">+</span>taskID<span class="token operator">+</span><span class="token string">"，执行第 "</span><span class="token operator">+</span>j<span class="token operator">+</span><span class="token string">" 次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果</p><pre class="line-numbers language-xml"><code class="language-xml">线程ID：1，执行第 1 次线程ID：1，执行第 2 次线程ID：1，执行第 3 次线程ID：2，执行第 1 次线程ID：2，执行第 2 次线程ID：2，执行第 3 次线程ID：3，执行第 1 次线程ID：3，执行第 2 次线程ID：3，执行第 3 次线程ID：4，执行第 1 次线程ID：4，执行第 2 次线程ID：4，执行第 3 次线程ID：5，执行第 1 次线程ID：5，执行第 2 次线程ID：5，执行第 3 次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个结果都是相隔0.5秒打印出来的，顺序执行下去。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列-BlockingQueue</title>
      <link href="/2020/02/16/BlockingQueue/"/>
      <url>/2020/02/16/BlockingQueue/</url>
      
        <content type="html"><![CDATA[<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列：顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用如下</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcfem6tcdyj30gf06gq4x.jpg" alt></p><ul><li>当阻塞队列是空时，试图从队列中获取元素的操作将被阻塞。</li><li>当阻塞队列是满时，试图往队列里添加元素的操作将被阻塞。</li></ul><p>在多线程领域，所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒。<a id="more"></a></p><h3 id="为什么需要阻塞队列"><a href="#为什么需要阻塞队列" class="headerlink" title="为什么需要阻塞队列"></a>为什么需要阻塞队列</h3><p>在concurrent包发布以前，多线程环境下我们需要去控制线程的细节，尤其还要兼顾效率和线程安全。阻塞队列的好处是我们不需要关心线程何时阻塞，何时唤醒，因为这一切都被<code>BlockingQueue</code>一手包办了。</p><h3 id="阻塞队列的架构体系"><a href="#阻塞队列的架构体系" class="headerlink" title="阻塞队列的架构体系"></a>阻塞队列的架构体系</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcgqyg9zwhj30fi0gw0vm.jpg" alt></p><h3 id="阻塞队列的种类分析"><a href="#阻塞队列的种类分析" class="headerlink" title="阻塞队列的种类分析"></a>阻塞队列的种类分析</h3><p><code>ArrayBlockingQueue</code>：由数组结构组成的有界阻塞队列。</p><p><code>LinkedBlockingQueue</code>：由链表结构组成的有界（但大小默认值为Integer.MAX_VALUE）阻塞队列。</p><p>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</p><p>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</p><p><code>SynchronousQueue</code>：<strong>一个不存储元素的阻塞队列，即队列中只有一个元素，出队后才能再进。</strong></p><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列。</p><p>LinkedBlocking<strong>Deque</strong>：由链表结构组成的双向阻塞队列。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronousQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t put 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t put 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t put 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t take 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t take 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t take 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//t1     put 1</span><span class="token comment" spellcheck="true">//t2     take 1</span><span class="token comment" spellcheck="true">//t1     put 2</span><span class="token comment" spellcheck="true">//t2     take 2</span><span class="token comment" spellcheck="true">//t1     put 3</span><span class="token comment" spellcheck="true">//t2     take 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞队列的核心方法"><a href="#阻塞队列的核心方法" class="headerlink" title="阻塞队列的核心方法"></a>阻塞队列的核心方法</h3><table><thead><tr><th align="center">方法类型</th><th align="center">抛出异常</th><th align="center">特殊值</th><th align="center">阻塞</th><th align="center">超时</th></tr></thead><tbody><tr><td align="center">插入</td><td align="center">add(e)</td><td align="center">offer(e)</td><td align="center">put(e)</td><td align="center">offer(e, time,unit)</td></tr><tr><td align="center">移除</td><td align="center">remove()</td><td align="center">poll()</td><td align="center">take()</td><td align="center">poll(time,unit)</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td><td align="center">不可用</td><td align="center">不可用</td></tr></tbody></table><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><ul><li><p>使用add(e)进入队列，当阻塞队列满时会抛出：java.lang.IllegalStateException: Queue full</p></li><li><p>使用remove()移出队列，当阻塞队列空时会抛出：java.util.NoSuchElementException</p></li><li><p>使用element()检查队列，有值时返回首元素，队列为空时会抛出：java.util.NoSuchElementException</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//Exception in thread "main" java.lang.IllegalStateException: Queue full</span><span class="token comment" spellcheck="true">//    at java.util.AbstractQueue.add(AbstractQueue.java:98)</span><span class="token comment" spellcheck="true">//    at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)</span><span class="token comment" spellcheck="true">//    at BlockingQueueDemo.main(BlockingQueueDemo.java:10)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h4><ul><li><p>使用offer(e)插入方法，成功返回true，<strong>失败返回false，不抛出异常</strong>。</p></li><li><p>使用poll()移除方法，成功返回出队列的元素，队列里面没有就返回null。</p></li><li><p>使用peek()检查队列，有值时返回首元素，队列为空时返回null。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//a</span><span class="token comment" spellcheck="true">//b</span><span class="token comment" spellcheck="true">//c</span><span class="token comment" spellcheck="true">//null</span><span class="token comment" spellcheck="true">//null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li><p>使用put(e)方法进入队列，队列满时阻塞，没有返回值。</p></li><li><p>使用take()方法移出队列，队列空时阻塞，没有返回值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//blockingQueue.put("d");</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        blockingQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//blockingQueue.take();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><ul><li><p>使用offer(e,time,unit)方法进入队列，可以设置阻塞超时时间。</p></li><li><p>使用poll(time,unit)方法移出队列，可以设置阻塞等待时间。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BlockingQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>5L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//true</span><span class="token comment" spellcheck="true">//false</span><span class="token comment" spellcheck="true">//a</span><span class="token comment" spellcheck="true">//b</span><span class="token comment" spellcheck="true">//c</span><span class="token comment" spellcheck="true">//null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="阻塞队列的用途"><a href="#阻塞队列的用途" class="headerlink" title="阻塞队列的用途"></a>阻塞队列的用途</h3><p><strong>使用BlockingQueue建造生产者消费者模型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MySource</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 资源类</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> FLAG <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认开启，进行生产+消费操作</span>    <span class="token keyword">private</span> AtomicInteger atomicInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认0</span>    BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设计时范围尽量大</span>    <span class="token comment" spellcheck="true">//构造方法允许7中阻塞队列的传入</span>    <span class="token keyword">public</span> <span class="token function">MySource</span><span class="token punctuation">(</span>BlockingQueue<span class="token operator">&lt;</span>String<span class="token operator">></span> blockingQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>blockingQueue <span class="token operator">=</span> blockingQueue<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 定位问题（查看具体实现队列）</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>blockingQueue<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 生产者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myProd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String data <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> retValue<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>FLAG<span class="token punctuation">)</span> <span class="token punctuation">{</span>            data <span class="token operator">=</span> atomicInteger<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            retValue <span class="token operator">=</span> blockingQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> 2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 插入队列"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 插入队列"</span> <span class="token operator">+</span> data <span class="token operator">+</span> <span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 需求叫停，表示FLAG=false，生产结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 消费者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">myCons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>FLAG<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> blockingQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> result <span class="token operator">||</span> result<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                FLAG <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 超过2秒钟没有取到数据，消费结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 消费队列"</span> <span class="token operator">+</span> result <span class="token operator">+</span> <span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 停止方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>FLAG <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProdCons_BlockQueueDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化阻塞队列，传入ArrayBlockingQueue</span>        MySource mySource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MySource</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 生产线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用生产者插入数据到队列</span>                mySource<span class="token punctuation">.</span><span class="token function">myProd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Prod"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 消费线程启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用消费者消费队列中的数据</span>                mySource<span class="token punctuation">.</span><span class="token function">myCons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Cons"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 生产消费5秒后结束</span>        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mySource<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//java.util.concurrent.ArrayBlockingQueue</span><span class="token comment" spellcheck="true">//Prod     生产线程启动</span><span class="token comment" spellcheck="true">//Cons     消费线程启动</span><span class="token comment" spellcheck="true">//Prod     插入队列1成功</span><span class="token comment" spellcheck="true">//Cons     消费队列1成功</span><span class="token comment" spellcheck="true">//Prod     插入队列2成功</span><span class="token comment" spellcheck="true">//Cons     消费队列2成功</span><span class="token comment" spellcheck="true">//Prod     插入队列3成功</span><span class="token comment" spellcheck="true">//Cons     消费队列3成功</span><span class="token comment" spellcheck="true">//Prod     插入队列4成功</span><span class="token comment" spellcheck="true">//Cons     消费队列4成功</span><span class="token comment" spellcheck="true">//Prod     插入队列5成功</span><span class="token comment" spellcheck="true">//Cons     消费队列5成功</span><span class="token comment" spellcheck="true">//Prod     需求叫停，表示FLAG=false，生产结束</span><span class="token comment" spellcheck="true">//Cons     超过2秒钟没有取到数据，消费结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程控制级别</strong></p><p>1.0    synchronized、wait、notify</p><p>2.0    lock、await、singal</p><p>3.0    BlockingQueue</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发包-JUC</title>
      <link href="/2020/02/12/JUC/"/>
      <url>/2020/02/12/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><strong>倒计时/发令枪</strong>，让一些线程阻塞，直到另一些线程完成一系列操作后才被唤醒。</p><p><code>CountDownLatch</code>主要有两个方法，当一个或多个线程调用<code>await()</code>方法时，调用线程会被阻塞。其他线程调用<code>countDown()</code>方法会将计数器减1（调用countDown的线程不会阻塞），当计数器的值变为0时，因调用<code>await()</code>方法被阻塞的线程会被唤醒，继续执行。</p><p>官方解释：<code>CountDownLatch</code>用给定的计数初始化。 <code>await()</code>方法阻塞，直到由于<code>countDown()</code>方法的调用而导致当前计数达到零，之后所有等待线程被释放，并且任何后续的<code>await()</code>调用立即返回。 这是一个一次性的现象 - 计数无法重置。 如果您需要重置计数的版本，请考虑使用<code>CyclicBarrier</code>。<a id="more"></a></p><p><strong>CountDownLatchDemo</strong>：等待所有人上完自习离开，班长最后关门走人</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// CountDownLatch用给定的计数初始化</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 上完自习，离开教室"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// countDown()方法的调用使当前计数达到零</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//},i+" "+CountryEnum.forEach_CountryEnum(i).getRetMessage()).start(); // 枚举实现自定义顺序</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// await方法阻塞，计数到0后所有线程被释放</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" 班长最后关门走人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果如下：</span><span class="token comment" spellcheck="true">//1     上完自习，离开教室</span><span class="token comment" spellcheck="true">//5     上完自习，离开教室</span><span class="token comment" spellcheck="true">//4     上完自习，离开教室</span><span class="token comment" spellcheck="true">//2     上完自习，离开教室</span><span class="token comment" spellcheck="true">//6  上完自习，离开教室</span><span class="token comment" spellcheck="true">//3     上完自习，离开教室</span><span class="token comment" spellcheck="true">//main 班长最后关门走人</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CountryEnum</strong>：枚举自定义顺序举例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Getter<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">enum</span> CountryEnum <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//ONE(1,v1,v2,v3,v4,v5…),通过增加变量可以实现自定义枚举。</span>    <span class="token function">ONE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"齐"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TWO</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"楚"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">THREE</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"燕"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FOUR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"韩"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FIVE</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"赵"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SEX</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">"魏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Getter</span>    <span class="token keyword">private</span> Integer retCode<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Getter</span>    <span class="token keyword">private</span> String retMessage<span class="token punctuation">;</span>    <span class="token function">CountryEnum</span><span class="token punctuation">(</span>Integer retCode<span class="token punctuation">,</span> String retMessage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>retCode <span class="token operator">=</span> retCode<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>retMessage <span class="token operator">=</span> retMessage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CountryEnum <span class="token function">forEach_CountryEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountryEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> myArray <span class="token operator">=</span> CountryEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>CountryEnum element <span class="token operator">:</span> myArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> element<span class="token punctuation">.</span><span class="token function">getRetCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> element<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//1 齐国，被灭</span><span class="token comment" spellcheck="true">//3 燕国，被灭</span><span class="token comment" spellcheck="true">//2 楚国，被灭</span><span class="token comment" spellcheck="true">//5 赵国，被灭</span><span class="token comment" spellcheck="true">//4 韩国，被灭</span><span class="token comment" spellcheck="true">//6 魏国，被灭</span><span class="token comment" spellcheck="true">//main 秦国，统一六国</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>字面意思是<strong>可循环</strong>（Cyclic）使用的<strong>屏障</strong>（Barrier）</p><p>让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会打开，所有被拦截的线程才会继续执行。</p><p><code>CyclicBarrier</code>通过<code>await()</code>方法开启屏障。</p><p>构造方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个新的 CyclicBarrier ，当给定数量的线程（线程）等待时，它将跳闸，并且当屏障跳闸时不执行预定义的动作。</span><span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//创建一个新的 CyclicBarrier ，当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。</span><span class="token function">CyclicBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> parties<span class="token punctuation">,</span> Runnable barrierAction<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CyclicBarrierDemo</strong>：集齐7颗龙珠，召唤神龙</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BrokenBarrierException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CyclicBarrier<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"*******召唤神龙"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> tempInt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\t 收集到"</span> <span class="token operator">+</span> tempInt <span class="token operator">+</span> <span class="token string">"星球"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//创建屏障，等待集齐7颗再执行给定方法</span>                      cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下：</span><span class="token comment" spellcheck="true">//1     收集到1星球</span><span class="token comment" spellcheck="true">//5     收集到5星球</span><span class="token comment" spellcheck="true">//4     收集到4星球</span><span class="token comment" spellcheck="true">//6     收集到6星球</span><span class="token comment" spellcheck="true">//3     收集到3星球</span><span class="token comment" spellcheck="true">//7     收集到7星球</span><span class="token comment" spellcheck="true">//2     收集到2星球</span><span class="token comment" spellcheck="true">//2*******召唤神龙</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>信号量</strong>主要用于两个目的：</p><ol><li>用于多个共享资源的互斥使用。</li><li>用于并发线程的控制。</li></ol><p>构造方法（可以设置公平锁和非公平锁，默认空是false非公平）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个 Semaphore与给定数量的许可证和非公平公平设置。</span><span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//创建一个 Semaphore与给定数量的许可证和给定的公平设置。</span><span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token keyword">int</span> permits<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SemaphoreDemo</strong>：非公平锁类似抢车位，公平锁类似餐厅排队等位</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Semaphore<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//模拟3个车位</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//抢占车位</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 抢到车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 停车3秒后离开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放车位</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果：</span><span class="token comment" spellcheck="true">//1     抢到车位</span><span class="token comment" spellcheck="true">//3     抢到车位</span><span class="token comment" spellcheck="true">//2     抢到车位</span><span class="token comment" spellcheck="true">//1     停车3秒后离开</span><span class="token comment" spellcheck="true">//3     停车3秒后离开</span><span class="token comment" spellcheck="true">//4     抢到车位</span><span class="token comment" spellcheck="true">//2     停车3秒后离开</span><span class="token comment" spellcheck="true">//6     抢到车位</span><span class="token comment" spellcheck="true">//5     抢到车位</span><span class="token comment" spellcheck="true">//4     停车3秒后离开</span><span class="token comment" spellcheck="true">//6     停车3秒后离开</span><span class="token comment" spellcheck="true">//5     停车3秒后离开</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>CountDownLatch</code> : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。  </p><p><code>CyclicBarrier</code> : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p><p>这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待，而另外那N的线程在把“某个事情”做完之后可以继续执行，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</p><ul><li><p>发令枪是一次性的，无法重置，循环屏障可重复使用。<code>reset()</code></p></li><li><p><strong>CountDownLatch</strong>： 现实例子：我在一个地方等着队友开发进度，只有我的队友到达了一个预定进度，然后，我才能开始开发。当所有队友到达了一个预定进度，我开始开发了，队友也不管我，继续他们的开发。</p></li><li><p><strong>CyclicBarrier</strong>：当我使用CyclicBarrier(int count,Thread task) 这个构造方法，现实例子：几个工程队修地铁的基础设施，只有当都完成之后，技术检验人员检验合格了（这个期间工程队就歇着），工程队接着进行下一步的铁轨铺设。</p></li></ul><p><code>Semaphore</code>中有一个”许可”的概念:</p><ul><li>访问特定资源前，先使用<code>acquire(1)</code>获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</li><li>访问资源后，使用<code>release()</code>释放许可。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>便捷开发双刃剑-Lombok</title>
      <link href="/2020/02/11/lombok/"/>
      <url>/2020/02/11/lombok/</url>
      
        <content type="html"><![CDATA[<h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><p>Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而使您的Java更加生动有趣。 永远不要再编写另一个getter或equals方法，带有一个注释的类将具有功能全面的生成器，自动执行日志记录变量等等。</p><h3 id="Lombok安装"><a href="#Lombok安装" class="headerlink" title="Lombok安装"></a>Lombok安装</h3><p>打开 IDEA 的 Preferences，选择 Plugins 选项，选中 MarketPlace 并搜索 lombok，安装后重启 IDEA 生效。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge6dfdn9lqj31ha0s2dse.jpg" alt="安装lombok插件"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.18.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>在pojo实体类上引入相关注解即可。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge6dotehbxj310k0a0di5.jpg" alt style="zoom: 67%;"><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@Data：自动生成全参构造、Getter()、Setter()、equals()、hashCode()、toString()</li><li>@Setter：自动生成Setter()方法</li><li>@Getter：自动生成Getter()方法</li><li>@Log4j：自动生成属性名为 log 的日志对象</li><li>@AllArgsConstructor：自动生成全参数构造函数</li><li>@NoArgsConstructor：自动生成无参数构造函数</li><li>@EqualsAndHashCode：自动生成equals()和hashCode()</li><li>@NonNull：作用在参数上，自动抛出空指针异常</li><li>@Cleanup：自动关闭注解变量所代表的资源</li><li>@ToString：自动生成ToString()方法</li><li>@Value：作用在类上，自动生成全参构造方法，getter()、equals()、hashCode()、toString()</li><li>@SneakyThrows：作用在方法上，可以将方法中的代码用 try-catch 语句包裹起来，使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常</li></ul><h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p>lombok是一把双刃剑，理解不到位的话在开发使用过程中很容易带来许多意想不到的问题。lombok的缺点如下：</p><ol><li><strong>较高的侵入性</strong>：如果项目组中有一个人使用了Lombok，那么其他人就必须也要安装IDE插件。否则就没办法协同开发。更重要的是，如果我们定义的一个jar包中使用了Lombok，那么就要求所有依赖这个jar包的所有应用都必须安装插件。</li><li><strong>可调试性低</strong>：不容易找到某个类中的某个属性的getter方法都被哪些类引用。</li><li><strong>影响升级</strong>：如果我们需要升级到某个新版本的JDK的时候，若其中的特性在Lombok中不支持的话就会受到影响。</li><li><strong>破坏封装性</strong>：一个类中的所有参数都自动提供了Getter()、Setter()方法。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2020/02/10/java8/"/>
      <url>/2020/02/10/java8/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><ol><li><p>无参，无返回值</p><pre class="line-numbers language-java"><code class="language-java">Runnable r2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是Lambda表达式写法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>r2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>一个参数，无返回值</p><pre class="line-numbers language-java"><code class="language-java">Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span> con2 <span class="token operator">=</span> <span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>con2<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"一个是听的人当真了,一个是说的人当真了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数据类型可以省略，因为可由编译器推断得出，这就是<strong>类型推断</strong>(比如<strong>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</strong>)</p><pre class="line-numbers language-java"><code class="language-java">Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span> con2 <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>con2<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"一个是听的人当真了,一个是说的人当真了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Lambda若只需要一个参数时，参数的小括号可省略</p><pre class="line-numbers language-java"><code class="language-java">Consumer<span class="token operator">&lt;</span>String<span class="token operator">></span> con2 <span class="token operator">=</span> s <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>con2<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"一个是听的人当真了,一个是说的人当真了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Lambda若需要两个或两个以上的参数，小括号不能省，多条执行语句，并且可能有返回值的情况</p><pre class="line-numbers language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> comparator2 <span class="token operator">=</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comparator2<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当Lambda体只有一条语句时，大括号和return都可省略</p><pre class="line-numbers language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> comparator2 <span class="token operator">=</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comparator2<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Runnable r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是常规写法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        r1<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"***********************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runnable r2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是Lambda表达式写法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        r2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Comparator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> comparator1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Integer o1<span class="token punctuation">,</span> Integer o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comparator1<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"***********************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Lambda表达式写法</span>        Comparator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> comparator2 <span class="token operator">=</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comparator2<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"***********************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//方法引用</span>        Comparator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> comparator3 <span class="token operator">=</span> Integer<span class="token operator">:</span><span class="token operator">:</span>compare<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>comparator3<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p><strong>只包含一个抽象方法的接口，称为函数式接口</strong>。可以使用Lambda表达式来创建该接口的对象。我们可以在一个接口上使用@FunctionalInterface注解来检查它是否是一个函数式接口。</p><p>简单的说，<strong>Lambda表达式就是一个函数式接口的实例。</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * When an object implementing interface &lt;code>Runnable&lt;/code> is used     * to create a thread, starting the thread causes the object's     * &lt;code>run&lt;/code> method to be called in that separately executing thread.     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。</p><p><strong>方法引用可以看做是Lambda表达式深层次的表达</strong>。换句话说，方法引用<strong>就是Lambda表达式</strong>，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖。</p><blockquote><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致。</p><p>格式：使用操作符 “::” 将类(或对象)与方法名分隔开来。</p><p>如下三种主要使用情况：</p><ul><li><strong>对象 :: 实例方法名</strong>(非静态)</li><li><strong>类 :: 静态方法名</strong></li><li><strong>类 :: 实例方法名</strong></li></ul></blockquote><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Supplier<span class="token operator">&lt;</span>Employee<span class="token operator">></span> supplier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Employee <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"****************************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Supplier<span class="token operator">&lt;</span>Employee<span class="token operator">></span> sup1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Lambda表达式</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"****************************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Supplier<span class="token operator">&lt;</span>Employee<span class="token operator">></span> sup2 <span class="token operator">=</span> Employee <span class="token operator">:</span><span class="token operator">:</span> <span class="token keyword">new</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//构造器引用</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Function<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Employee<span class="token operator">></span> func1 <span class="token operator">=</span> id <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    Employee emp1 <span class="token operator">=</span> func1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>emp1<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"****************************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Function<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Employee<span class="token operator">></span> func2 <span class="token operator">=</span> Employee <span class="token operator">:</span><span class="token operator">:</span> <span class="token keyword">new</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//构造器引用</span>    Employee emp2 <span class="token operator">=</span> func1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>emp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p>如果把数组看做是一个特殊的类，则写法与构造器引用一致。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Function<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> func1 <span class="token operator">=</span> length <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> str1 <span class="token operator">=</span> func1<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"****************************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Function<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> func2 <span class="token operator">=</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">:</span> <span class="token keyword">new</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数组引用</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> str2 <span class="token operator">=</span> func2<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="强大的-Stream-API"><a href="#强大的-Stream-API" class="headerlink" title="强大的 Stream API"></a>强大的 Stream API</h2><ul><li>Java8中有两大最为重要的改变。第一个是Lambda表达式；另外一个则是Stream API。</li><li>Stream API (java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li><li>Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。<strong>使用Stream API对集合数据进行操作，就类似于使用SQL执行的数据库查询。</strong>也可以使用Stream API来并行执行操作。简而言之，StreamAPI提供了一种高效且易于使用的处理数据的方式。</li></ul><h3 id="Stream是什么"><a href="#Stream是什么" class="headerlink" title="Stream是什么"></a>Stream是什么</h3><p>Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。</p><p><strong>“集合讲的是数据，Stream讲的是计算!”</strong></p><blockquote><p>注意</p><ol><li>Stream自己不会存储元素。</li><li>Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol></blockquote><h4 id="为什么要使用Stream-API-？"><a href="#为什么要使用Stream-API-？" class="headerlink" title="为什么要使用Stream API ？"></a>为什么要使用Stream API ？</h4><p>实际开发中，项目中多数数据源都来自于Mysql， Oracle等。 但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。</p><h4 id="Stream和Collection集合的区别？"><a href="#Stream和Collection集合的区别？" class="headerlink" title="Stream和Collection集合的区别？"></a>Stream和Collection集合的区别？</h4><p>Stream关注的是对数据的运算，与CPU打交道；</p><p>Collection集合关注的是数据的存储，与内存打交道。</p><h4 id="Stream操作的三个步骤"><a href="#Stream操作的三个步骤" class="headerlink" title="Stream操作的三个步骤"></a>Stream操作的三个步骤</h4><ol><li><p>创建Stream对象</p><p>一个数据源(如:集合、数组)，获取一个流。</p></li><li><p>一系列中间操作</p><p>一个中间操作链，对数据源的数据进行处理。</p></li><li><p>终止操作</p><p>只有执行终止操作，才执行中间操作链，并产生结果。之后，不会再被使用。</p></li></ol><h3 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h3><ol><li><strong>通过集合</strong>：Java8中的Collection接口被扩展，提供了两个获取流的方法。</li><li><strong>通过数组</strong>：Java8中的Arrays的静态方法stream()可以获取数组流。</li><li><strong>通过Stream的of()</strong>：可以调用Stream类静态方法of()，通过显示值创建一个流。它可以接收任意数量的参数。</li><li><strong>创建无限流</strong>：可以使用静态方法Stream.iterate()和Stream.generate()，创建无限流。</li></ol><p>代码示例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StreamAPITest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建方式一:通过集合</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employees <span class="token operator">=</span> EmployeeData<span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//default Stream&lt;E> stream():返回一个顺序流</span>        Stream<span class="token operator">&lt;</span>Employee<span class="token operator">></span> stream <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//default Stream&lt;E> parallelStream():返回一个并行流</span>        Stream<span class="token operator">&lt;</span>Employee<span class="token operator">></span> parallelStream <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建方式二:通过数组</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        IntStream stream1 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//重载:IntStream LongStream DoubleStream</span>        Employee e1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1001</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Employee e2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token number">1002</span><span class="token punctuation">,</span> <span class="token string">"Jerry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Employee<span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">}</span><span class="token punctuation">;</span>        Stream<span class="token operator">&lt;</span>Employee<span class="token operator">></span> stream2 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//泛型:Stream&lt;Employee></span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建方式三:通过Stream的of()</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建方式四:创建无限流(造数据)</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//迭代方式</span>        Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> t <span class="token operator">-</span><span class="token operator">></span> t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//随机生成</span>        Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>Math<span class="token operator">:</span><span class="token operator">:</span>random<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理。而在终止操作时一次性全部处理，称为“惰性求值”。</p><h4 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter(Predicate  p)</td><td>接收Lambda,  从流中排除某些元素（<strong>过滤</strong>）</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成元素的hashCode()和equals()去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补</td></tr></tbody></table><p>代码示例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> list <span class="token operator">=</span> EmployeeData<span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//年龄大于26岁</span>    list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前3条数据</span>    list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//跳过前3条数据</span>    list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//去重</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><table><thead><tr><th>方法 描述</th><th></th></tr></thead><tbody><tr><td><strong>map(Function f)</strong></td><td>接收一个函数作为参数,该函数会被应用到每个元素上,并将其映射成一个新的元素</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数,该函数会被应用到每个元素上,产生一个新的DoubleStream</td></tr><tr><td>mapTolnt( ToIntFunction f)</td><td>接收一个函数作为参数,该函数会被应用到每个元 素上,产生一个新的IntStream</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数,该函数会被应用到每个元 素上,产生一个新的LongStream</td></tr><tr><td><strong>flatMap(Function f)</strong></td><td>接收一个函数作为参数,将流中的每个值都换成另一个流,然后把所有流连接成一个流</td></tr></tbody></table><p>代码示例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">,</span><span class="token string">"cc"</span><span class="token punctuation">,</span><span class="token string">"dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>str <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//map(Function f)</span>    Stream<span class="token operator">&lt;</span>Character<span class="token operator">></span> characterStream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>StreamAPITest<span class="token operator">:</span><span class="token operator">:</span>formStringToStream<span class="token punctuation">)</span><span class="token punctuation">;</span>    characterStream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//flatMap(Function f)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table><p>代码示例</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自然排序</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employees <span class="token operator">=</span> EmployeeData<span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span>e2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ageValue <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>e2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定制排序</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ageValue <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> ageValue<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//先根据年龄大小排序，如果年龄相等则按照薪资排序</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> Double<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>e1<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>e2<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如: List、 Integer，甚至是void。</p><p>流进行了终止操作后，不能再次使用。</p><h4 id="匹配与查找"><a href="#匹配与查找" class="headerlink" title="匹配与查找"></a>匹配与查找</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>findFirst()</td><td>返回第一个元素</td></tr><tr><td>findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>count()</td><td>返回流中元素总数</td></tr><tr><td>max(Comparator  c)</td><td>返回流中最大值</td></tr><tr><td>min(Comparator  c)</td><td>返回流中最小值</td></tr><tr><td>forEach(Consumer c)</td><td><strong>内部迭代</strong></td></tr></tbody></table><p><strong>内部迭代</strong>：使用Collection接口需要用户去做迭代，称为外部迭代。相反Stream API使用内部迭代，它帮你把迭代做了。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employees <span class="token operator">=</span> EmployeeData<span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> allMatch <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>allMatch<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索是否所有人的年龄都大于18岁</span>    <span class="token keyword">boolean</span> anyMatch <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>anyMatch<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索是否所有人的薪水都大于1000</span>    <span class="token keyword">boolean</span> noneMatch <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"侠"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>noneMatch<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索是否没有末尾叫"侠"的人</span>    Optional<span class="token operator">&lt;</span>Employee<span class="token operator">></span> first <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索第一个数据</span>    Optional<span class="token operator">&lt;</span>Employee<span class="token operator">></span> any <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索随机的数据</span>    <span class="token keyword">long</span> count <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索个数</span>    Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ageStream <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> maxAge <span class="token operator">=</span> ageStream<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Double<span class="token operator">:</span><span class="token operator">:</span>compare<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>maxAge<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索最大年龄的数据</span>    Stream<span class="token operator">&lt;</span>Double<span class="token operator">></span> salaryStream <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Optional<span class="token operator">&lt;</span>Double<span class="token operator">></span> minSalary <span class="token operator">=</span> salaryStream<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>Double<span class="token operator">:</span><span class="token operator">:</span>compare<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>minSalary<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//检索最低薪水的数据</span>    employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//内部迭代遍历</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来,得到一个值。返回 T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来,得到一个值。返回 Optional&lt;T&gt;</td></tr></tbody></table><p>备注: map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer sum <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//0是初始值</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//求和</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employees <span class="token operator">=</span> EmployeeData<span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Stream<span class="token operator">&lt;</span>Double<span class="token operator">></span> salaryStream <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Employee<span class="token operator">:</span><span class="token operator">:</span>getSalary<span class="token punctuation">)</span><span class="token punctuation">;</span>    Optional<span class="token operator">&lt;</span>Double<span class="token operator">></span> sumMoney <span class="token operator">=</span> salaryStream<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Double<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sumMoney<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//求薪水总和,等同于reduce(d1,d2) -> (d1+d2);</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p>Collector接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。</p><p>另外，Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test23</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employees <span class="token operator">=</span> EmployeeData<span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employeeList <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    employeeList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>Employee<span class="token operator">></span> employeeSet <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    employeeSet<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><ul><li>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类 已经成为Java 8类库的一部分。</li><li><strong>Optional&lt;T&gt;类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</strong></li><li>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</li></ul><p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><ul><li>创建Optional类对象的方法：<ul><li><code>Optional.of(T t)</code>：创建一个Optional实例，t必须非空；</li><li><code>Optional.empty()</code>：创建一个空的Optional实例；</li><li><code>Optional.ofNullable(T t)</code>：t可以为null。</li></ul></li><li>判断Optional容器中是否包含对象：<ul><li><code>boolean isPresent()</code>：判断是否包含对象；</li><li><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul></li><li>获取Optional容器的对象：<ul><li><code>T get()</code>：如果调用对象包含值，返回该值，否则抛异常；</li><li><code>T orElse(T other)</code>：如果有值则将其返回，否则返回指定的other对象；</li><li><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果有值则将其返回，否则返回由Supplier接口实现提供的对象；</li><li><code>T orElse Throw(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何星空连线背景-canvas</title>
      <link href="/2020/02/05/star/"/>
      <url>/2020/02/05/star/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近受疫情的影响，整天宅在家无所事事，于是就想给自己的博客添加一个动态的背景，试了各种GIF和视频，动画效果有了不过CPU占用太高，浏览体验不佳，最后选择了这个几何星空背景页面，参考网上大神的代码自己改了一份，效果如下。</p><h2 id="星空入口"><a href="#星空入口" class="headerlink" title="星空入口"></a>星空入口</h2><p>点击传送门可以预览效果：<a href="https://lishaojie1993.gitee.io/demo/star.html">传送门</a><a id="more"></a></p><h2 id="预览实现"><a href="#预览实现" class="headerlink" title="预览实现"></a>预览实现</h2><h4 id="1、在GitHub上新建repository"><a href="#1、在GitHub上新建repository" class="headerlink" title="1、在GitHub上新建repository"></a>1、在GitHub上新建repository</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc1thz4junj316s0my7ej.jpg" alt></p><h4 id="2、点击setting，修改GitHub-Pages"><a href="#2、点击setting，修改GitHub-Pages" class="headerlink" title="2、点击setting，修改GitHub Pages"></a>2、点击setting，修改GitHub Pages</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc1tjizss0j316k0k47d1.jpg" alt></p><h4 id="3、将网页文件上传到GitHub（访问）www-lishaojie-top-demo-star-html"><a href="#3、将网页文件上传到GitHub（访问）www-lishaojie-top-demo-star-html" class="headerlink" title="3、将网页文件上传到GitHub（访问）www.lishaojie.top/demo/star.html"></a>3、将网页文件上传到GitHub（访问）<a href="http://www.lishaojie.top/demo/star.html" target="_blank" rel="noopener">www.lishaojie.top/demo/star.html</a></h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc1tp8p8a3j31j00k0k0f.jpg" alt></p><hr><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>几何星空连线背景<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>canvas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token comment" spellcheck="true">// 可调参数</span><span class="token keyword">var</span> BACKGROUND_COLOR <span class="token operator">=</span> <span class="token string">"rgba(0,43,54,1)"</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 背景颜色</span><span class="token keyword">var</span> POINT_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 星星数目</span><span class="token keyword">var</span> POINT_COLOR <span class="token operator">=</span> <span class="token string">"rgba(255,255,255,0.7)"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 点的颜色</span><span class="token keyword">var</span> LINE_LENGTH <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 点之间连线长度(的平方)</span><span class="token comment" spellcheck="true">// 创建背景画布</span><span class="token keyword">var</span> cvs <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"canvas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>cvs<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">"\    position:fixed;\    top:0px;\    left:0px;\    z-index:-1;\    opacity:1.0;\    "</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>cvs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> ctx <span class="token operator">=</span> cvs<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">"2d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> startTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//随机数函数</span><span class="token keyword">function</span> <span class="token function">randomInt</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> min<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//构造点类</span><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> speed <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> angle <span class="token operator">=</span> <span class="token function">randomFloat</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span> <span class="token operator">*</span> speed<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> POINT_COLOR<span class="token punctuation">;</span><span class="token punctuation">}</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>move <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">></span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dx <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">></span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token operator">-</span><span class="token keyword">this</span><span class="token punctuation">.</span>dy<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>Point<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>draw <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">arc</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span>PI <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">initPoints</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        points<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//鼠标</span>p0<span class="token punctuation">.</span>dx <span class="token operator">=</span> p0<span class="token punctuation">.</span>dy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> degree <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>onmousemove <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span>onmousedown <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    degree <span class="token operator">=</span> <span class="token number">5.0</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>document<span class="token punctuation">.</span>onmouseup <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    degree <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientX<span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> ev<span class="token punctuation">.</span>clientY<span class="token punctuation">;</span><span class="token punctuation">}</span>window<span class="token punctuation">.</span>onmouseout <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    p0<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    p0<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">drawLine</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> deg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> dx <span class="token operator">=</span> p1<span class="token punctuation">.</span>x <span class="token operator">-</span> p2<span class="token punctuation">.</span>x<span class="token punctuation">;</span>    <span class="token keyword">var</span> dy <span class="token operator">=</span> p1<span class="token punctuation">.</span>y <span class="token operator">-</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token keyword">var</span> dis2 <span class="token operator">=</span> dx <span class="token operator">*</span> dx <span class="token operator">+</span> dy <span class="token operator">*</span> dy<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dis2 <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dis2 <span class="token operator">></span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">===</span> p0<span class="token punctuation">)</span> <span class="token punctuation">{</span>                p2<span class="token punctuation">.</span>x <span class="token operator">+</span><span class="token operator">=</span> dx <span class="token operator">*</span> <span class="token number">0.03</span><span class="token punctuation">;</span>                p2<span class="token punctuation">.</span>y <span class="token operator">+</span><span class="token operator">=</span> dy <span class="token operator">*</span> <span class="token number">0.03</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.05</span> <span class="token operator">-</span> dis2 <span class="token operator">/</span> LINE_LENGTH<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.2</span> <span class="token operator">*</span> deg<span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>strokeStyle <span class="token operator">=</span> <span class="token string">"rgba(255,255,255,"</span> <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">beginPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span>lineWidth <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">moveTo</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p1<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">lineTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">closePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">stroke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//绘制每一帧</span><span class="token keyword">function</span> <span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cvs<span class="token punctuation">.</span>width <span class="token operator">=</span> window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">;</span>    cvs<span class="token punctuation">.</span>height <span class="token operator">=</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> BACKGROUND_COLOR<span class="token punctuation">;</span>    ctx<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>width<span class="token punctuation">,</span> cvs<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span>p0<span class="token punctuation">.</span>x <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> points <span class="token punctuation">:</span> <span class="token punctuation">[</span>p0<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawLine</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    window<span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>drawFrame<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">initPoints</span><span class="token punctuation">(</span>POINT_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">drawFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DIY </tag>
            
            <tag> star-line </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub骚操作</title>
      <link href="/2020/01/20/github/"/>
      <url>/2020/01/20/github/</url>
      
        <content type="html"><![CDATA[<h2 id="in-限制搜索范围"><a href="#in-限制搜索范围" class="headerlink" title="in:限制搜索范围"></a>in:限制搜索范围</h2><p>公式：<strong>xxx in:name｜description｜readme</strong></p><ul><li>xxx in:name 项目名包含xxx的</li><li>xxx in:description 项目描述包含xxx的</li><li>xxx in:readme 项目的readme文件中包含xxx的</li></ul><p>组合使用（查秒杀系统）：<strong>seckill in:<code>name</code>,<code>description</code>,<code>readme</code></strong><a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhjlmxiej31l30u0qv5.jpg" alt></p><h2 id="stars-｜forks-数量区间"><a href="#stars-｜forks-数量区间" class="headerlink" title="stars:｜forks:数量区间"></a>stars:｜forks:数量区间</h2><p>公式：<strong>xxx stars:</strong><kbd>></kbd><kbd><</kbd><kbd>=</kbd><strong>｜</strong><kbd>..</kbd></p><p>查找stars数大于等于5000的springboot项目：<strong>springboot stars:&gt;=5000</strong></p><p>查找fork数大于300的springcloud项目：<strong>springcloud forks:&gt;300</strong></p><p>组合使用：查找fork在100～200之间并且star数在80～100之间的springboot项目</p><p><strong>seckill forks:100..2000 stars:1000..2000</strong>：缩小查找范围</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhnxi6rrj31em0n6e2t.jpg" alt></p><h2 id="awesome-加强搜索"><a href="#awesome-加强搜索" class="headerlink" title="awesome 加强搜索"></a>awesome 加强搜索</h2><p>搜索优秀的比如redis相关的项目，包括框架、教程等。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhtnze9ij31hk0u0u0x.jpg" alt></p><h2 id="高亮显示某一行代码"><a href="#高亮显示某一行代码" class="headerlink" title="高亮显示某一行代码"></a>高亮显示某一行代码</h2><ul><li>单行高亮：<strong>GitHub地址+#L行数</strong></li><li>多行高亮：<strong>GitHub地址+#L行数-L行数</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnh72xxn6j313q0jynh5.jpg" alt></p><h2 id="项目内搜索"><a href="#项目内搜索" class="headerlink" title="项目内搜索"></a>项目内搜索</h2><ul><li><p>进入项目页后按<kbd>t</kbd>：激活文件查看器，可以直接搜索内容</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhbtga2qj31aq0u07wh.jpg" alt></p></li><li><p>进入代码页后按<kbd>l</kbd>：输入数字，跳到代码中的具体哪一行</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcnhdhoeqjj31jo0gmk87.jpg" alt></p></li></ul><p>更多快捷键操作请点击：<a href="https://help.github.com/en/github/getting-started-with-github/keyboard-shortcuts" target="_blank" rel="noopener">https://help.github.com/en/github/getting-started-with-github/keyboard-shortcuts</a></p><h2 id="搜索某个地区内的大佬"><a href="#搜索某个地区内的大佬" class="headerlink" title="搜索某个地区内的大佬"></a>搜索某个地区内的大佬</h2><p>location:地区｜language:语言</p><p>例如：<strong>location:beijing language:java</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcngwj9gyrj316o0u0npd.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射&amp;动态代理</title>
      <link href="/2020/01/20/proxy/"/>
      <url>/2020/01/20/proxy/</url>
      
        <content type="html"><![CDATA[<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><h3 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h3><p>在 Java 程序中许多对象在运行时都会出现两种类型：编译时类型和运行时类型。 </p><p>编译时的类型由声明对象时使用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：</p><pre class="line-numbers language-java"><code class="language-java">Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中编译时类型为 Person，运行时类型为 Student。</p><h3 id="Java反射API"><a href="#Java反射API" class="headerlink" title="Java反射API"></a>Java反射API</h3><p>java.lang.Class 类：反射的核心类，可以获取类的属性，方法等信息。</p><p>java.lang.reflect.Field 类：表示类的成员变量，可以用来获取和设置类之中的属性值。</p><p>java.lang.reflect.Method 类：表示类的方法，它可以用来获取类中的方法信息或者执行方法。</p><p>java.lang.reflect.Constructor 类：表示类的构造方法。</p><h3 id="关于Class类的理解"><a href="#关于Class类的理解" class="headerlink" title="关于Class类的理解"></a>关于Class类的理解</h3><p>简单来说，Class的实例就对应着一个<strong>运行时类</strong>。加载到内存中的运行时类会缓存一定的时间，在此时间内，我们可以通过不同的方式来获取此运行时类。</p><h3 id="获取Class实例的方式"><a href="#获取Class实例的方式" class="headerlink" title="获取Class实例的方式"></a>获取Class实例的方式</h3><ol><li><p>调用某个对象的 getClass()方法</p><pre class="line-numbers language-java"><code class="language-java">Person p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class <span class="token class-name">clazz</span><span class="token operator">=</span>p<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>调用某个类的 class 属性来获取该类对应的 Class 对象</p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">clazz</span><span class="token operator">=</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">clazz</span><span class="token operator">=</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"类的全路径"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//(最常用)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取 Person 类的 Class 对象</span>Class <span class="token class-name">clazz</span><span class="token operator">=</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"reflection.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取 Person 类的所有方法信息</span>Method<span class="token punctuation">[</span><span class="token punctuation">]</span> method<span class="token operator">=</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Method m<span class="token operator">:</span>method<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取 Person 类的所有成员属性信息</span>Field<span class="token punctuation">[</span><span class="token punctuation">]</span> field<span class="token operator">=</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Field f<span class="token operator">:</span>field<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取 Person 类的所有构造方法信息</span>Constructor<span class="token punctuation">[</span><span class="token punctuation">]</span> constructor<span class="token operator">=</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Constructor c<span class="token operator">:</span>constructor<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3><p>方式一：new + 构造器</p><p>方式二：Xxx、Xxxs、XxxFactory、XxxBuilder</p><p>方式三：通过反射</p><h3 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h3><ol><li><p><strong>调用Class对象的newInstance()</strong></p><p>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</p></li><li><p><strong>调用Constructor对象的newInstance()</strong></p><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例，通过这种方法可以选定构造方法创建实例。</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取 Person 类的 Class 对象</span>Class <span class="token class-name">clazz</span><span class="token operator">=</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"reflection.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最常用的反射方式</span><span class="token comment" spellcheck="true">//调用Class对象的newInstance()</span>Person p<span class="token operator">=</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用Class对象的show()方法</span>Method method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclareMethod</span><span class="token punctuation">(</span><span class="token string">"show"</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//参数2指定获取方法的形参列表</span>method<span class="token punctuation">.</span><span class="token function">setAccessiable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保证当前方法是可访问的</span>method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">"CH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//给方法赋值的实参</span><span class="token comment" spellcheck="true">//获取Constructor对象</span>Constructor c<span class="token operator">=</span>clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用Constructor对象的newInstance()</span>Person p1<span class="token operator">=</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span> c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span><span class="token string">"男"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反射的应用-动态代理"><a href="#反射的应用-动态代理" class="headerlink" title="反射的应用-动态代理"></a>反射的应用-动态代理</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token keyword">interface</span> <span class="token class-name">Avenger</span> <span class="token punctuation">{</span>    String <span class="token function">getName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">useWeapon</span><span class="token punctuation">(</span>String weapon<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">IronMan</span> <span class="token keyword">implements</span> <span class="token class-name">Avenger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm IronMan! Avenger Leader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"我是 "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useWeapon</span><span class="token punctuation">(</span>String weapon<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我使用 "</span> <span class="token operator">+</span> weapon<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">SpiderMan</span> <span class="token keyword">implements</span> <span class="token class-name">Avenger</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm SpiderMan! Avenger lovely"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"我是 "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">useWeapon</span><span class="token punctuation">(</span>String weapon<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我使用 "</span> <span class="token operator">+</span> weapon<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//代理工厂</span><span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//调用此方法,根据传入的被代理类对象创建并返回一个代理类对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getProxyInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//obj参数是被代理类的对象</span>        MyInvocationHandler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将被代理对象传给 MyInvocationHandler</span>        <span class="token comment" spellcheck="true">//返回动态创建出的代理对象</span>        <span class="token keyword">return</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">MyInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Object obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//声明并获取被代理对象</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bind</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当我们通过DynamicProxyTest类的代理对象调用其方法时,就会自动调用invoke()方法.</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        Object returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用被代理对象进行方法回调</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicProxyTest</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//没有显式的定义代理类,而是根据传入的被代理对象来动态的创建代理类,体现了反射的动态性</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建被代理对象</span>        IronMan ironMan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IronMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过反射创建代理对象</span>        Avenger proxyInstance1 <span class="token operator">=</span> <span class="token punctuation">(</span>Avenger<span class="token punctuation">)</span> ProxyFactory<span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span>ironMan<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用代理对象调用被代理对象的方法</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>proxyInstance1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token string">"斯塔克"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyInstance1<span class="token punctuation">.</span><span class="token function">useWeapon</span><span class="token punctuation">(</span><span class="token string">"激光武器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SpiderMan spiderMan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpiderMan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Avenger proxyInstance2 <span class="token operator">=</span> <span class="token punctuation">(</span>Avenger<span class="token punctuation">)</span> ProxyFactory<span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span>spiderMan<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>proxyInstance2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token string">"皮特儿"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxyInstance2<span class="token punctuation">.</span><span class="token function">useWeapon</span><span class="token punctuation">(</span><span class="token string">"蜘蛛网"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="基于动态代理的AOP"><a href="#基于动态代理的AOP" class="headerlink" title="基于动态代理的AOP"></a>基于动态代理的AOP</h3><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//在MyInvocationHandler中的invoke()方法前后添加如下代码</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        Utils utils <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Utils</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        utils<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//回调方法之前获取方法信息</span>        Object returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用被代理对象进行方法回调</span>        utils<span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//回调方法之后追加日志输出</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心知识</title>
      <link href="/2020/01/19/java-basic/"/>
      <url>/2020/01/19/java-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception。</p><ul><li><p>Error</p><p>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止，如<code>StackOverFlow</code>和<code>OutOfMemery</code>。详细请参考：<a href="https://lishaojie1993.gitee.io/2020/03/02/OOM/">内存溢出举例</a></p></li><li><p>Exception</p><ul><li><p>运行时异常RuntimeException：指那些可能在 Java 虚拟机正常运行期间抛出的异常的超类，如NullPointerException、 ClassCastException。只要发现此类异常就是程序员的错误。</p></li><li><p>检查异常CheckedException：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p><blockquote><ol><li>试图在文件尾部读取数据。</li><li>试图打开一个错误格式的 URL。</li><li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在。</li></ol></blockquote><p>如 I/O 错误导致的 IOException、SQLException。</p></li></ul></li></ul><h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ul><li><p>抛出异常</p><p>抛出异常有三种形式，一种是throw，一种是throws，还有一种系统自动抛异常。</p></li><li><p>捕获异常</p><p>使用try catch捕获异常并进行针对性的处理。</p></li></ul><p><strong>throw和throws的区别？</strong></p><ul><li><p>位置不同</p><p>throws 用在方法上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。</p></li><li><p>功能不同</p><blockquote><ol><li>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</li><li>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由方法去处理异常，真正的处理异常由方法的上层调用处理。</li></ol></blockquote></li></ul><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</p><p>详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2020/01/20/proxy/">Java反射&amp;动态代理</a></p><h2 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h2><p>Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p><h3 id="4种标准元注解"><a href="#4种标准元注解" class="headerlink" title="4种标准元注解"></a>4种标准元注解</h3><ul><li><strong>@Target</strong> 修饰的对象范围</li><li><strong>@Retention</strong> 定义被保留的时间长短</li><li><strong>@Document</strong> 描述-javadoc</li><li><strong>@Inherited</strong> 阐述了某个被标注的类型是被继承的</li></ul><h2 id="Java内部类"><a href="#Java内部类" class="headerlink" title="Java内部类"></a>Java内部类</h2><p>Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。</p><p>根据定义的方式不同，内部类分为<strong>静态内部类，成员内部类，局部内部类，匿名内部类</strong>四种。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Out</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>静态内部类可以访问外部类所有的静态变量和方法，即使是 private 修饰的也一样可以访问。</p></li><li><p>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。</p></li><li><p>其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：</p><pre class="line-numbers language-java"><code class="language-java">Out<span class="token punctuation">.</span>Inner inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Out<span class="token punctuation">.</span>Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>inner<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。</p></li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和静态变量（final 修饰的除外）。这是因为成员内部类是非静态的， 类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Out</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在方法中的类，就是局部内部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Out</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Bird bird<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bird<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"能够飞 "</span> <span class="token operator">+</span> bird<span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"米"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        test<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">10000</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token string">"大雁"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。</p><h3 id="泛型方法-lt-E-gt"><a href="#泛型方法-lt-E-gt" class="headerlink" title="泛型方法&lt;E&gt;"></a>泛型方法&lt;E&gt;</h3><p>手写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 泛型方法 printArray</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span> E <span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> E element <span class="token operator">:</span> inputArray <span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"%s "</span><span class="token punctuation">,</span> element <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="泛型类-lt-T-gt"><a href="#泛型类-lt-T-gt" class="headerlink" title="泛型类&lt;T&gt;"></a>泛型类&lt;T&gt;</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> T t<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类型通配符 <strong>？</strong></p><p>类型通配符一般是使用?代替具体的类型参数。</p><p>例如List&lt;?&gt; 在逻辑上是List&lt;String&gt;,List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt;的父类。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt;Object&gt;和 List&lt;String&gt;等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。</p><h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java提供一种保存对象状态的机制，那就是序列化。</p><p>什么情况下需要序列化：</p><ul><li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想通过RMI传输对象的时候；</li></ul><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h3 id="为什么要使用克隆"><a href="#为什么要使用克隆" class="headerlink" title="为什么要使用克隆"></a>为什么要使用克隆</h3><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p><h3 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h3><p>有两种方式：</p><p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p><p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p><p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。</p><p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式-Singleton Pattern</title>
      <link href="/2020/01/18/singleton/"/>
      <url>/2020/01/18/singleton/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>单例模式属于设计模式三大分类的第一类——<strong>创建型模式</strong>，单例模式在创建对象的同时还要控制对象的数量，<strong>只能创建一个实例</strong>。</p><ol><li><p>有些场景下，不使用单例模式，会导致系统同一时刻出现多个状态，如网页流量计数器。</p></li><li><p>通过控制创建对象的数量，可以节约系统资源开销。不需要频繁的创建跟销毁。</p></li><li><p>全局数据共享。</p><ul><li><p>比如应用中的日志系统，所有的日志都会统一追加，方便后续管理。</p></li><li><p>读取配置的类一般会使用一个单例去统一加载读取。（一般都是启动时加载一次）<a id="more"></a></p></li></ul></li></ol><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><ol><li>私有的构造方法</li><li>指向自己实例的私有静态引用</li><li>以自己实例为返回值的静态的公有的方法</li></ol><p><strong>单例模式根据实例化对象时机的不同分为两种：饿汉式、懒汉式。</strong></p><p>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式在调用取得实例方法的时候才会实例化对象。</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungrySingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//①</span>    <span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//②</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungrySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//③</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①static修饰，类加载时new对象，天然防止并发问题</span><span class="token comment" spellcheck="true">//②私有化构造方法，禁止其他类通过构造方法创建对象</span><span class="token comment" spellcheck="true">//③对外提供单例对象的获取方式</span><span class="token comment" spellcheck="true">//存在的问题</span><span class="token comment" spellcheck="true">//1、类初始化就创建，如果对象非常大，会对系统的性能造成影响</span><span class="token comment" spellcheck="true">//2、有时候只是单纯想加载类，不想使用对象，会浪费内存空间</span><span class="token comment" spellcheck="true">//3、如果类中有静态属性的话，访问静态属性会导致对象被实例化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> LazySingleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//①</span>    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//②</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//③</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①static修饰，类加载时不创建对象，volatile保证可见性</span><span class="token comment" spellcheck="true">//②私有化构造方法</span><span class="token comment" spellcheck="true">//③考虑线程安全加synchronized同步锁</span><span class="token comment" spellcheck="true">//存在的问题</span><span class="token comment" spellcheck="true">//每个线程不管instance有没有被创建过，都会去调用getInstance()，因为if(instance == null)是需要进入方法后才判断的，然而getInstance()又是一个同步的，同一时刻只会有一个线程进入，其余线程都必须等待，这就会导致线程阻塞，性能下降。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> LazySingleton instance<span class="token operator">=</span>null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//①</span>    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//②</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//③</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//④</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//⑤</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//⑥</span>                    instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//⑦</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①static修饰，类加载时不创建对象，volatile保证可见性、防止指令重排序</span><span class="token comment" spellcheck="true">//②私有化构造方法</span><span class="token comment" spellcheck="true">//③在获取实例的方法上不加锁</span><span class="token comment" spellcheck="true">//④判断是否创建了实例，如果有实例直接返回，提高效率</span><span class="token comment" spellcheck="true">//⑤没有创建实例，需要进入同步方法创建实例</span><span class="token comment" spellcheck="true">//⑥保证多线程安全，防止创建多个实例</span><span class="token comment" spellcheck="true">//⑦volatile防止指令重排</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于volatile指令重排序的讲解：</p><p>⑦处会创建一个<code>LazySingleton</code>实例，并且赋值给<code>instance</code>变量，但是这一个动作在指令层面<strong>并非原子操作</strong>。这个动作可以分为4步：</p><ol><li>申请内存空间</li><li>初始化默认值</li><li>执行构造器初始化</li><li>将instance指向创建的对象</li></ol><p>有些编译器会对代码做指令重排序，因为3和4本身相互并不存在依赖，指令重排序的存在可能会导致3和4顺序发生颠倒。这会有什么问题？首先在单线程下并不会有什么问题，因为指令重排序的前提就是不改变在单线程下的结果，无论先执行3还是4，最后返回的对象都是初始化好后的。但是在多线程下呢？设想一种极端场景，现在假设A线程拿到锁进入到⑦处，然后它完成了上面4步的1和2，因为现在指令重排序了，下面A线程会将<code>instance</code>指向创建的对象，也就是说，此时<code>instance != null</code>了！然后正当A要去执行构造器初始化对象时，巧得很，这时候B线程来到④处，判断<code>instance == null</code>不成立了，直接返回，但是A线程还没有初始化对象呢，因为返回了一个没有经过初始化的对象，后续操作自然会有问题。正是因为这个原因，所以①处<code>volatile</code>不可省略，<strong>主要原因就在于防止指令重排序</strong>，避免上述问题。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerSingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">StaticInnerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInnerSingletonInstance</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//①</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> StaticInnerSingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticInnerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> StaticInnerSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//②</span>      <span class="token keyword">return</span> StaticInnerSingletonInstance<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//说明</span><span class="token comment" spellcheck="true">//①StaticInnerSingletonInstance是一个静态内部类，内部静态字段instance负责创建对象。外部类StaticInnerSingleton初始化时，并不会导致StaticInnerSingletonInstance初始化，进而导致instance的初始化。所以实现了延迟加载。</span><span class="token comment" spellcheck="true">//②通过StaticInnerSingletonInstance.instance对instance引用才会导致对象的创建。由于static的属性只会跟随类加载初始化一次，天然保证了线程安全问题。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">enum</span> EnumSingletonInstance<span class="token punctuation">{</span>   INSTANCE<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> EnumSingletonInstance <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//好处：绝对安全，不会被破解</span><span class="token comment" spellcheck="true">//缺点：不能实现延迟加载，对象不大的情况下推荐使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="破解单例"><a href="#破解单例" class="headerlink" title="破解单例"></a>破解单例</h2><h3 id="反射破解"><a href="#反射破解" class="headerlink" title="反射破解"></a>反射破解</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungrySingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungrySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 破解单例</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反射破解单例..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance1 <span class="token operator">=</span> HungrySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance2 <span class="token operator">=</span> HungrySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//反射破解单例...</span><span class="token comment" spellcheck="true">//HungrySingleton@60e53b93</span><span class="token comment" spellcheck="true">//HungrySingleton@5e2de80c</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何防止反射破解"><a href="#如何防止反射破解" class="headerlink" title="如何防止反射破解"></a>如何防止反射破解</h3><p>很简单，因为<code>Class.newInstance()</code>是通过调用<code>HungrySingleton()</code>无参构造器创建对象的，只要在构造器中加入有以下逻辑即可。这样，当类初始化时，第一次正常创建出实例并赋值给<code>instance</code>。当再想通过反射想要破解单例时，自然会抛出异常阻止继续实例化。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 构造方法修改如下</span><span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"只能创建一个对象！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//java.lang.Exception: 只能创建一个对象！</span><span class="token comment" spellcheck="true">//    at HungrySingleton.&lt;init>(HungrySingleton.java:6)</span><span class="token comment" spellcheck="true">//    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><span class="token comment" spellcheck="true">//    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><span class="token comment" spellcheck="true">//    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><span class="token comment" spellcheck="true">//    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><span class="token comment" spellcheck="true">//    at java.lang.Class.newInstance(Class.java:442)</span><span class="token comment" spellcheck="true">//    at HungrySingleton.main(HungrySingleton.java:20)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反序列化破解"><a href="#反序列化破解" class="headerlink" title="反序列化破解"></a>反序列化破解</h3><p>前提是单例类实现了<code>Serializable</code>接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungrySingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">HungrySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungrySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 破解单例</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"反序列化破解单例..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance1 <span class="token operator">=</span> HungrySingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//序列化</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungrySingleton instance2 <span class="token operator">=</span> <span class="token punctuation">(</span>HungrySingleton<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//反序列化</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果如下</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//反序列化破解单例...</span><span class="token comment" spellcheck="true">//HungrySingleton@511d50c0</span><span class="token comment" spellcheck="true">//HungrySingleton@2f4d3709</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如何防止反序列化破解"><a href="#如何防止反序列化破解" class="headerlink" title="如何防止反序列化破解"></a>如何防止反序列化破解</h3><p>也非常简单，只需要在单例类中添加如下<code>readResolve()</code>方法，然后在方法体中返回我们的单例实例即可。为什么？因为<code>readResolve()</code>方法是在<code>readObject()</code>方法之后才被调用，因而它每次都会用我们自己生成的单实例替换从流中读取的对象。这样自然就保证了单例。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ObjectStreamException<span class="token punctuation">{</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="适用场景和注意事项"><a href="#适用场景和注意事项" class="headerlink" title="适用场景和注意事项"></a>适用场景和注意事项</h2><h3 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h3><ol><li><p>扩展困难，由于<code>getInstance()</code>静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。</p></li><li><p>隐式使用引起类结构不清晰。</p></li><li><p>导致程序内存泄露的问题。</p></li></ol><h3 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h3><ol><li>在内存中只有一个对象，节省内存空间。</li><li>避免频繁的创建销毁对象，可以提高性能。</li><li>避免对共享资源的多重占用。</li><li>可以全局访问。</li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：</p><ol><li><p>需要频繁实例化然后销毁的对象。</p></li><li><p>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</p></li><li><p>资源共享的情况下，避免由于资源操作时导致的性能或损耗等</p></li><li><p>控制资源的情况下，方便资源之间的互相通信。</p></li></ol><h3 id="单例模式注意事项"><a href="#单例模式注意事项" class="headerlink" title="单例模式注意事项"></a>单例模式注意事项</h3><p>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</p><p>不要做断开单例类对象与类中静态引用的危险操作。</p><p>多线程使用单例使用共享资源时，注意线程安全问题。</p><h3 id="一般选用原则"><a href="#一般选用原则" class="headerlink" title="一般选用原则"></a>一般选用原则</h3><ul><li>单例对象占用资源少，不需要延时加载：枚举式好于饿汉式。</li><li>单例对象占用资源大，需要延时加载：静态内部类式好于懒汉式。</li></ul><h2 id="单例模式的一些常见问题"><a href="#单例模式的一些常见问题" class="headerlink" title="单例模式的一些常见问题"></a>单例模式的一些常见问题</h2><h3 id="单例模式的对象长时间不用会被jvm垃圾收集器收集吗"><a href="#单例模式的对象长时间不用会被jvm垃圾收集器收集吗" class="headerlink" title="单例模式的对象长时间不用会被jvm垃圾收集器收集吗?"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗?</h3><pre class="line-numbers language-html"><code class="language-html">除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>JVM卸载类的判定条件如下：</p><ol><li><p>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</p></li><li><p>加载该类的ClassLoader已经被回收。</p></li><li><p>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ol><p>只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。</p><h3 id="单例类可以被继承吗"><a href="#单例类可以被继承吗" class="headerlink" title="单例类可以被继承吗?"></a>单例类可以被继承吗?</h3><p>根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。</p><p>这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="/2020/01/17/spring/"/>
      <url>/2020/01/17/spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring 是Java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p><h3 id="使用Spring的好处"><a href="#使用Spring的好处" class="headerlink" title="使用Spring的好处"></a>使用Spring的好处</h3><ul><li><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB。</li><li><strong>控制反转(IOC)：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架：</strong>Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li><strong>声明式事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li><li><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li></ul><h2 id="IoC-是什么"><a href="#IoC-是什么" class="headerlink" title="IoC 是什么"></a>IoC 是什么</h2><p>全称是<strong>控制反转</strong>（Inversion of Control），原先需要主动通过new实例化对象的事情现在<strong>交由Spring管理</strong>了，最大的作用是<strong>解耦</strong>。</p><p>IOC最大的作用是<strong>解耦</strong>。</p><h3 id="DI-是什么"><a href="#DI-是什么" class="headerlink" title="DI 是什么"></a>DI 是什么</h3><p>全称是<strong>依赖注入</strong>（Dependency Injection），当一个类中需要依赖另一个类对象时，把另一个对象实例化后注入到这个类的过程。</p><p><strong>IOC就是一种软件设计思想，DI是这种软件设计思想的一个实现。而Spring中的核心机制就是DI。</strong></p><h3 id="Spring创建对象的三种方式"><a href="#Spring创建对象的三种方式" class="headerlink" title="Spring创建对象的三种方式"></a>Spring创建对象的三种方式</h3><ol><li><p><strong>通过构造方法创建</strong></p><ul><li>无参构造创建：默认情况</li><li>有参构造创建：需要明确配置（在类中提供具体有参构造方法，在application.xml中配置）</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不使用spring</span>People people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 使用spring --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>people<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.cherry.pojo.People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>张三<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 也可以配置 index="0",index="1" 还可以添加 type="int",type="String"等等 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>实例工厂</strong></p><p>需要创建工厂，才能创建对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不使用spring</span>PeopleFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PeopleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>People people <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 使用spring --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>factory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.cherry.pojo.PeopleFactory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>people<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>factory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newInstance<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>静态工厂</p><p>不需要创建工厂，可以快速创建对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 原始代码</span>People people <span class="token operator">=</span> PeopleFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 使用spring --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>people<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.cherry.pojo.PeopleFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>newInstance<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// spring调用方式相同</span>ApplicationContext ac <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"applicationContext.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>People people <span class="token operator">=</span> ac<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"people"</span><span class="token punctuation">,</span>People<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以指定返回值类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="如何给Bean的属性赋值"><a href="#如何给Bean的属性赋值" class="headerlink" title="如何给Bean的属性赋值"></a>如何给Bean的属性赋值</h3><ul><li><p>通过构造方法注入</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>people<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.cherry.pojo.People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>25<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>张三<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>constructor-arg</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>setter方法注入</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>people<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.cherry.pojo.People<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 简单数据类型或String --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>张三<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Set集合类型 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>subject<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>语文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>数学<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>英语<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ref</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ref</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 对象引用 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- list集合类型 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teacher<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>list</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>语文老师<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>数学老师<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>英语老师<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>list</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 如果list中只有一个值，&lt;property name="teacher"，value="语文老师"> --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- Map集合类型 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>map</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>entry</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>entry</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 数组类型 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>score<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>array</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>98<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>99<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>array</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- properties类型 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>props</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>98<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>prop</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>value<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>prop</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>props</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li></li></ul><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="BeanFactory和FacoryBean的区别"><a href="#BeanFactory和FacoryBean的区别" class="headerlink" title="BeanFactory和FacoryBean的区别"></a>BeanFactory和FacoryBean的区别</h3><p>共同点：都是接口。</p><p>区别</p><ul><li>BeanFactory 以 Factory 结尾，表示它是一个工厂类，用于管理 Bean 的一个工厂。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。</li><li>但对 FactoryBean 而言，这个 Bean 不是简单的 Bean，而是一个能生产或者修饰对象生成的工厂Bean，它的实现与设计模式中的工厂模式和修饰器模式类似。</li></ul><blockquote><p>一般情况下，Spring通过反射机制利用&lt;bean&gt;的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。</p><p>Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。 FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。</p></blockquote><h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><p>BeanFactory是Spring里面最底层的接口，只提供了实例化对象和拿对象的功能；</p><p>ApplicationContext是应用上下文，继承BeanFactory接口，它是Spring的高级容器，提供了更多的有用的功能；</p><ol><li>国际化（MessageSource）：通过ApplicationContext加载不同国家的语言文件。</li><li>访问资源，如URL和文件（ResourceLoader）：可以通过虚拟/绝对/相对路径来获取资源文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li><li>消息发送、响应机制（ApplicationEventPublisher）</li><li>AOP（拦截器）</li></ol><blockquote><p>两者装载Bean的区别</p><p><strong>BeanFactory：</strong></p><p>BeanFactory在启动的时候不会去实例化Bean，只有从容器中拿Bean的时候才会去实例化；</p><p><strong>ApplicationContext：</strong></p><p>ApplicationContext在启动的时候就把所有的Bean全部实例化了。它还可以为Bean配置lazy-init=true来让Bean延迟实例化； </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> web框架 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 防火墙-iptables</title>
      <link href="/2020/01/17/firewall/"/>
      <url>/2020/01/17/firewall/</url>
      
        <content type="html"><![CDATA[<h3 id="关闭默认防火墙"><a href="#关闭默认防火墙" class="headerlink" title="关闭默认防火墙"></a>关闭默认防火墙</h3><p>CentOS 7默认使用的防火墙是firewall，需要将其关闭</p><ul><li>systemctl stop firewalld.service #停止firewall</li><li>systemctl disable firewalld.service #禁止firewall开机启动</li></ul><h3 id="安装-iptables-service"><a href="#安装-iptables-service" class="headerlink" title="安装 iptables service"></a>安装 iptables service</h3><p>yum -y install iptables-services <a id="more"></a></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>vi /etc/sysconfig/iptables </p><h3 id="在配置文件中增加规则"><a href="#在配置文件中增加规则" class="headerlink" title="在配置文件中增加规则"></a>在配置文件中增加规则</h3><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p><h3 id="保存退出，重启防火墙"><a href="#保存退出，重启防火墙" class="headerlink" title="保存退出，重启防火墙"></a>保存退出，重启防火墙</h3><ul><li>systemctl restart iptables.service #重启防火墙使配置生效</li><li>systemctl enable iptables.service #设置防火墙开机启动</li></ul><h3 id="iptables防火墙常用命令"><a href="#iptables防火墙常用命令" class="headerlink" title="iptables防火墙常用命令"></a>iptables防火墙常用命令</h3><ul><li>systemctl start iptables.service #打开防火墙</li><li>systemctl stop iptables.service #关闭防火墙</li><li>systemctl restart iptables.service #重启防火墙</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> FireWall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神一样的存在,万能插件-Tampermonkey</title>
      <link href="/2020/01/10/Tampermonkey/"/>
      <url>/2020/01/10/Tampermonkey/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：<a href="https://lishaojie1993.gitee.io/2020/01/09/ghelper">科学上网推荐,谷歌浏览器插件Ghelper</a>  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg" alt></p><a id="more"></a><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>说到这款插件就不得不说一个网址：<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg" alt></p><p>这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg" alt></p><p>选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg" alt></p><p>点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg" alt></p><h2 id="脚本推荐"><a href="#脚本推荐" class="headerlink" title="脚本推荐"></a>脚本推荐</h2><p>管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg" alt></p><p>我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。</p><p>划词翻译</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg" alt></p><p>BiliBili会员站点解析</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg" alt></p><p>YouTube视频下载</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg" alt></p><p>是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Google plugin </tag>
            
            <tag> Tampermonkey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学上网推荐,谷歌浏览器插件Ghelper</title>
      <link href="/2020/01/10/ghelper/"/>
      <url>/2020/01/10/ghelper/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg" alt></p><a id="more"></a><p>不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 <a href="https://usky.ml/tool/free_ssr" target="_blank" rel="noopener">SSR工具</a></p><p>把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。</p><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg" alt></p><p>点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg" alt></p><h2 id="资费详情"><a href="#资费详情" class="headerlink" title="资费详情"></a>资费详情</h2><p>介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg" alt></p><h2 id="手机代理"><a href="#手机代理" class="headerlink" title="手机代理"></a>手机代理</h2><p>页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg" alt></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>YouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Google plugin </tag>
            
            <tag> Ghelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 超实用的「付费」软件推荐,分享一波福利！</title>
      <link href="/2020/01/07/macapp/"/>
      <url>/2020/01/07/macapp/</url>
      
        <content type="html"><![CDATA[<h2 id="Alfred-4"><a href="#Alfred-4" class="headerlink" title="Alfred 4"></a>Alfred 4</h2><p>版本号: 4.0.6</p><p>功能介绍: <a href="https://www.alfredapp.com/whats-new/" target="_blank" rel="noopener">https://www.alfredapp.com/whats-new/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA" target="_blank" rel="noopener">https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA</a>  密码:9onb</p><p>推荐指数: ★★★★★<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg" alt></p><h2 id="CleanMyMac-X"><a href="#CleanMyMac-X" class="headerlink" title="CleanMyMac X"></a>CleanMyMac X</h2><p>版本号: 4.4.6</p><p>功能介绍: <a href="https://macpaw.com/cleanmymac" target="_blank" rel="noopener">https://macpaw.com/cleanmymac</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA</a>  密码:mslx</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg" alt></p><h2 id="Movist-Pro"><a href="#Movist-Pro" class="headerlink" title="Movist Pro"></a>Movist Pro</h2><p>版本号: 2.2.13</p><p>功能介绍: <a href="https://movistprime.com/" target="_blank" rel="noopener">https://movistprime.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg</a>  密码:8ocb</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg" alt></p><h2 id="Final-Cut-Pro-X"><a href="#Final-Cut-Pro-X" class="headerlink" title="Final Cut Pro X"></a>Final Cut Pro X</h2><p>版本号: 10.4.5</p><p>功能介绍: <a href="https://www.apple.com/final-cut-pro/" target="_blank" rel="noopener">https://www.apple.com/final-cut-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ</a>  密码:wqdk</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg" alt></p><h2 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h2><p>版本号: 4.4.3</p><p>功能介绍: <a href="https://www.apple.com.cn/cn/final-cut-pro/compressor/" target="_blank" rel="noopener">https://www.apple.com.cn/cn/final-cut-pro/compressor/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA</a>  密码:8mng</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg" alt></p><h2 id="iStat-Menus-6"><a href="#iStat-Menus-6" class="headerlink" title="iStat Menus 6"></a>iStat Menus 6</h2><p>版本号: 6.31</p><p>功能介绍: <a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">https://bjango.com/mac/istatmenus/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ</a>  密码:r8yx</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg" alt></p><h2 id="Parallels-Desktop-15"><a href="#Parallels-Desktop-15" class="headerlink" title="Parallels Desktop 15"></a>Parallels Desktop 15</h2><p>版本号: 15.1.2</p><p>功能介绍: <a href="https://www.parallels.com/cn/landingpage/pd/general/" target="_blank" rel="noopener">https://www.parallels.com/cn/landingpage/pd/general/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg" alt></p><h2 id="XMind-8-Pro"><a href="#XMind-8-Pro" class="headerlink" title="XMind 8 Pro"></a>XMind 8 Pro</h2><p>版本号: 3.7.7</p><p>功能介绍: <a href="https://www.xmind.cn/xmind8-pro/" target="_blank" rel="noopener">https://www.xmind.cn/xmind8-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg" alt></p><h2 id="PDF-Expert"><a href="#PDF-Expert" class="headerlink" title="PDF Expert"></a>PDF Expert</h2><p>版本号: 2.4.23</p><p>功能介绍: <a href="https://pdfexpert.com/" target="_blank" rel="noopener">https://pdfexpert.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow" target="_blank" rel="noopener">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p><p>推荐指数: ★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg" alt></p><h2 id="Things-3"><a href="#Things-3" class="headerlink" title="Things 3"></a>Things 3</h2><p>版本号: 3.11</p><p>功能介绍: <a href="https://culturedcode.com/things/" target="_blank" rel="noopener">https://culturedcode.com/things/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ</a>  密码:ddv6</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg" alt></p><h2 id="Downie-3"><a href="#Downie-3" class="headerlink" title="Downie 3"></a>Downie 3</h2><p>版本号: 3.9.4</p><p>功能介绍: <a href="https://software.charliemonroe.net/downie/" target="_blank" rel="noopener">https://software.charliemonroe.net/downie/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA</a>  密码:cqma</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg" alt></p><h2 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h2><p>版本号: 2.4.4</p><p>功能介绍: <a href="https://pasteapp.me/" target="_blank" rel="noopener">https://pasteapp.me/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g" target="_blank" rel="noopener">https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g</a>  密码:4bxn</p><p>推荐指数: ★★★★☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg" alt></p><h2 id="Bartender-3"><a href="#Bartender-3" class="headerlink" title="Bartender 3"></a>Bartender 3</h2><p>版本号: 3.1.1</p><p>功能介绍: <a href="https://www.macbartender.com/" target="_blank" rel="noopener">https://www.macbartender.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q</a>  密码:b00n</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg" alt></p><h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p>版本号: 3.2.2</p><p>功能介绍: <a href="https://zh.mweb.im/" target="_blank" rel="noopener">https://zh.mweb.im/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw</a>  密码:87dx</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg" alt></p><h2 id="Smooze"><a href="#Smooze" class="headerlink" title="Smooze"></a>Smooze</h2><p>版本号: 1.8.6</p><p>功能介绍: <a href="https://smooze.co/" target="_blank" rel="noopener">https://smooze.co/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw</a>  密码:upjo</p><p>推荐指数: ★★☆☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg" alt></p><h2 id="Keka"><a href="#Keka" class="headerlink" title="Keka"></a>Keka</h2><p>版本号: 1.1.5</p><p>功能介绍: <a href="https://www.keka.io/en/" target="_blank" rel="noopener">https://www.keka.io/en/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ</a>  密码:7sdf</p><p>推荐指数: ★★★☆☆</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg" alt></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!</p><p>本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!</p>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> paid apps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 超实用的「免费」软件推荐,使用经验分享！</title>
      <link href="/2020/01/06/macappfree/"/>
      <url>/2020/01/06/macappfree/</url>
      
        <content type="html"><![CDATA[<h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它</p><p>功能介绍：<a href="https://iterm2.com/features.html" target="_blank" rel="noopener">https://iterm2.com/features.html</a></p><p>官方下载地址：<a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener">https://iterm2.com/downloads.html</a></p><p>推荐指数：★★★★★<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg" alt></p><h2 id="IINA"><a href="#IINA" class="headerlink" title="IINA"></a>IINA</h2><p>概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快</p><p>功能介绍：<a href="https://zhuanlan.zhihu.com/p/24700324" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24700324</a></p><p>官方下载地址：<a href="https://iina.io/" target="_blank" rel="noopener">https://iina.io/</a></p><p>推荐指数：★★★★☆（Movist Pro 是满分😄）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg" alt></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>概括：支持实时预览的Markdown文本编辑器</p><p>功能介绍：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">https://sspai.com/post/54912</a></p><p>官方下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><p>推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg" alt></p><h2 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h2><p>概括：Markdown 图床、文件上传工具，免费版足够用</p><p>功能介绍：<a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">https://toolinbox.net/iPic/</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg" alt></p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件</p><p>功能介绍：<a href="https://www.cnblogs.com/clwydjgs/p/10078065.html" target="_blank" rel="noopener">https://www.cnblogs.com/clwydjgs/p/10078065.html</a></p><p>官方下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><p>推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg" alt></p><h2 id="Better-And-Better"><a href="#Better-And-Better" class="headerlink" title="Better And Better"></a>Better And Better</h2><p>概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用</p><p>功能介绍：<a href="https://www.better365.cn/tv.html" target="_blank" rel="noopener">https://www.better365.cn/tv.html</a></p><p>官方下载地址：<a href="https://www.better365.cn/bab.html" target="_blank" rel="noopener">https://www.better365.cn/bab.html</a></p><p>推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg" alt></p><h2 id="iShot"><a href="#iShot" class="headerlink" title="iShot"></a>iShot</h2><p>概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法</p><p>功能介绍：<a href="https://sspai.com/post/57302" target="_blank" rel="noopener">https://sspai.com/post/57302</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg" alt></p><h2 id="Final-Shell"><a href="#Final-Shell" class="headerlink" title="Final Shell"></a>Final Shell</h2><p>概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp</p><p>功能介绍：<a href="https://blog.csdn.net/sinat_25838589/article/details/79781241" target="_blank" rel="noopener">https://blog.csdn.net/sinat_25838589/article/details/79781241</a></p><p>官方下载地址：<a href="http://www.hostbuf.com/t/988.html" target="_blank" rel="noopener">http://www.hostbuf.com/t/988.html</a></p><p>推荐指数：★★★★★</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> free apps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式-Builder Pattern</title>
      <link href="/2019/12/17/builder/"/>
      <url>/2019/12/17/builder/</url>
      
        <content type="html"><![CDATA[<h2 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h2><h3 id="传统方式盖房子"><a href="#传统方式盖房子" class="headerlink" title="传统方式盖房子"></a>传统方式盖房子</h3><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejrlx996dj30js0hq78v.jpg" style="zoom:50%;"><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractHouse</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//打地基</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//砌墙</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildWalls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//封顶</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">roofed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//方法调用顺序</span>        <span class="token function">buildBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">buildWalls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">roofed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonHouse</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractHouse</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通房子打地基5米"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildwalls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通房子砌墙3米"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">roofed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通房子封顶"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        CommonHouse commonHouse <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CommonHouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        commonHouse<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果：</span><span class="token comment" spellcheck="true">//普通房子打地基</span><span class="token comment" spellcheck="true">//普通房子砌墙</span><span class="token comment" spellcheck="true">//普通房子封顶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="传统方式优缺点"><a href="#传统方式优缺点" class="headerlink" title="传统方式优缺点"></a>传统方式优缺点</h3><ol><li>优点是比较好理解，简单易操作。</li><li>缺点是设计的程序结构过于简单，没有设计缓存层对象，程序的扩展和维护不好。也就是说，这种设计方案，把产品(即:房子)和创建产品的过程(即:建房子流程)封装在一起，耦合性增强了。</li></ol><p><strong>解决方案</strong>：将产品和产品建造过程解耦——建造者模式。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="建造者模式介绍"><a href="#建造者模式介绍" class="headerlink" title="建造者模式介绍"></a>建造者模式介绍</h3><ul><li><strong>建造者模式(Builder Pattern)又叫生成器模式</strong>，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。</li><li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ul><h3 id="建造者模式的角色"><a href="#建造者模式的角色" class="headerlink" title="建造者模式的角色"></a>建造者模式的角色</h3><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejrvwcd6bj311y0jgn7z.jpg" style="zoom:50%;"><ul><li><strong>Product (产品角色)</strong>：一个具体的产品对象。</li><li><strong>Builder (抽象建造者)</strong>：创建一个Product对象的各个部件指定的接口/抽象类。</li><li><strong>ConcreteBuilder (具体建造者)</strong>：实现接口，构建和装配各个部件，实现细节。</li><li><strong>Director (指挥者)</strong>：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用：<ul><li>一是隔离了客户与对象的生产过程。</li><li>二是负责控制产品对象的生产过程。</li></ul></li></ul><h3 id="建造者模式在JDK的应用"><a href="#建造者模式在JDK的应用" class="headerlink" title="建造者模式在JDK的应用"></a>建造者模式在JDK的应用</h3><p>java.lang.StringBuilder 使用了建造者模式（StringBuilder =&gt; AbstractStringBuilder =&gt; Appendable）。</p><ul><li>Appendable 接口定义了多个 append() 方法(抽象方法)，即 Appendable 为抽象建造者。</li><li>AbstractStringBuilder 实现了 Appendable 接口中的方法，这里的<br>AbstractStringBuilder 已经是建造者，只是不能实例化。</li><li>StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由 AbstractStringBuilder 完成，而StringBuilder继承了<br>AbstractStringBuilder。</li></ul><h3 id="建造者模式的注意事项"><a href="#建造者模式的注意事项" class="headerlink" title="建造者模式的注意事项"></a>建造者模式的注意事项</h3><ol><li><strong>客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦</strong>，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，<strong>用户使用不同的具体建造者即可得到不同的产品对象</strong>。</li><li><strong>可以更加精细地控制产品的创建过程</strong>。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，<strong>符合“开闭原则”</strong>。</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式。</li></ol><p><strong>抽象工厂模式 VS 建造者模式</strong></p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> builder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式-Adapter Pattern</title>
      <link href="/2019/12/15/adapter/"/>
      <url>/2019/12/15/adapter/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>适配器模式(Adapter Pattern)属于结构型模式</strong>。</p><p>将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容。其别名为包装器(Wrapper)。</p><p><strong>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。</strong></p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>从用户的角度看不到被适配者，是解耦的。</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法。</li><li>用户收到反馈结果，感觉只是和目标接口交互，如下图所示：</li></ol><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejscyl6sej30y607adky.jpg" style="zoom:50%;"><h2 id="适配器模式种类"><a href="#适配器模式种类" class="headerlink" title="适配器模式种类"></a>适配器模式种类</h2><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>Adapter类通过继承 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejsp89oxxj30ze0bqaft.jpg" style="zoom:50%;"><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//被适配类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Voltage220V</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//输出220V的电压</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> src <span class="token operator">=</span> <span class="token number">220</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"电压="</span> <span class="token operator">+</span> src <span class="token operator">+</span> <span class="token string">"伏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> src<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//目标接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IVoltage5V</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适配器类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoltageAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">Voltage220V</span> <span class="token keyword">implements</span> <span class="token class-name">IVoltage5V</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取到22QV电压</span>        <span class="token keyword">int</span> srcV <span class="token operator">=</span> <span class="token function">output220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dstV <span class="token operator">=</span> srcV <span class="token operator">/</span> <span class="token number">44</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//转成5V使用</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配器转换成功!输出电压为"</span> <span class="token operator">+</span> dstV <span class="token operator">+</span> <span class="token string">"伏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> dstV<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//充电</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">charging</span><span class="token punctuation">(</span>IVoltage5V iVoltage5V<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>iVoltage5V<span class="token punctuation">.</span><span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"电压为5V,可以充电~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>iVoltage5V<span class="token punctuation">.</span><span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"电压大于5V,不能充电~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===类适配器模式==="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone<span class="token punctuation">.</span><span class="token function">charging</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VoltageAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果：</span><span class="token comment" spellcheck="true">//===类适配器模式===</span><span class="token comment" spellcheck="true">//电压=220伏</span><span class="token comment" spellcheck="true">//适配器转换成功!输出电压为5伏</span><span class="token comment" spellcheck="true">//电压为5V,可以充电~~</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="类适配器的注意事项"><a href="#类适配器的注意事项" class="headerlink" title="类适配器的注意事项"></a>类适配器的注意事项</h4><ol><li>Java是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点，因为这要求 dst 必须是接口，有一定局限性。</li><li>src 类的方法在 Adapter 中<strong>都</strong>会暴露出来，也增加了使用的成本。</li><li>由于其继承了 src 类，所以它可以根据需求重写 src 类的方法，使得Adapter的灵活性增强了。</li></ol><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><ol><li><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，<strong>不是继承src类，而是持有src类的实例</strong>，以解决兼容性的问题。</p><p>即：持有 src 类，实现 dst 类接口，完成 src-&gt;dst 的适配。</p></li><li><p>根据“合成复用原则”，在系统中<strong>尽量使用关联关系来替代继承关系</strong>。</p></li><li><p><strong>对象适配器模式是适配器模式常用的一种。</strong></p></li></ol><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejt94q6vej315c0eoguf.jpg" style="zoom:50%;"><p><strong>在类适配器模式的基础上需要改进的代码</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//适配器类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoltageAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">IVoltage5V</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Voltage220V voltage220V<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关联关系-聚合</span>    <span class="token comment" spellcheck="true">//通过构造器，传入一个 Voltage220V 实例</span>    <span class="token keyword">public</span> <span class="token function">VoltageAdapter</span><span class="token punctuation">(</span>Voltage220V voltage220V<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>voltage220V <span class="token operator">=</span> voltage220V<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dstV <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> voltage220V<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> srcV <span class="token operator">=</span> voltage220V<span class="token punctuation">.</span><span class="token function">output220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取220V电压</span>            dstV <span class="token operator">=</span> srcV <span class="token operator">/</span> <span class="token number">44</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配器转换成功!输出电压为5伏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dstV<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===对象适配器模式==="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Phone phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone<span class="token punctuation">.</span><span class="token function">charging</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">VoltageAdapter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Voltage220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="对象适配器的注意事项"><a href="#对象适配器的注意事项" class="headerlink" title="对象适配器的注意事项"></a>对象适配器的注意事项</h4><ol><li>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。</li><li>根据合成复用原则，使用<strong>聚合替代继承</strong>，所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口。</li><li>使用成本更低，更灵活。</li></ol><h3 id="接口适配器模式"><a href="#接口适配器模式" class="headerlink" title="接口适配器模式"></a>接口适配器模式</h3><ol><li>一些书籍称把接口适配器模式(Default Adapter Pattern)称为缺省适配器模式。</li><li><strong>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口</strong>，并为该接口中每个方法提供一个<strong>默认实现(空方法)</strong>，那么该抽象类的<strong>子类可有选择地覆盖父类的某些方法</strong>来实现需求。</li><li>适用于一个接口不想使用其所有的方法的情况。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InterfaceDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbsAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">InterfaceDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//匿名内部类</span>        AbsAdapter absAdapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbsAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用了method1方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        absAdapter<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="适配器模式的应用"><a href="#适配器模式的应用" class="headerlink" title="适配器模式的应用"></a>适配器模式的应用</h2><h3 id="适配器在SpringMVC中的应用"><a href="#适配器在SpringMVC中的应用" class="headerlink" title="适配器在SpringMVC中的应用"></a>适配器在SpringMVC中的应用</h3><p>SpringMVC中的<strong>HandlerAdapter</strong>就使用了适配器模式。</p><p><strong>为什么使用HandlerAdapter？</strong></p><p>由于处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用Controller方法，需要调用的时候就得不断是使用 if else 来进行判断是哪一种类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。</p><p><strong>如何使用适配器？</strong></p><ul><li>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类。</li><li>适配器代替controller执行相应的方法扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</li></ul><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejy5xd5y8j313u0iwai7.jpg" style="zoom:50%;"><h3 id="适配器模式的注意事项"><a href="#适配器模式的注意事项" class="headerlink" title="适配器模式的注意事项"></a>适配器模式的注意事项</h3><ol><li>三种命名方式是根据 src 是以怎样的形式给到 Adapter (在Adapter里的形式)来命名的。<ul><li>类适配器：以类的方式给到，在Adapter里， 就是将 src 当做类，<strong>继承</strong></li><li>对象适配器：以对象的方式给到，在Adapter里，将 src 作为一个对象，<strong>持有</strong></li><li>接口适配器：以接口的方式给到，在Adapter里， 将 src 作为一个接口，<strong>实现</strong></li></ul></li><li>Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。</li><li>实际开发中，实现起来不拘泥于这三种经典形式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> adapter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式-State Pattern</title>
      <link href="/2019/12/04/state/"/>
      <url>/2019/12/04/state/</url>
      
        <content type="html"><![CDATA[<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>状态模式(State Pattern)：它主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是一一对应的，状态之间可以相互转换当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。</p><h3 id="状态模式的角色"><a href="#状态模式的角色" class="headerlink" title="状态模式的角色"></a>状态模式的角色</h3><ol><li>Context类为环境角色，用于维护State实例，这个实例定义当前状态。</li><li>State是抽象状态角色，定义一个接口封装与Context的一个特定接口相关行为。</li><li>ConcreteState具体的状态角色，每个子类实现一个与Context的一个状态相关行为。</li></ol><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/007S8ZIlgy1gekxxiypmuj31620gq14o.jpg" style="zoom:50%;"><h3 id="抽奖实例代码"><a href="#抽奖实例代码" class="headerlink" title="抽奖实例代码"></a>抽奖实例代码</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 状态接口 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 扣除积分</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deductMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否抽中奖品</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//发放奖品</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispensePrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽奖活动 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RaffleActivity</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//表示活动当前的状态,是变化的</span>    State state <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//表示奖品的数量</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//四种状态</span>    State noRaffleState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NoRaffleState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    State canRaffleState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CanRaffleState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    State disPenseState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispenseState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    State disPenseOutState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DispenseOutState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化当前的状态为不可抽奖状态和奖品数量</span>    <span class="token keyword">public</span> <span class="token function">RaffleActivity</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token function">getNoRaffleState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//扣积分</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">debuctMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        state<span class="token punctuation">.</span><span class="token function">deductMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//抽奖</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果当前的状态是抽奖成功</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//领取奖品</span>            state<span class="token punctuation">.</span><span class="token function">dispensePrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//省略state以及四种状态的get()set()...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 初始状态,不能抽奖 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NoRaffleState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    RaffleActivity activity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NoRaffleState</span><span class="token punctuation">(</span>RaffleActivity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>activity <span class="token operator">=</span> activity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当前状态可以扣积分，扣除后，将状态设置成可以抽奖状态</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deductMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"扣除50积分成功,您可以抽奖了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        activity<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>activity<span class="token punctuation">.</span><span class="token function">getCanRaffleState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当前状态不能抽奖</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"扣除积分后才能抽奖喔~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当前状态不能发放奖品</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispensePrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"还没抽奖,不能发放奖品"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 可以抽奖的状态 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CanRaffleState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    RaffleActivity activity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CanRaffleState</span><span class="token punctuation">(</span>RaffleActivity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>activity <span class="token operator">=</span> activity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当前状态已经扣除了积分,不需要重复扣</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deductMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经扣除过积分!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当前状态可以抽奖</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"正在抽奖,请稍等..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//随机数为0即中奖,10%的中奖机会</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//改变活动状态为发放奖品</span>            activity<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>activity<span class="token punctuation">.</span><span class="token function">getDisPenseState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"很遗憾您没有抽中奖品~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//改变活动状态为不能抽奖</span>            activity<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>activity<span class="token punctuation">.</span><span class="token function">getNoRaffleState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//当前状态不知道抽奖结果</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispensePrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有中奖,不能发放奖品!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 发放奖品状态 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispenseState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    RaffleActivity activity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DispenseState</span><span class="token punctuation">(</span>RaffleActivity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>activity <span class="token operator">=</span> activity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deductMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不能扣除积分"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不能抽奖"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//发放奖品</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispensePrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> curCount <span class="token operator">=</span> activity<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>curCount <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"恭喜您中奖了!!!===(＾－＾)V=== ❤ ===(๑•̀ㅂ•́)و✧==="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//省略发放奖品代码,跳转到初始没积分不能抽奖状态</span>            activity<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>activity<span class="token punctuation">.</span><span class="token function">getNoRaffleState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>curCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//activity.setState(activity.getDisPenseOutState());</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"奖品发放完毕,活动结束!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 奖品发送完毕状态,抽奖活动结束 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispenseOutState</span> <span class="token keyword">implements</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    RaffleActivity activity<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DispenseOutState</span><span class="token punctuation">(</span>RaffleActivity activity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>activity <span class="token operator">=</span> activity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deductMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"扣除积分失败,奖品已经发送完了,请您下次再来参加,谢谢~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不能参与抽奖,奖品已经发送完了,请您下次再来参加,谢谢~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispensePrize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"奖品已经发送完了,请您下次再来参加,谢谢~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RaffleActivity activity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RaffleActivity</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------------第"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"次抽奖------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            activity<span class="token punctuation">.</span><span class="token function">debuctMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            activity<span class="token punctuation">.</span><span class="token function">raffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="状态模式的注意事项"><a href="#状态模式的注意事项" class="headerlink" title="状态模式的注意事项"></a>状态模式的注意事项</h3><ol><li><strong>代码有很强的可读性</strong>。状态模式将每个状态的行为封装到对应的一个类中。</li><li><strong>方便维护</strong>。将容易产生问题的 if-else 语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时都要判断当前是什么状态，不但会产出很多 if-else 语句，而且容易出错。</li><li><strong>符合“开闭原则”</strong>。方便增删状态。</li><li>会产生很多类。每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度。</li><li>当一个事件或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候，可以考虑使用状态模式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> state </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式-Factory Pattern</title>
      <link href="/2019/12/02/factory/"/>
      <url>/2019/12/02/factory/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><h3 id="工厂模式种类"><a href="#工厂模式种类" class="headerlink" title="工厂模式种类"></a>工厂模式种类</h3><p>根据抽象程度分为三种：</p><ul><li>简单工厂模式（也叫静态工厂模式）</li><li>工厂方法模式（也叫多形性工厂）</li><li>抽象工厂模式（也叫工具箱）</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。</p><p><strong>工厂方法模式应该在实际中用的较多，我们以工厂方法模式举例（例子来源百度，帮助理解）</strong></p><p>抽象的产品类：定义car 交通工具类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">gotowork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bike</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">gotowork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"骑自行车去上班！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bus</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">gotowork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"坐公交车去上班！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义抽象的工厂接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICarFactory</span> <span class="token punctuation">{</span>    Car <span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BikeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ICarFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Car <span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BusFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ICarFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Car <span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单的测试类，来验证不同的工厂能够产生不同的产品对象</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ICarFactory factory <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// bike</span>        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BikeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Car bike <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bike<span class="token punctuation">.</span><span class="token function">gotowork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// bus</span>        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BusFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Car bus <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getCar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bus<span class="token punctuation">.</span><span class="token function">gotowork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="工厂模式优缺点"><a href="#工厂模式优缺点" class="headerlink" title="工厂模式优缺点"></a>工厂模式优缺点</h2><h3 id="工厂模式的优点"><a href="#工厂模式的优点" class="headerlink" title="工厂模式的优点"></a>工厂模式的优点</h3><p>1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。</p><p>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。</p><p>3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><h3 id="工厂模式的缺点"><a href="#工厂模式的缺点" class="headerlink" title="工厂模式的缺点"></a>工厂模式的缺点</h3><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。</p><h2 id="工厂模式的适用场景"><a href="#工厂模式的适用场景" class="headerlink" title="工厂模式的适用场景"></a>工厂模式的适用场景</h2><p>1， 一个对象拥有很多子类。</p><p>2， 创建某个对象时需要进行许多额外的操作。</p><p>3， 系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。</p><h2 id="工厂模式常见问题"><a href="#工厂模式常见问题" class="headerlink" title="工厂模式常见问题"></a>工厂模式常见问题</h2><p>利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？</p><p>把指向子类对象的父类引用赋给子类引用叫做向下转型，如：</p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span>     Person s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span>person <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。</p><p>但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。</p><h2 id="工厂模式小结"><a href="#工厂模式小结" class="headerlink" title="工厂模式小结"></a>工厂模式小结</h2><p>无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> factory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES对称加密算法</title>
      <link href="/2019/11/05/AES/"/>
      <url>/2019/11/05/AES/</url>
      
        <content type="html"><![CDATA[<h2 id="AES算法的特点"><a href="#AES算法的特点" class="headerlink" title="AES算法的特点"></a>AES算法的特点</h2><p>AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客<a href="http://www.lishaojie.top/2019/07/04/MD5/" target="_blank" rel="noopener">《MD5底层实现和解密方法》</a>所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用<strong>同一个密钥</strong>。AES支持三种长度的密钥：<strong>128位，192位，256位</strong>。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。</p><p>从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。<a id="more"></a></p><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。</p><p>假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行<strong>填充</strong>（Padding）。</p><h4 id="NoPadding"><a href="#NoPadding" class="headerlink" title="NoPadding"></a>NoPadding</h4><p>不做任何填充，但是要求明文必须是16字节的整数倍。</p><h4 id="PKCS5Padding（默认）"><a href="#PKCS5Padding（默认）" class="headerlink" title="PKCS5Padding（默认）"></a>PKCS5Padding（默认）</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p><h4 id="ISO10126Padding"><a href="#ISO10126Padding" class="headerlink" title="ISO10126Padding"></a>ISO10126Padding</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}</p><p><strong>注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</strong></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。</p><h4 id="ECB模式（默认）"><a href="#ECB模式（默认）" class="headerlink" title="ECB模式（默认）"></a>ECB模式（默认）</h4><p>电码本模式  Electronic Codebook Book</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg" alt></p><p>ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。</p><h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>密码分组链接模式  Cipher Block Chaining</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg" alt></p><p>CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它<strong>前一个明文块所加密出的密文块</strong>相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。</p><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计算器模式  Counter（实现省略……）</p><h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>密码反馈模式  Cipher FeedBack（实现省略……）</p><h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>输出反馈模式  Output FeedBack（实现省略……）</p><p><strong>注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。</strong></p><p>在Java代码中，如何修改不同长度的密钥和填充模式？</p><p>AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg" alt></p><ol><li>kgen.init传入的第一个参数128决定了密钥的长度是<strong>128bit</strong>。</li><li>Cipher.getInstance(“AES/CBC/NoPadding”)决定了AES选择的填充方式是<strong>NoPadding</strong>，工作模式是<strong>CBC</strong>模式。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。</li><li>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</li></ol><h2 id="AES加密算法底层原理"><a href="#AES加密算法底层原理" class="headerlink" title="AES加密算法底层原理"></a>AES加密算法底层原理</h2><h3 id="AES加密步骤"><a href="#AES加密步骤" class="headerlink" title="AES加密步骤"></a>AES加密步骤</h3><ol><li>把明文按照128bit拆分成若干个明文块。</li><li>按照选择的填充方式来填充最后一个明文块。</li><li>每一个明文块利用AES加密器和密钥，加密成密文块。</li><li>拼接所有的密文块，成为最终的密文结果。</li></ol><h3 id="AES加密器需要经过多少轮加密"><a href="#AES加密器需要经过多少轮加密" class="headerlink" title="AES加密器需要经过多少轮加密"></a>AES加密器需要经过多少轮加密</h3><ul><li>初始轮（Initial Round） 1次</li><li>普通轮（Rounds）     N次</li><li>最终轮（Final Round）  1次</li></ul><p>上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。</p><h3 id="除去初始轮各种Key长度对应的轮数"><a href="#除去初始轮各种Key长度对应的轮数" class="headerlink" title="除去初始轮各种Key长度对应的轮数"></a>除去初始轮各种Key长度对应的轮数</h3><ul><li>AES128：10轮</li><li>AES192：12轮</li><li>AES256：14轮</li></ul><h3 id="不同阶段Round的处理步骤"><a href="#不同阶段Round的处理步骤" class="headerlink" title="不同阶段Round的处理步骤"></a>不同阶段Round的处理步骤</h3><p><strong>初始轮只有一个步骤</strong></p><ul><li>加轮密钥（AddRoundKey）</li></ul><p><strong>普通轮有四个步骤</strong></p><ul><li><p>字节代替（SubBytes）</p><p>首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为<strong>S盒</strong>（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。</p></li><li><p>行移位（ShiftRows）</p><p>这一步很简单，就像图中所描述的：第一行不变，第二行循环左移<strong>1</strong>个字节，第三行循环左移<strong>2</strong>个字节，第四行循环左移<strong>3</strong>个字节。</p></li><li><p>列混淆（MixColumns）</p><p>这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。</p></li><li><p>加轮密钥（AddRoundKey）</p><p>这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：<strong>扩展密钥</strong>（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ……一直到W{160-175}用于最终轮（第10轮）的处理。</p></li></ul><p><strong>最终轮有三个步骤</strong></p><ul><li>字节代替（SubBytes）</li><li>行移位（ShiftRows）</li><li>加轮密钥（AddRoundKey）</li></ul><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p>解密流程基本是把加密流程倒置过来，顺序变为 最终轮-&gt;普通轮-&gt;初始轮。扩展密钥的使用顺序也和加密相反。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> AES算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密算法</title>
      <link href="/2019/11/03/encryption/"/>
      <url>/2019/11/03/encryption/</url>
      
        <content type="html"><![CDATA[<h2 id="加密算法的种类"><a href="#加密算法的种类" class="headerlink" title="加密算法的种类"></a>加密算法的种类</h2><p>从宏观上来看，加密算法可以归结为三大类：<strong>哈希算法、对称加密算法、非对称加密算法。</strong></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从严格意义上来说，<strong>哈希算法并不属于加密算法</strong>，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是<strong>生成信息摘要</strong>，用以验证原信息的完整性和来源的可靠性。</p><p>举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，<strong>Hash（1234_100_abc） = 948569CD3466451F</strong>）<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg" alt></p><p>请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。</p><p>生成信息摘要的过程叫做<strong>签名</strong>，验证信息摘要的过程叫做<strong>验签</strong>。</p><p>哈希算法最著名的当属<strong>MD5算法</strong>。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了<strong>SHA系列算法</strong>。</p><hr><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。</p><h3 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg" alt></p><p>如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。</p><p>除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。</p><h3 id="对称加密包含哪些算法？"><a href="#对称加密包含哪些算法？" class="headerlink" title="对称加密包含哪些算法？"></a>对称加密包含哪些算法？</h3><p>在早期，人们使用<strong>DES算法</strong>进行加密解密；后来，人们觉得DES不够安全，发明了<strong>3DES</strong>算法；而如今，最为流行的对称加密算法是<strong>AES算法</strong>。</p><h3 id="对称加密的优缺点"><a href="#对称加密的优缺点" class="headerlink" title="对称加密的优缺点"></a>对称加密的优缺点</h3><p>对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。</p><hr><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg" alt></p><p>如图所示，在非对称加密中存在一对密钥，一个叫做<strong>公钥</strong>，另一个叫做<strong>私钥</strong>。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属<strong>RSA算法</strong>。</p><h3 id="非对称加密的通信过程"><a href="#非对称加密的通信过程" class="headerlink" title="非对称加密的通信过程"></a>非对称加密的通信过程</h3><ol><li>在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。</li><li>客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。</li><li>服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。</li><li>从此以后，双方可以利用密钥X进行对称加密的通信了。</li></ol><h3 id="非对称加密的优缺点"><a href="#非对称加密的优缺点" class="headerlink" title="非对称加密的优缺点"></a>非对称加密的优缺点</h3><p>好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。</p><p>缺点是性能较差，无法应用于长期的通信。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5加密的底层实现和破解</title>
      <link href="/2019/11/03/MD5/"/>
      <url>/2019/11/03/MD5/</url>
      
        <content type="html"><![CDATA[<h2 id="信息摘要技术"><a href="#信息摘要技术" class="headerlink" title="信息摘要技术"></a>信息摘要技术</h2><p>信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。</p><p>MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。</p><h2 id="摘要哈希的生成过程"><a href="#摘要哈希的生成过程" class="headerlink" title="摘要哈希的生成过程"></a>摘要哈希的生成过程</h2><ol><li>收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</li><li>按照规则，把参数名和参数值拼接成一个字符串，同时把给定的<strong>密钥</strong>也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</li><li>利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。<a id="more"></a></li></ol><h2 id="第三方支付平台验证签名"><a href="#第三方支付平台验证签名" class="headerlink" title="第三方支付平台验证签名"></a>第三方支付平台验证签名</h2><ol><li>发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。</li><li>第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。</li><li>用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做<strong>验签</strong>。</li></ol><h2 id="MD5算法底层实现原理"><a href="#MD5算法底层实现原理" class="headerlink" title="MD5算法底层实现原理"></a>MD5算法底层实现原理</h2><p>简单概括起来，MD5算法的过程分为四步：</p><ol><li><p>处理原文</p><p>首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。</p></li><li><p>设置初始值</p><p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p><p>A=0x01234567</p><p>B=0x89ABCDEF</p><p>C=0xFEDCBA98</p><p>D=0x76543210</p></li><li><p>循环加工</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg" alt></p><p>图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = <strong>M / 512</strong>，每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。上面这张图所表达的就是<strong>单次子循环</strong>的流程。下面对图中其他元素一一解释：</p><p><strong>1.绿色F</strong></p><p>图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：</p><p>F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</p><p>G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</p><p>H(X, Y, Z) =X^Y^Z</p><p>I(X, Y, Z)=Y^(X|(~Z))</p><p>在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。</p><p><strong>2.红色“田”字</strong></p><p>很简单，红色的田字代表相加的意思。</p><p><strong>3.Mi</strong></p><p>Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0<del>M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1</del>M16之一。</p><p><strong>4.Ki</strong></p><p>一个常量，在64次子循环中，每一次用到的常量都是不同的。</p><p><strong>5.黄色的&lt;&lt;</strong></p><p>左移S位，S的值也是常量。</p></li><li><p>拼接结果</p><p>这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。</p></li></ol><hr><h2 id="MD5破解"><a href="#MD5破解" class="headerlink" title="MD5破解"></a>MD5破解</h2><p>这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。</p><p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。</p><h3 id="MD5碰撞方法"><a href="#MD5碰撞方法" class="headerlink" title="MD5碰撞方法"></a>MD5碰撞方法</h3><h4 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h4><p>顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。</p><h4 id="字典法"><a href="#字典法" class="headerlink" title="字典法"></a>字典法</h4><p>如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。</p><h4 id="彩虹表法"><a href="#彩虹表法" class="headerlink" title="彩虹表法"></a>彩虹表法</h4><p>彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：<strong>彩虹表</strong>。</p><p>彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。</p><h4 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h4><p>2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> MD5算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存-Redis</title>
      <link href="/2019/10/22/redis/"/>
      <url>/2019/10/22/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis单线程模型原理剖析？"><a href="#redis单线程模型原理剖析？" class="headerlink" title="redis单线程模型原理剖析？"></a>redis单线程模型原理剖析？</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p><h2 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h2><ol><li>纯内存操作。</li><li>核心是基于非阻塞的IO多路复用机制。</li><li>单线程——避免了多线程的频繁上下文切换问题。</li><li>Resp协议。<a id="more"></a></li></ol><h2 id="使用redis有什么缺点？"><a href="#使用redis有什么缺点？" class="headerlink" title="使用redis有什么缺点？"></a>使用redis有什么缺点？</h2><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩、缓存击穿</li><li>缓存的并发竞争</li></ul><h2 id="redis支持的数据类型和使用场景"><a href="#redis支持的数据类型和使用场景" class="headerlink" title="redis支持的数据类型和使用场景"></a>redis支持的数据类型和使用场景</h2><ol><li><p>string</p><p>最基本的类型，普通的set和get，做简单的key-value缓存。</p></li><li><p>hash</p><p>类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。</p></li><li><p>list</p><p>有序列表，这个是可以玩出很多花样的：</p><p>比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。</p><p>还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。</p></li><li><p>set</p><p>无序集合，自动去重。</p><p>如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。</p><p>还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。</p></li><li><p>sorted set</p><p>有序集合，自动去重。</p><p>这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。</p><p>比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。</p><p>排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。</p><p>zadd board 85 jack</p><p>zadd board 72 tom</p><p>zadd board 96 jerry</p><p>zrevrange board 0 2：可以查看前三名的排序结果</p><p>zrank board tom：返回3，意思是tom排名第3</p></li></ol><h2 id="redis的过期策略有哪些"><a href="#redis的过期策略有哪些" class="headerlink" title="redis的过期策略有哪些"></a>redis的过期策略有哪些</h2><p><strong>定期删除+惰性删除</strong></p><p>所谓<strong>定期删除</strong>，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。</p><p>所谓<strong>惰性删除</strong>，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。</p><p>产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走<strong>内存淘汰机制</strong>了。</p><ol><li>no-enviction（驱逐）：禁止驱逐数据，再写入会报错。<strong>（默认，应该没人用）</strong></li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。<strong>（推荐使用）</strong></li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从<code>已设置过期时间的</code>数据集中挑选<code>将要过期的</code>数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li></ol><h2 id="怎么保证redis的高并发-amp-高可用？"><a href="#怎么保证redis的高并发-amp-高可用？" class="headerlink" title="怎么保证redis的高并发&amp;高可用？"></a>怎么保证redis的高并发&amp;高可用？</h2><p>redis高并发：采用<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。</p><p>redis高可用：如果做主从架构部署，其实加上<strong>哨兵</strong>就可以了，任何一个实例宕机，都会自动切换。</p><h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑10+的<strong>读QPS</strong></p><p>首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 </p><h4 id="主从复制的核心原理"><a href="#主从复制的核心原理" class="headerlink" title="主从复制的核心原理"></a>主从复制的核心原理</h4><p>当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行<strong>增量复制</strong>，如果这是slave第一次连接master，会触发一次<strong>全量复制</strong>。</p><p>官方解释：</p><ol><li>slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。</li><li>slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。</li><li>slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。</li><li>master第一次执行全量复制，将所有数据发送给slave。</li><li>master后续还会持续将写命令异步发送给slave。</li></ol><p>全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。</p><p>增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。</p><h4 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h4><p>从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。</p><p>官方解释：</p><ol><li>master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。</li><li>master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。</li><li>master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。</li><li>从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。</li></ol><h4 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h4><p>在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。</p><h4 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h4><p>slave不会过期key，只会等待master过期key。</p><p>如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。</p><h4 id="redis的心跳检测机制"><a href="#redis的心跳检测机制" class="headerlink" title="redis的心跳检测机制"></a>redis的心跳检测机制</h4><p>在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。</p><h4 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h4><p>如果采用了主从架构，建议必须开启master node的持久化。</p><p>不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。</p><p>即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。</p><p><strong>持久化方式RDB和AOF</strong></p><ul><li>RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。</li><li>AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。</li></ul><p>如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。</p><p>如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。</p><p><strong>RDB的优点</strong></p><ol><li>RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。</li><li>RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。</li><li>通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。</li></ol><p><strong>RDB的缺点</strong></p><ol><li>最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。</li><li>RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。</li></ol><p><strong>AOF的优点</strong></p><ol><li>AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。</li><li>AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。</li><li>AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。</li><li>AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。</li></ol><p><strong>AOF的缺点</strong></p><ol><li>最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。</li><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li><li>AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。</li><li>如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。</li><li>AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。</li></ol><p><strong>RDB和AOF到底如何选择</strong></p><ul><li>不要仅仅使用RDB，因为那样会导致丢失很多数据。</li><li>也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。</li><li>所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。</li></ul><hr><h3 id="redis的哨兵机制"><a href="#redis的哨兵机制" class="headerlink" title="redis的哨兵机制"></a>redis的哨兵机制</h3><p>sentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：</p><ol><li>集群监控：负责监控redis master和slave进程是否正常工作。</li><li>消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。</li><li>故障转移：如果master挂掉了，会自动转移到slave上。</li><li>配置中心：如果故障转移发生了，把新的master地址通知到客户端。</li></ol><p>哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。</p><ol><li>故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。</li></ol><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ol><li>哨兵至少需要3个实例，来保证自己的健壮性。</li><li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。</li><li>对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。</li></ol><p><strong>为什么redis哨兵集群少于3个节点无法正常工作</strong></p><p>如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。</p><h4 id="sdown和odown转换机制？"><a href="#sdown和odown转换机制？" class="headerlink" title="sdown和odown转换机制？"></a>sdown和odown转换机制？</h4><p>master宕机有sdown和odown两种失败状态</p><ul><li>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。</li><li>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。</li><li>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了</li><li>sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。</li></ul><h4 id="哨兵和slave集群的自动发现机制"><a href="#哨兵和slave集群的自动发现机制" class="headerlink" title="哨兵和slave集群的自动发现机制"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往_sentinel_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的_sentinel_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p><h4 id="slave-master选举算法"><a href="#slave-master选举算法" class="headerlink" title="slave-master选举算法"></a>slave-master选举算法</h4><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。</p><p><strong>从节点过滤</strong>：判断跟master断开连接的时长</p><p>如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。</p><ol><li>slave配置的优先级（slave-priority=100）</li><li>复制offset</li><li>run id</li></ol><p>说明：</p><ol><li>然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。</li><li>如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li></ol><h4 id="slave配置的自动纠正"><a href="#slave配置的自动纠正" class="headerlink" title="slave配置的自动纠正"></a>slave配置的自动纠正</h4><p>哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。</p><h4 id="quorum和majority"><a href="#quorum和majority" class="headerlink" title="quorum和majority"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。</p><p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。</p><p>如果quorum &gt;= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。</p><h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><p>哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。</p><h4 id="configuration传播"><a href="#configuration传播" class="headerlink" title="configuration传播"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。</p><p>这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p><h2 id="异步复制和集群脑裂导致数据丢失"><a href="#异步复制和集群脑裂导致数据丢失" class="headerlink" title="异步复制和集群脑裂导致数据丢失"></a>异步复制和集群脑裂导致数据丢失</h2><p>场景一：异步复制导致的数据丢失</p><p>client往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。</p><p>场景二：集群脑裂导致的数据丢失</p><p>master出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。</p><p><strong>如何降低损失？</strong></p><ul><li>min-slaves-to-write 1</li><li>min-slaves-max-lag 10</li></ul><p>配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。</p><p>上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。</p><h2 id="分布式集群-redis-cluster"><a href="#分布式集群-redis-cluster" class="headerlink" title="分布式集群-redis cluster"></a>分布式集群-redis cluster</h2><ol><li>自动将数据进行分片，每个master上放一部分数据。</li><li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的。</li></ol><p>redis cluster可以突破单机redis在海量数据面前的瓶颈。</p><p><strong>redis cluster VS replication+sentinal</strong></p><p>如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。</p><h3 id="分布式数据存储的核心算法"><a href="#分布式数据存储的核心算法" class="headerlink" title="分布式数据存储的核心算法"></a>分布式数据存储的核心算法</h3><h4 id="最老土的hash算法和弊端"><a href="#最老土的hash算法和弊端" class="headerlink" title="最老土的hash算法和弊端"></a>最老土的hash算法和弊端</h4><p>把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到<strong>大量的缓存重建</strong>，这是致命的。</p><h4 id="一致性hash算法-自动缓存迁移"><a href="#一致性hash算法-自动缓存迁移" class="headerlink" title="一致性hash算法(自动缓存迁移)"></a>一致性hash算法(自动缓存迁移)</h4><p>有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。</p><h4 id="一致性hash算法-虚拟节点"><a href="#一致性hash算法-虚拟节点" class="headerlink" title="一致性hash算法+虚拟节点"></a>一致性hash算法+虚拟节点</h4><p>基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的<strong>负载均衡</strong>。</p><h4 id="hash-slot算法"><a href="#hash-slot算法" class="headerlink" title="hash slot算法"></a>hash slot算法</h4><p>redis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。</p><hr><h3 id="redis集群模式的工作原理"><a href="#redis集群模式的工作原理" class="headerlink" title="redis集群模式的工作原理"></a>redis集群模式的工作原理</h3><h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p><strong>基础通信原理</strong></p><p>redis cluster节点间采用<strong>gossip</strong>协议进行通信。</p><p>跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。</p><ul><li>集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。</li><li>gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。</li></ul><p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。</p><p><strong>gossip协议</strong></p><p>gossip协议包含多种消息，包括ping、pong、meet、fail等。</p><ul><li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。</li><li>ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。</li><li>pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。</li><li>fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li></ul><p><strong>ping消息深入</strong></p><p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。</p><hr><p>jedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -&gt; node的映射表缓存。</p><h4 id="高性能与主备切换原理"><a href="#高性能与主备切换原理" class="headerlink" title="高性能与主备切换原理"></a>高性能与主备切换原理</h4><p>redis cluster的高可用原理，几乎和哨兵是一样的。</p><ol><li><p>判断节点宕机</p><p>如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。</p></li><li><p>从节点过滤</p><p>对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。</p></li><li><p>master选举</p><p>每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。</p></li></ol><p>综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。</p><h2 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：指在某一时间段，缓存集体失效。</p><h4 id="造成缓存雪崩的原因"><a href="#造成缓存雪崩的原因" class="headerlink" title="造成缓存雪崩的原因"></a>造成缓存雪崩的原因</h4><ol><li>比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。</li><li>缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</li></ol><h4 id="如何预防缓存雪崩？"><a href="#如何预防缓存雪崩？" class="headerlink" title="如何预防缓存雪崩？"></a>如何预防缓存雪崩？</h4><p>针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p><p>针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。</p><h4 id="缓存雪崩了如何恢复？"><a href="#缓存雪崩了如何恢复？" class="headerlink" title="缓存雪崩了如何恢复？"></a>缓存雪崩了如何恢复？</h4><p>本地ehcache缓存+hystrix限流&amp;降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。</p><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。</p><h4 id="造成缓存穿透的原因"><a href="#造成缓存穿透的原因" class="headerlink" title="造成缓存穿透的原因"></a>造成缓存穿透的原因</h4><p>代码bug或者恶意攻击。</p><h4 id="如何预防缓存穿透？"><a href="#如何预防缓存穿透？" class="headerlink" title="如何预防缓存穿透？"></a>如何预防缓存穿透？</h4><p>如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p><hr><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><h3 id="如何预防缓存击穿？"><a href="#如何预防缓存击穿？" class="headerlink" title="如何预防缓存击穿？"></a>如何预防缓存击穿？</h3><p>这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。</p><h2 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性"></a>如何保证缓存与数据库的双写一致性</h2><h3 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h3><p>最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）</p><ol><li>读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。</li><li>更新的时候，<strong>先删除缓存，再更新数据库</strong>，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。</li></ol><p>为什么是删除缓存，而不是更新缓存呢？</p><p>原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。</p><p>其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。</p><hr><h3 id="高并发场景下的数据不一致"><a href="#高并发场景下的数据不一致" class="headerlink" title="高并发场景下的数据不一致"></a>高并发场景下的数据不一致</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>把数据库与缓存的更新读取操作进行异步串行化。</p><ul><li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。</li><li>读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。</li></ul><p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p><p>这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。</p><h4 id="解决方案需要注意的问题"><a href="#解决方案需要注意的问题" class="headerlink" title="解决方案需要注意的问题"></a>解决方案需要注意的问题</h4><p><strong>读请求 长时间堵塞</strong></p><p>由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。</p><p>该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。</p><p><strong>读请求 并发量过高</strong></p><p>上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。</p><p><strong>多服务实例部署的请求路由</strong></p><p>可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。</p><p><strong>热点商品的路由问题</strong></p><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。</p><p>因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。</p><h2 id="如何保证redis并发竞争的数据一致性"><a href="#如何保证redis并发竞争的数据一致性" class="headerlink" title="如何保证redis并发竞争的数据一致性"></a>如何保证redis并发竞争的数据一致性</h2><ul><li><p>客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p></li><li><p>服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。</p></li></ul><h2 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li><strong>互斥性</strong>：在任意时刻，只有一个客户端能持有锁。</li><li><strong>不能死锁</strong>：可能会发生客户端在持有锁的期间崩溃而没有主动解锁，所以需要设置过期时间。</li><li><strong>容错性</strong>：只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以直接通过 <code>set key value px milliseconds nx</code> 命令实现加锁， 通过Lua脚本实现解锁。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取锁（unique_value可以是UUID等）PX毫秒｜EX秒</span>SET resource_name unique_value NX PX <span class="token number">30000</span><span class="token comment" spellcheck="true">//释放锁（lua脚本中，一定要比较value，防止误解锁）</span><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>代码解释</p><ul><li>set 命令要用 <code>set key value px milliseconds nx</code>，替代 <code>setnx + expire</code> 需要分两次执行命令的方式，保证了原子性；</li><li>value 要具有唯一性，可以使用<code>UUID.randomUUID().toString()</code>方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；</li><li>释放锁时要验证 value 值，防止误解锁；</li><li>通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；</li></ul></blockquote><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbrd45hm50j31gy0lekjl.jpg" alt></p><h3 id="加锁代码分析"><a href="#加锁代码分析" class="headerlink" title="加锁代码分析"></a>加锁代码分析</h3><p>首先，set加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。</p><h3 id="解锁代码分析"><a href="#解锁代码分析" class="headerlink" title="解锁代码分析"></a>解锁代码分析</h3><p>将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。</p><h3 id="存在的风险"><a href="#存在的风险" class="headerlink" title="存在的风险"></a>存在的风险</h3><ol><li>基于单点redis存在单点故障。</li><li>基于主从架构，如果master挂了，key还没同步到从节点，此时主从切换别人就会拿到锁。</li><li>基于redis cluster架构的分布式锁方案-RedLock算法，是redis官方支持的分布式锁算法。</li></ol><p>详细可查看：</p><blockquote><p><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">https://redis.io/topics/distlock</a></p></blockquote><h2 id="分布式锁的对比"><a href="#分布式锁的对比" class="headerlink" title="分布式锁的对比"></a>分布式锁的对比</h2><ol><li>redis分布式锁需要不断去尝试获取锁，比较耗性能。zk分布式锁获取不到锁注册个监听器即可。</li><li>redis获取锁的客户端挂了，只能等待超时之后再释放锁，zk是基于临时节点，挂了znode就没了，自动释放。</li><li>综上所述，推荐基于zk实现分布式锁，相对于redis更牢靠，且简单易用。</li></ol><blockquote><p>想获取更多关于zookeeper的知识可以访问：<a href="https://lishaojie1993.gitee.io/2018/06/03/zookeeper">https://lishaojie1993.gitee.io/2018/06/03/zookeeper</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表“逆序”算法</title>
      <link href="/2019/09/18/LinkedList-Reverse/"/>
      <url>/2019/09/18/LinkedList-Reverse/</url>
      
        <content type="html"><![CDATA[<h2 id="链表逆序算法"><a href="#链表逆序算法" class="headerlink" title="链表逆序算法"></a>链表逆序算法</h2><h3 id="逆序本质"><a href="#逆序本质" class="headerlink" title="逆序本质"></a>逆序本质</h3><p>链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。</li><li>以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>三个临时节点的引用分别向后移动一格位置。</li><li>重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>重复第3步的工作，三个临时节点分别向后移动一格位置。</li><li>继续这样迭代下去，直到p2是空为止。</li><li>最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。<a id="more"></a></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Node head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里head是静态成员，其实也可以作为方法参数传入</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>head<span class="token operator">==</span>null <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//算法实现</span>  Node p1 <span class="token operator">=</span> head<span class="token punctuation">;</span>  Node p2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  Node p3 <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>p2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    p3 <span class="token operator">=</span> p2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p3赋值</span>    p2<span class="token punctuation">.</span>next <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p2指向p1</span>    p1 <span class="token operator">=</span> p2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p1赋值</span>    p2 <span class="token operator">=</span> p3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给p2赋值</span>  <span class="token punctuation">}</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//head指向null</span>  head <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给head赋值</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义节点</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> data<span class="token punctuation">;</span>  Node next<span class="token punctuation">;</span>  <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//初始化链表</span>  head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//给头节点赋值</span>  head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//头节点的next指向新节点6</span>  Node temp <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//定义临时节点并赋值</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//临时节点的next指向新节点1</span>  temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//临时节点指针后移</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  temp<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出初始化的链表</span>  temp <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//调用逆序链表的方法</span>  <span class="token function">reverseLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出逆序后的链表</span>  temp <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判定字符是否唯一"><a href="#判定字符是否唯一" class="headerlink" title="判定字符是否唯一"></a>判定字符是否唯一</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isUnique</span><span class="token punctuation">(</span>String astr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>astr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>astr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> astr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表逆序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/09/16/Sort/"/>
      <url>/2019/09/16/Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h2><p>对一序列对象根据某个关键字进行排序。</p><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><ul><li><strong>稳定：</strong>如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定：</strong>如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序：</strong>所有排序操作都在内存中完成；</li><li><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong>一个算法执行所耗费的时间。</li><li><strong>空间复杂度：</strong>运行完一个程序所需内存的大小。<a id="more"></a></li></ul><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg" alt></p><h3 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p><p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。</p><p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><h3 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h3><p>计数排序、基数排序、桶排序则属于非比较排序。<strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</strong></p><p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p><p><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p><h2 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h2><h3 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h3><p>冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif" alt></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 冒泡排序     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="选择排序（不稳定）"><a href="#选择排序（不稳定）" class="headerlink" title="选择排序（不稳定）"></a>选择排序（不稳定）</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p><p>选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="过程演示-1"><a href="#过程演示-1" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif" alt></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 选择排序     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//找到最小的数</span>                    minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将最小数的索引保存</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n2) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><h4 id="过程演示-2"><a href="#过程演示-2" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif" alt></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 插入排序     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">int</span> current<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            current <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                preIndex<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最坏情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="希尔排序（不稳定）"><a href="#希尔排序（不稳定）" class="headerlink" title="希尔排序（不稳定）"></a>希尔排序（不稳定）</h3><p>希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="过程演示-3"><a href="#过程演示-3" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg" alt></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 希尔排序     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp<span class="token punctuation">,</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                    preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlog2 n) </li><li>最坏情况：T(n) = O(nlog2 n) </li><li>平均情况：T(n) =O(nlog2n)　</li></ul><hr><h3 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p><strong>归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</strong></p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="过程演示-4"><a href="#过程演示-4" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif" alt></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 归并排序     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">MergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 归并排序——将两段排序好的数组结合成一个排序数组     *     * @param left     * @param right     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最差情况：T(n) = O(nlogn) </li><li>平均情况：T(n) = O(nlogn)</li></ul><hr><h3 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h3><p>快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="过程演示-5"><a href="#过程演示-5" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif" alt></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 快速排序方法     * @param array     * @param start     * @param end     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">>=</span> array<span class="token punctuation">.</span>length <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> smallIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallIndex <span class="token operator">></span> start<span class="token punctuation">)</span>            <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> smallIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallIndex <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>            <span class="token function">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> smallIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 快速排序算法——partition     * @param array     * @param start     * @param end     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> smallIndex <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                smallIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> smallIndex<span class="token punctuation">)</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> smallIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token keyword">return</span> smallIndex<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换数组内两个元素     * @param array     * @param i     * @param j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(nlogn)　</li></ul><hr><h3 id="堆排序（不稳定）"><a href="#堆排序（不稳定）" class="headerlink" title="堆排序（不稳定）"></a>堆排序（不稳定）</h3><p>堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="过程演示-6"><a href="#过程演示-6" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif" alt></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//声明全局变量，用于记录数组array的长度；</span><span class="token keyword">static</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 堆排序算法     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//1.构建一个最大堆</span>        <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            len<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 建立最大堆     *     * @param array     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//从最后一个非叶子节点开始向上构造最大堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整使之成为最大堆     *     * @param array     * @param i     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxIndex <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxIndex <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> maxIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn) </li><li>最差情况：T(n) = O(nlogn) </li><li>平均情况：T(n) = O(nlogn)</li></ul><hr><h3 id="基数排序（稳定）"><a href="#基数排序（稳定）" class="headerlink" title="基数排序（稳定）"></a>基数排序（稳定）</h3><p>基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序(利用计数排序适用于小范围数的特点)；</li></ul><h4 id="过程演示-7"><a href="#过程演示-7" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif" alt></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 基数排序     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">RadixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> null <span class="token operator">||</span> array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.先算出最大数的位数；</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxDigit<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> bucketList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            bucketList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> div<span class="token punctuation">;</span>                bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                    array<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n * k) </li><li>最差情况：T(n) = O(n * k) </li><li>平均情况：T(n) = O(n * k)</li></ul><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序</li><li>LSD 从低位开始进行排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表的原理</title>
      <link href="/2019/08/27/Sub-table/"/>
      <url>/2019/08/27/Sub-table/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h2><ul><li><p>数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。</p></li><li><p>物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。</p><p>换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p><p>比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。<a id="more"></a></p></li></ul><hr><h2 id="如何进行分库分表？"><a href="#如何进行分库分表？" class="headerlink" title="如何进行分库分表？"></a>如何进行分库分表？</h2><h3 id="数据分表"><a href="#数据分表" class="headerlink" title="数据分表"></a>数据分表</h3><ul><li><p><strong>垂直分表</strong></p><p>根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。<strong>主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。</strong></p><p>垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。</p></li><li><p><strong>水平分表</strong></p><p>将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。</p><p>水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg" alt></p><h3 id="数据分库"><a href="#数据分库" class="headerlink" title="数据分库"></a>数据分库</h3><p>每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。</p><ul><li>根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。</li><li>根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。</li><li>根据访问数据的地域/时间范围进行分库。</li></ul><p><strong>range和hash的优缺点</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg" alt></p><p><strong>分库分表会遇到哪些问题</strong></p><ul><li><p>ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(“-“,””)，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。</p></li><li><p>Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。</p></li><li><p>排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。</p><ol><li><p>对分表的数据先进行排序/分页/聚合，再进行合并。</p></li><li><p>对分表的数据先进行合并再做排序/分页/聚合。</p></li></ol></li><li><p>事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。</p></li></ul><hr><h2 id="如何对数据库进行扩容？"><a href="#如何对数据库进行扩容？" class="headerlink" title="如何对数据库进行扩容？"></a>如何对数据库进行扩容？</h2><p>分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。</p><ul><li><p><strong>主从数据库扩容</strong></p><p>我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。</p><p>由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。</p><p>负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。</p><p>这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。</p><p>此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。</p></li><li><p><strong>双写数据库扩容</strong></p><p>在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。</p><p>这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。</p><p>与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。</p><p>当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。</p><p>当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。</p></li></ul><hr><h2 id="有哪些分库分表的中间件？"><a href="#有哪些分库分表的中间件？" class="headerlink" title="有哪些分库分表的中间件？"></a>有哪些分库分表的中间件？</h2><p><strong>sharding-jdbc 和 mycat</strong>。</p><p>sharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。</p><p>mycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。</p><h2 id="不同的中间件有什么优缺点？"><a href="#不同的中间件有什么优缺点？" class="headerlink" title="不同的中间件有什么优缺点？"></a>不同的中间件有什么优缺点？</h2><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg" alt></p><hr><h2 id="如何把单库单表的系统迁移到分库分表？"><a href="#如何把单库单表的系统迁移到分库分表？" class="headerlink" title="如何把单库单表的系统迁移到分库分表？"></a>如何把单库单表的系统迁移到分库分表？</h2><h3 id="停机迁移"><a href="#停机迁移" class="headerlink" title="停机迁移"></a>停机迁移</h3><p>发布公告，凌晨0点～2点维护系统，暂停使用。</p><p>数据迁移，修改配置，验证测试。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg" alt></p><h3 id="不停机双写迁移"><a href="#不停机双写迁移" class="headerlink" title="不停机双写迁移"></a>不停机双写迁移</h3><p>通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。</p><p>此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg" alt></p><hr><h2 id="分库分表以后ID主键如何处理？"><a href="#分库分表以后ID主键如何处理？" class="headerlink" title="分库分表以后ID主键如何处理？"></a>分库分表以后ID主键如何处理？</h2><p>推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。</p><p>其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg" alt></p><hr><h2 id="简述如何实现mysql的读写分离？"><a href="#简述如何实现mysql的读写分离？" class="headerlink" title="简述如何实现mysql的读写分离？"></a>简述如何实现mysql的读写分离？</h2><p>其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。</p><h2 id="mysql主从复制的原理？"><a href="#mysql主从复制的原理？" class="headerlink" title="mysql主从复制的原理？"></a>mysql主从复制的原理？</h2><ol><li>mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。</li><li>从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。</li><li>接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。</li></ol><p><strong>需要注意的问题（数据延迟和数据丢失）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg" alt></p><ol><li>从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。</li><li>由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。</li><li>如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。</li></ol><p><strong>如何解决？</strong></p><p>mysql在这一块有两个机制，一个是<strong>半同步复制</strong>，解决数据丢失问题。一个是<strong>并行复制</strong>，缓解数据延时问题。</p><ul><li>所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。</li><li>所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。</li></ul><p><strong>有没有更好的方法解决主从数据延时问题（重点）</strong></p><ol><li>分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。</li><li>重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。</li><li>如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>因为数据量的上升，为了提高性能会对系统进行分表分库。</li><li>从分表来说，有水平分表和垂直分表两种方式。</li><li>从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。</li><li>如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Sub-table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-MQ</title>
      <link href="/2019/08/19/MQ/"/>
      <url>/2019/08/19/MQ/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用消息队列？说说优缺点？"><a href="#为什么使用消息队列？说说优缺点？" class="headerlink" title="为什么使用消息队列？说说优缺点？"></a>为什么使用消息队列？说说优缺点？</h2><p>比较核心的使用场景有3个：<strong>解耦、异步、削峰</strong>。同样也是使用MQ的<strong>优点</strong>。</p><p><strong>解耦举例</strong>：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。</p><p>总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。<a id="more"></a></p><p><strong>异步举例</strong>：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。</p><p>总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。</p><p><strong>削峰举例</strong>：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。</p><p>总结：削峰可以缓解数据库压力，达到最终一致性。</p><p><strong>缺点</strong>：</p><ul><li>系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。</li><li>系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。</li><li>一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。</li></ul><hr><h2 id="不同消息中间件的区别以及适用场景？"><a href="#不同消息中间件的区别以及适用场景？" class="headerlink" title="不同消息中间件的区别以及适用场景？"></a>不同消息中间件的区别以及适用场景？</h2><ul><li>单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。</li><li>时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。</li><li>可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。</li></ul><p>优劣势总结</p><ul><li>activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。</li><li>rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。</li><li>rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。</li><li>kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。</li></ul><p>综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。</p><hr><h2 id="RabbitMQ如何保证消息队列的高可用？"><a href="#RabbitMQ如何保证消息队列的高可用？" class="headerlink" title="RabbitMQ如何保证消息队列的高可用？"></a>RabbitMQ如何保证消息队列的高可用？</h2><p>RabbitMQ是比较有代表性的，因为是基于<strong>主从架构</strong>实现的的高可用。</p><p>RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。</p><ol><li><p>单机模式</p><p>就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。</p></li><li><p>普通集群模式（不是高可用的）</p><p>意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。</p><p>该模式有两个缺点：</p><p>​    如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；</p><p>​    如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。</p></li><li><p>镜像集群模式（是高可用的）</p><p>这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。</p><p>这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。</p><p><strong>怎么开启这个镜像集群模式呢？</strong></p><p>rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。</p></li></ol><hr><h2 id="如何保证消息不被重复消费？-幂等性"><a href="#如何保证消息不被重复消费？-幂等性" class="headerlink" title="如何保证消息不被重复消费？(幂等性)"></a>如何保证消息不被重复消费？(幂等性)</h2><p>什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。</p><p><strong>如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：</strong></p><ol><li>比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。</li><li>比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。</li><li>还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。</li></ol><hr><h2 id="如何保证消息的可靠性传输，不丢消息？"><a href="#如何保证消息的可靠性传输，不丢消息？" class="headerlink" title="如何保证消息的可靠性传输，不丢消息？"></a>如何保证消息的可靠性传输，不丢消息？</h2><p><strong>消息丢失的3种情况：</strong></p><ol><li><strong>生产者</strong>写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；</li><li><strong>rabbitmq</strong>接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；</li><li><strong>消费者</strong>消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。</li></ol><p>情况1<strong>（生产者弄丢了数据）</strong>的解决方案：</p><p><strong>rabbitmq的事务机制</strong>：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。</p><p><strong>confirm机制</strong>：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。</p><p>事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。</p><p>情况2<strong>（rabbitmq弄丢了数据）</strong>的解决方案：</p><p><strong>开启rabbitmq持久化</strong>：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。</p><p>设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，<strong>注意：必须同时设置这两个才可以</strong>。</p><p>这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。</p><p>情况3<strong>（消费者弄丢了数据）</strong>的解决方案：</p><p>消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。</p><hr><h2 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h2><p>先看看造成消息错乱的场景</p><p>如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。</p><p>解决方案：</p><p>拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；</p><p>一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。</p><hr><p>如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？</p><p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：</p><ol><li>先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。</li><li>临时建立好原先10倍或者20倍的queue数量。</li><li>然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。</li><li>等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。</li></ol><p>假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。</p><p>如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。</p><hr><h2 id="如果让你写消息队列，如何架构设计？"><a href="#如果让你写消息队列，如何架构设计？" class="headerlink" title="如果让你写消息队列，如何架构设计？"></a>如果让你写消息队列，如何架构设计？</h2><p><strong>下面说一下设计思路</strong></p><ol><li>首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。</li><li>其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。</li><li>还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举leader即可对外服务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/2019/08/15/mysql0/"/>
      <url>/2019/08/15/mysql0/</url>
      
        <content type="html"><![CDATA[<h3 id="Mysql常用存储引擎"><a href="#Mysql常用存储引擎" class="headerlink" title="Mysql常用存储引擎"></a>Mysql常用存储引擎</h3><table><thead><tr><th align="center">对比项</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">支持外键</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">支持事务</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">行表锁</td><td align="center">只支持表锁，不适合高并发</td><td align="center">支持行锁，适合高并发</td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引，不缓存真实数据</td><td align="center">不仅缓存索引还缓存真实数据，对内存要求较高，<br>而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">表空间</td><td align="center">小</td><td align="center">大</td></tr><tr><td align="center">关注点</td><td align="center">性能，适合大量select</td><td align="center">事务，合适大量select、delete、update</td></tr><tr><td align="center">默认安装</td><td align="center">是</td><td align="center">是（5.6以后支持）</td></tr></tbody></table><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引(index)是帮助Mysql高效获取数据的<strong>数据结构</strong>。</p><p>索引的目的在于提高查询效率，可以简单理解为<strong>排好序的快速查找数据结构</strong>，可以类比字典。</p><p>在数据本身之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。这种数据结构就是索引。</p><blockquote><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上，我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引（InnoDB使用B+树索引）。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引(hash index)等。</p></blockquote><h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><ol><li>提高数据的检索效率，减少IO次数。</li><li>加快分组和排序，降低CPU消耗。</li></ol><h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><ol><li>索引实际上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引也是要占空间的。</li><li>对数据库表中字段的增删改操作还会触发索引的更新，维护索引也是需要额外的成本的。</li></ol><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ul><li>主键索引：即主索引，根据主键建立的索引，<strong>不允许重复，不允许空值</strong>。</li><li>唯一索引：用来建立索引的列的值必须唯一，但<strong>允许有空值</strong>。</li><li>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。</li><li>复合索引：用多个列组合构建的索引，这多个列中的值不允许有空值。</li><li>全文索引：用大文本对象的列构建的索引。</li></ul><blockquote><p>基本语法</p><ul><li><p>创建索引</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE mytable(      ID INT NOT NULL,       username VARCHAR(16) NOT NULL,      INDEX [indexName] (username(length))  ); #在创建表的时候添加索引#创建表以后添加索引的两种方式ALTER TABLE table_name ADD INDEX index_name (col1,col2...);CREATE INDEX index_name ON table_name (col1,col2,col3...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引</p><pre class="line-numbers language-mysql"><code class="language-mysql">DROP INDEX index_name ON table_name;ALTER TABLE table_name DROP INDEX index_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看索引</p><pre class="line-numbers language-mysql"><code class="language-mysql">SHOW INDEX FROM table_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></blockquote><h3 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h3><p>MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如<strong>BTree索引，B+Tree索引，哈希索引，全文索引</strong>等等。</p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>全文索引（FULLTEXT），目前仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：</p><pre class="line-numbers language-mysql"><code class="language-mysql">#创建表的时候添加FULLTEXT索引CTREATE TABLE table_name(    id INT(10) PRIMARY KEY,    name VARCHAR(10) NOT NULL,    my_text TEXT,    FULLTEXT(my_text))ENGINE=MyISAM DEFAULT CHARSET=utf8;#创建表以后，在需要的时候添加FULLTEXT索引ALTER TABLE table_name ADD FULLTEXT INDEX ft_index(column_name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>全文索引<strong>不能使用LIKE %查询字符串%</strong>的模糊查询语法，它有自己特殊的语法</p><pre class="line-numbers language-mysql"><code class="language-mysql">SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><ul><li>对于较大的数据集，<strong>先添加数据</strong>再建全文索引要比<strong>先建全文索引</strong>再添加数据快。</li><li>5.6版本前的MySQL自带的全文索引只能用于MyISAM，5.6版本之后InnoDB开始支持全文索引。</li><li>在MySQL中，全文索引只对英文有用，不支持中文。5.7版本之后通过使用ngram插件开始支持中文。</li><li>如果检索的字符串太短则无法得到预期的结果，检索的字符串长度至少为4字节，此外，如果检索的字符包括停止词，那么停止词会被忽略。</li></ul></blockquote><p>深入理解可参考：<a href="https://www.cnblogs.com/dreamworlds/p/5462018.html" target="_blank" rel="noopener">全文索引的深入理解</a></p><h4 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h4><p>BTree是平衡搜索多叉树。每个节点都同时存储键值和数据，通过使用二分查找的查找方式来高效检索数据，一般来说B树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdf7mun0h8j30qk078wfh.jpg" alt="BTree"></p><blockquote><p>二叉树的缺陷</p><ul><li><strong>搜索效率不足，树的深度不可控。</strong>（树的深度决定着搜索时IO次数）</li><li><strong>节点数据内容太少。</strong>（没有很好的利用系统和磁盘的数据交换特性）</li></ul></blockquote><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h4><p>B+Tree是BTree的一个变种，非叶子结点不存储数据，只存储键值，这样相同的空间可以存储更多的键值。</p><p>很多存储引擎在B+Tree的基础上进行了优化，<strong>在叶子节点添加了顺序访问指针</strong>，这样做是为了<strong>提高区间查找的效率</strong>，只要找到第一个值，然后顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdf7n9fwhgj30va0bgjsv.jpg" alt="优化后的B+Tree"></p><blockquote><p><strong>B+Tree相比BTree的优点</strong></p><ol><li><p>单一节点存储的元素更多，查询的<strong>IO次数更少</strong>。</p></li><li><p>所有查询都要查找到子节点，<strong>查询性能稳定</strong>。</p></li><li><p>所有叶子节点形成有序链表，<strong>便于范围查询</strong>。</p></li></ol></blockquote><p>深入理解参考文章：<a href="https://www.cnblogs.com/dreamworlds/p/5462018.html" target="_blank" rel="noopener">全文索引的深入理解</a></p><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>MySQL中最常见的两种存储引擎分别是MyISAM和InnoDB，分别实现了非聚簇索引和聚簇索引。</p><ul><li>聚簇索引：聚簇索引的顺序就是数据的物理存储顺序。</li><li>非聚簇索引：索引顺序与数据物理排列顺序无关。</li></ul><p>首先要介绍几个概念，在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。</p><h4 id="MyISAM非聚簇索引"><a href="#MyISAM非聚簇索引" class="headerlink" title="MyISAM非聚簇索引"></a>MyISAM非聚簇索引</h4><p>MyISAM存储引擎采用的是非聚簇索引，MyISAM的<strong>主索引和辅助索引几乎是一样的</strong>，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。<br><strong>非聚簇索引的数据表和索引表是分开存储的</strong>。<br>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdf8wmbse6j30tq0q6gw8.jpg" alt="非聚簇索引的主键索引和二级索引"></p><h4 id="InnoDB聚簇索引"><a href="#InnoDB聚簇索引" class="headerlink" title="InnoDB聚簇索引"></a>InnoDB聚簇索引</h4><p>聚簇索引的<strong>主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值</strong>。因此主键的值长度越小越好，类型越简单越好。<br>聚簇索引的<strong>数据和主键索引存储在一起</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdf8v91t4aj312y0k040u.jpg" alt="聚簇索引的主键索引和二级索引"></p><h4 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h4><ul><li>聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到主键时还要多一次IO寻址。</li><li>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。</li></ul><h4 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h4><ul><li><strong>插入速度严重依赖于插入顺序</strong>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</li><li><strong>更新主键的代价很高，因为将会导致被更新的行移动</strong>。因此对于InnoDB表，我们一般定义主键为不可更新。</li><li><strong>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</strong>这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</li><li><strong>采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多</strong>，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。</li></ul><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引-因为每次更新不单单是更新了记录还会更新索引</li><li>Where条件里用不到的字段不创建索引</li><li>单键/组合索引的选择问题 (在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol><h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol><li>表数据太少，只有当数据库里已经有了足够多的数据时才有优化价值。</li><li>经常增删的列不要创建索引，因为维护索引需要额外的成本。</li><li>有大量重复列不要建索引，应该只为最经常查询和最经常排序的数据列建立索引。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql性能分析与索引优化</title>
      <link href="/2019/08/14/mysql1/"/>
      <url>/2019/08/14/mysql1/</url>
      
        <content type="html"><![CDATA[<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="Mysql-Query-Optimizer"><a href="#Mysql-Query-Optimizer" class="headerlink" title="Mysql Query Optimizer"></a>Mysql Query Optimizer</h3><p>Mysql中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供Mysql认为最优的执行计划(它认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)</p><p>当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的Hint信息(如果有)，看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</p><h3 id="Mysql常见瓶颈"><a href="#Mysql常见瓶颈" class="headerlink" title="Mysql常见瓶颈"></a>Mysql常见瓶颈</h3><ul><li>CPU：CPU的瓶颈一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态</li></ul><h3 id="EXPLAIN怎么玩"><a href="#EXPLAIN怎么玩" class="headerlink" title="EXPLAIN怎么玩"></a>EXPLAIN怎么玩</h3><p>使用格式：<strong>EXPLAIN+SQL</strong></p><p>执行计划包含的信息：</p><ul><li><p><code>id</code>：表的读取顺序</p><p><strong>id相同</strong>：执行顺序由上到下。</p><p><strong>id不同</strong>：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行。</p><p><strong>id相同/不同，同时存在</strong>：相同id为一组，由上往下执行，组中id值大的先执行。</p></li><li><p><code>select_type</code>：数据读取操作的操作类型</p><p>常用值：SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION<br>RESULT 共6种。</p><ul><li><p><em>SIMPLE</em>：简单的select查询,查询中不包含子查询或者UNION。</p></li><li><p><em>PRIMARY</em>：查询中若包含任何复杂的子部分,最外层查询则被标记为PRIMARY。</p></li><li><p><em>SUBQUERY</em>：在SELECT或WHERE列表中包含了子查询。</p></li><li><p><em>DERIVED</em>：在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询,把结果放在临时表里。</p></li><li><p><em>UNION</em>：若第二个SELECT出现在UNION之后,则被标记为UNION;<br>若UNION包含在FROM子句的子查询中,外层SELECT将被标记为DERIVED。</p></li><li><p><em>UNION</em><br><em>RESULT</em>：从UNION表获取结果的SELECT。</p></li></ul></li><li><p><code>table</code>：显示这一行数据是关于哪张表的</p></li><li><p><code>partitions</code>：该列显示为分区表命中的分区情况。非分区表该字段为空（null）</p></li><li><p><code>type</code>：访问类型排列</p><p>常用值：ALL、index、range、ref、eq_ref、const、system、NULL</p><blockquote><p>查询效率从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; flltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL(全表扫描)</p></blockquote><ul><li><p><em>system</em>：表只有一行记录(等于系统表)，这是 const 类型的特列，平时不会出现，这个也可以忽略不计。</p></li><li><p><em>const</em>：表示通过索引一次就找到了，const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快的将主键置于where列表中，MySQL 就能将该查询转换为一个常量，比如（where id = ‘1’）</p></li><li><p><em>eq_ref</em>：<strong>唯一性索引扫描</strong>，对于每个索引键，表中<strong>只有一条记录</strong>与之匹配。常见于主键或唯一索引扫描。</p></li><li><p><em>ref</em>：<strong>非唯一性索引扫描</strong>，返回匹配某个单独值的<strong>所有行</strong>。</p><p>本质上也是一种索引访问，它返回所有匹配某个单独值的行。</p><p>然而，<br>它可能会找到多个符合条件的行，<br>所以他应该属于查找和扫描的混合体。</p></li><li><p><em>range</em>：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引。</p><p>一般就是在你的where语句中出现了 between、&lt;、&gt;、in 等的查询，这种范围索引扫描比全表扫描要好。</p><p>因为它只需要开始于索引的某一点， 而结束于另一点， 不用扫描全部索引。</p></li><li><p><em>index</em>：Full Index Scan，index 与 ALL 的区别为 index 类型只遍历索引树。这通常比 ALL 快。因为索引文件通常比数据文件小。(也就是说虽然ALL和Index都是读全表，但index是从索引中读取的，而ALL是从硬盘中读的)</p></li><li><p><em>all</em>：Full Table Scan，将遍历全表以找到匹配的行。</p></li></ul><p><strong>一般来说：保证查询至少达到range级别，最好能达到ref。</strong></p></li><li><p><code>possible_keys</code>：显示<strong>可能使用到的索引</strong>，但不一定被实际使用。</p></li><li><p><code>key</code>：<strong>实际使用的索引</strong>，如果为NULL，则没有使用索引。<u>查询中若使用了覆盖索引，则该索引仅出现在key列中</u>。</p></li><li><p><code>key_len</code>：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度<strong>越短越好</strong>；key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p></li><li><p><code>ref</code>：显示索引的哪一列被使用了，如果可能的话最好是个常数。即哪些列或常量被用于查找索引列上的值。</p></li><li><p><code>rows</code>：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数（越少越好）</p></li><li><p><code>filtered</code>：它指返回结果的行占需要读到的行(rows列的值)的百分比，filtered值只对index和all的扫描有效。</p></li><li><p><code>Extra</code>：包含不适合在其他列中显示但十分重要的额外信息。</p><ul><li><p>Using filesort：说明mysq|会对数据使用一个外部的<strong>文件排序</strong>，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为”文件排序”。（<strong>不好</strong>）</p></li><li><p>Using temporary：使用了<strong>临时表</strong>保存中间结果，Mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。临时表的创建非常消耗性能，增加数据库负担。（<strong>不好</strong>）</p></li><li><p>Using index：表示相应的select操作中使用了覆盖索引(Covering Index)， 避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 （<strong>好</strong>）</p><blockquote><p>覆盖索引(Covering Index) </p><p>理解：就是select的数据列只从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读数据文件，换句话说查询列要被所建的索引覆盖。</p></blockquote></li><li><p>Using where：表明使用了where过滤。</p></li><li><p>using join buffer：表明使用了连接缓存。（可以调大buffer缓解）</p></li><li><p>impossible where：不可能的where条件，比如where name = ‘zs’ and name = ‘ls’;</p></li><li><p>select tables optimized away：在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。（了解）</p></li><li><p>distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。（了解）</p></li></ul></li></ul><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><h4 id="单表查询优化"><a href="#单表查询优化" class="headerlink" title="单表查询优化"></a>单表查询优化</h4><p>比如查询category_id为1且comments&gt;1的情况下，views最多的category_id。</p><pre class="line-numbers language-mysql"><code class="language-mysql">select id,author_id from artical where category_id =1 and comments >1 order by views desc limit 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gddzq7a5lwj318603swf0.jpg" alt="单表没有使用索引"></p><p>存在问题：没有使用索引，扫描全表，文件排序。</p><pre class="line-numbers language-mysql"><code class="language-mysql">create index idx_article_ccv on article(category_id,comments,views); #新建三个字段的索引<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gddzsgtkckj31do03sdgf.jpg" alt="单表给三个字段加索引"></p><p>再次查询：索引被使用到，type是range，仍然存在文件排序，<strong>因为范围查询以后的索引会导致失效</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">drop index idx_article_ccv on article; #删除索引create index idx_article_cv on article(category_id,views); #新建两个字段的索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gddztulo3rj316m03qq3g.jpg" alt="单表给两个字段加索引"></p><p>再次查询：索引被使用到，type是ref，索引字段是const常量，没有产生文件排序，调优完成。</p><p>结论：SQL中包含范围查询，可以跳过范围查询的字段添加索引。</p><h4 id="两表查询优化"><a href="#两表查询优化" class="headerlink" title="两表查询优化"></a>两表查询优化</h4><pre class="line-numbers language-mysql"><code class="language-mysql">#左表是驱动表，显示全部数据，右侧可能有null，如果使用inner join则只显示两表中card能对应上的数据select * from class left join book on class.card = book.card; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gde0lt4sjyj318q05q0tl.jpg" alt="两表没有使用索引"></p><p>存在问题：type都是ALL，扫描全表，没有索引，rows检索40行</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table class add index idx_class_card; #给SQL中左侧class表的card字段添加索引<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gde1205epbj31c805q3zy.jpg" alt="给左表字段加索引"></p><p>左表加索引后的执行计划：type有index，但是检索行数没变。</p><pre class="line-numbers language-mysql"><code class="language-mysql">drop index idx_class_card on class; #删除索引alter table book add index idx_book_card; #给SQL中右侧book表的card字段添加索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gde0fzghz6j31i805uq4g.jpg" alt="给右表字段加索引"></p><p>右表加索引后的执行计划：type有ref，比index更好，检索行数减少。</p><p>结论：<strong>左连接的索引加右表，右连接加左表</strong>。因为左连接的左表数据肯定都有，主要检索右表的数据。如果数据库中某些字段已经存在索引，编写查询SQL的时候尽量把有索引的字段放在右表或者使用right join。</p><h4 id="三表查询优化"><a href="#三表查询优化" class="headerlink" title="三表查询优化"></a>三表查询优化</h4><pre class="line-numbers language-mysql"><code class="language-mysql">select * from class left join book on class.card=book.card left join phone on book.card=phone.card;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gde1dnbfcwj318q06uq43.jpg" alt="三表没有使用索引"></p><p>存在问题：type都是ALL，全部全表扫描，没有使用索引，检索行是60行。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table book add index idx_book_card; #给book表的card字段添加索引alter table phone add index idx_phone_card; #给phone表的card字段添加索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gde1ij37nhj31i806utb5.jpg" alt="给book表和phone表的card添加索引"></p><p>添加两个索引后的执行计划：type有两个ref，检索行数rows也大大减少，效果不错！</p><p>结论：索引最好设置在需要经常查询的字段中。</p><h4 id="Join优化总结"><a href="#Join优化总结" class="headerlink" title="Join优化总结"></a>Join优化总结</h4><ul><li>尽可能减少Join语句中嵌套循环的循环次数，不要join过多，<strong>永远用小结果集驱动大结果集-小表驱动大表</strong>。</li><li>优先优化嵌套循环(NestedLoop)的内层循环(括号中的查询)。</li><li>保证Join语句中被驱动表上Join条件字段已经被索引。</li><li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置；</li></ul><h4 id="问题补充"><a href="#问题补充" class="headerlink" title="问题补充"></a>问题补充</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdeb3a9pjsj31ks0godm4.jpg" alt="like在索引上的用法"></p><h3 id="避免索引失效（重点）"><a href="#避免索引失效（重点）" class="headerlink" title="避免索引失效（重点）"></a>避免索引失效（重点）</h3><ol><li>全值匹配（完美的使用索引）</li><li>最左前缀法则（带头大哥不能死，中间兄弟不能断）</li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列，<strong>范围查询以后的索引字段会失效</strong></li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *</li><li>mysql在使用不等于(!=或者&lt;&gt; )的时候无法使用索引会导致全表扫描</li><li>is null , is not null 也无法使用索引</li><li>like以通配符开头(‘%abc… ‘)也会变成全表扫描，解决方案%写在右边或使用覆盖索引</li><li>字符串不加单引号导致索引失效</li><li>少用or，用它来连接时也会索引失效</li></ol><h3 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h3><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠左越好</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where子句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li></ul><h4 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdea87rbuuj31su0gqgr5.jpg" alt="order by 使用覆盖索引"></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdeaemluv8j31no084gna.jpg" alt="查询条件中有c2常量，只排c3"></p><h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdeam0nvrrj32160gk43b.jpg" alt="group by"></p><p>order by也会使用覆盖索引，在执行计划上的体现是看有没有文件排序；</p><p>group by基本上都要进行排序，和order by类似，索引处理不好会有临时表产生。</p><h4 id="优化口诀"><a href="#优化口诀" class="headerlink" title="优化口诀"></a>优化口诀</h4><p>全值匹配我最爱，最左前缀要遵守；</p><p>带头大哥不能死，中间兄弟不能丢；</p><p>索引列上少计算，范围之后全失效；</p><p>LIKE 百分写最右，覆盖索引不写星；</p><p>不等空值还有 or，少用否则会失效；</p><p>VAR 引号不能丢， SQL 优化要记牢。</p><h3 id="in-和-exists"><a href="#in-和-exists" class="headerlink" title="in 和 exists"></a>in 和 exists</h3><pre class="line-numbers language-mysql"><code class="language-mysql">select * from A where id in (select id from B); #当A表的数据必须大于B表时，用in优于existselect * from A where exists(select 1 from B where B.id = A.id);#当A表的数据集小于B表的时候，用exist优于in<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>EXISTS（<strong>小表驱动大表</strong>）</p><pre class="line-numbers language-mysql"><code class="language-mysql">select ... from table where exists(subquery);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将主查询的数据放到子查询中做条件验证，根据验证结果(true或false)来决定主查询的数据是否得以保留。</p><h3 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h3><ul><li><p>尽量使用Index方式排序，避免使用FileSort方式排序（满足Index排序的两种方式）</p><ol><li>order by语句符合索引最左前缀原则。</li><li>使用where子句与order by子句条件列组合满足索引最左前缀原则。</li></ol></li><li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p></li><li><p>如果order by子句不在索引列上，则会产生filesort，有两种算法: <strong>双路排序 | 单路排序</strong></p><blockquote><p><code>双路排序</code>：Mysql4.1之前使用双路排序，扫描<strong>两次</strong>磁盘（先从磁盘取出排序字段在buffer排序，再从磁盘中取出其他字段），最终得到目标数据。</p><p><code>单路排序</code>：Mysql4.1之后使用单路排序，从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间，<br>因为它把每一行都保存在内存中了。</p><p><strong>单路虽好但仍存在的问题</strong>：在sort_buffer中，单路排序比双路排序要多占用更多的空间，因为单路排序是把所有字段都取出，所以有可能取出的数据总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据进行排序(创建tmp文件，多路合并)，排完再取sort_buffer容量大小的数据，再排…以而多次I/O。</p><p>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p></blockquote></li><li><p>优化策略</p><p>order by 时不要使用 select *，容易把sort_buffer占满</p><p>增大 sort_buffer_size 参数的设置</p><p>增大 max_length_for_sort_data 参数的设置</p></li></ul><blockquote><p>为排序使用索引，Mysql能为排序和查询使用相同的索引。</p><p>Mysql有两种排序方式：文件排序和扫描有序索引排序。</p><p>索引列：KEY a_b_c(a,b,c) ，满足索引最左前缀法则：</p><ul><li>order by a</li><li>order by a,b</li><li>order by a,b,c</li><li>order by a DESC,b DESC,c DESC（排序同升同降都可以使用，混合不行）</li></ul><p>如果where使用索引的最左前缀定义为常量，则order by能使用索引</p><ul><li>WHERE a = const ORDER BY b,c</li><li>WHERE a = const AND b = const ORDERBY c</li><li>WHERE a = const AND b &gt; const ORDER BY b,c</li></ul><p>不能使用索引进行排序</p><ul><li>ORDER BY a ASC,b DESC,c DESC /* 排序不一致/</li><li>WHERE g = const ORDER BY b,c /* 丢失a素引*/</li><li>WHERE a = const ORDER BY c /* 丢失b索引*/</li><li>WHERE a = const ORDER BY a,d /* d不是索引的一部分*/</li><li>WHERE a in (…) ORDER BY b,c /* <strong>丢失大哥,对于排序来说,多个相等条件也是范围查询*</strong>/</li></ul></blockquote><h3 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h3><ul><li>group by 的优化和order by大体相同。</li><li>group by 实质是先排序后进行分组，遵照索引建的最佳左前缀。</li><li>当无法使用索引列，增大 max_length_for_sort_data 参数的设置+增大 sort_ buffer_ size 参数的设置。</li><li>where 高于 having，能写在 where 限定的条件就不要写 having 了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> explain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql开启慢查询与SQL诊断</title>
      <link href="/2019/08/13/mysql2/"/>
      <url>/2019/08/13/mysql2/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql调优顺序"><a href="#Mysql调优顺序" class="headerlink" title="Mysql调优顺序"></a>Mysql调优顺序</h2><ol><li>开启慢查询并捕获慢SQL</li><li>explain分析慢SQL语句</li><li>show profile查看SQL在Mysql服务器里面的执行细节和生命周期</li><li>mysql数据库服务器的参数调优</li></ol><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过 long_query_time 值的SQL，则会被记录到慢查询日志中。比如一条 sql 执行超过5秒钟我们就算慢SQL，开启后就能收集超过5秒的sql，再结合explain进行全面分析。</p><h3 id="如何开启日志"><a href="#如何开启日志" class="headerlink" title="如何开启日志"></a>如何开启日志</h3><p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。<br>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少会带来一定的性能影响。慢查询日志支持将日志记录写入文件。</p><pre class="line-numbers language-mysql"><code class="language-mysql">show variables like '%slow_query_log%'; #查看慢查询日志的状态及保存位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启。</p><pre class="line-numbers language-mysql"><code class="language-mysql">set global slow_query_log=1; #开启慢查询日志（只针对当前数据库生效，mysql重启后会失效）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="如何记录慢SQL"><a href="#如何记录慢SQL" class="headerlink" title="如何记录慢SQL"></a>如何记录慢SQL</h3><pre class="line-numbers language-mysql"><code class="language-mysql">show variables like '%long_query_time%'; #查看慢SQL阈值，默认值是10s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，在mysql源码里是判断大于long_query_time， 而非大于等于。使用如下命令：</p><pre class="line-numbers language-mysql"><code class="language-mysql">set global long_query_time=3; #修改阈值，记录执行超过3s的就是慢sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新连接或者新开一个会话才能看到修改后的值，或者使用如下命令查看：</p><pre class="line-numbers language-mysql"><code class="language-mysql">show global variables like 'long_query_time';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前系统中有多少条慢查询记录</p><pre class="line-numbers language-mysql"><code class="language-mysql">show global status like '%slow_queries%';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="永久生效-可选"><a href="#永久生效-可选" class="headerlink" title="永久生效(可选)"></a>永久生效(可选)</h3><p>如要永久生效，就必须修改配置文件my.cnf（其他系统变量也是如此）具体方式如下：</p><p>[mysqld]下增加或修改以下参数，然后重启MySQL服务器。</p><pre class="line-numbers language-bash"><code class="language-bash">slow_query_log<span class="token operator">=</span>1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#开启</span>slow_query_log_file<span class="token operator">=</span>/usr/local/mysql/data/cherry-slow.log <span class="token comment" spellcheck="true">#日志保存位置</span>long_query_time<span class="token operator">=</span>3<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#设置慢查询阈值</span>log_output<span class="token operator">=</span>FILE <span class="token comment" spellcheck="true">#设置文件输出类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h3><pre class="line-numbers language-bash"><code class="language-bash">mysqldumpslow --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>s：是表示按照何种方式排序</li><li>c：访问次数</li><li>l：锁定时间</li><li>r：返回记录</li><li>t：查询时间</li><li>al：平均锁定时间</li><li>ar：平均返回记录数</li><li>at：平均查询时间</li><li>t：即为返回前面多少条的数据</li><li>g：后边搭配一个正则匹配模式，大小写不敏感的</li></ul><h4 id="常用参考"><a href="#常用参考" class="headerlink" title="常用参考"></a>常用参考</h4><blockquote><ul><li><p>得到返回记录集最多的10个SQL</p><p>mysqldumpslow -s r -t 10 /var/lib/mysql/cherry-slow.log</p></li><li><p>得到访问次数最多的10个SQL</p><p>mysqldumpslow -s c -t 10 /var/lib/mysql/cherry-slow.log</p></li><li><p>得到按照时间排序的前10条里面含有左连接的查询语句</p><p>mysqldumpslow-s t -t 10 -g “left join” /var/lib/mysql/cherry-slow.log</p></li><li><p>另外建议在使用这些命令时结合 | more 使用，否则有可能出现爆屏情况</p><p>mysqldumpslow -s r -t 10 /var/lib/mysql/cherry-slow.log | more</p></li></ul></blockquote><h2 id="批量数据脚本"><a href="#批量数据脚本" class="headerlink" title="批量数据脚本"></a>批量数据脚本</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE emp(id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,empno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*编号*/ename VARCHAR(20) NOT NULL DEFAULT "",/*名字*/job VARCHAR(9) NOT NULL DEFAULT "",/*工作*/mgr MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,/*.上级编号*/hiredate DATE NOT NULL,/* 入职时间*/sal DECIMAL (7,2) NOT NULL,/*薪水*/comm DECIMAL (7,2) NOT NULL,/*红利*/deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0 /*部门编号*/)ENGINE=INNODB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE dept(id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,deptno MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,dname VARCHAR(20) NOT NULL DEFAULT "",loc VARCHAR(13) NOT NULL DEFAULT "") ENGINE=INNODB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><pre class="line-numbers language-mysql"><code class="language-mysql">#获得随机字符串的函数#DELIMITER $$CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)BEGINDECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';DECLARE return_str VARCHAR(255) DEFAULT '';DECLARE i INT DEFAULT 0;WHILE i < n DOSET return_str = CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));SET i = i + 1;END WHILE;RETURN return_str;END #$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">#获得随机整数的函数#DELIMITER $$CREATE FUNCTION rand_num()RETURNS INT(5)BEGINDECLARE i INT DEFAULT 0;SET i = FLOOR(100+RAND()*10);RETURN i;END #$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre class="line-numbers language-mysql"><code class="language-mysql">#DELIMITER $$CREATE PROCEDURE insert_emp(IN START INT(10),IN max_num INT(10))BEGINDECLARE i INT DEFAULT 0;#set autocommit = 0 把自动提交关掉SET autocommit = 0;REPEATSET i = i + 1;INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES((START+i),rand_string(6),'SALESMAN',0001,CURDATE(),2000,400,rand_num());UNTIL i = max_numEND REPEAT;COMMIT;END #$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-mysql"><code class="language-mysql">#DELIMITER $$CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))BEGINDECLARE i INT DEFAULT 0;SET autocommit = 0;REPEATSET i = i + 1;INSERT INTO dept(deptno,dname,loc) VALUES((START+i),rand_string(10),rand_string(8));UNTIL i = max_numEND REPEAT;COMMIT;END #$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre class="line-numbers language-mysql"><code class="language-mysql">CALL insert_emp(10001,50000); #33sCALL insert_dept(100001,500000); #3min<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h2><p>show profile是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于SQL调优的测量。</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><pre class="line-numbers language-mysql"><code class="language-mysql">show variables like 'profiling'; #查看状态set profiling = on; #开启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="诊断SQL"><a href="#诊断SQL" class="headerlink" title="诊断SQL"></a>诊断SQL</h3><pre class="line-numbers language-mysql"><code class="language-mysql">show profiles; #查看执行的SQL的id和耗时show profile CPU,BLOCK IO for query 222; #222是具体id展示详细耗时信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>参数备注</strong></p><ul><li>ALL：显示所有的开销信息</li><li>BLOCK IO：显示块IO相关开销</li><li>CONTEXT SWITCHES：上下文切换相关开销</li><li>CPU：显示CPU相关开销信息</li><li>IPC：显示发送和接收相关开销信息</li><li>MEMORY：显示内存相关开销信息<br>PAGE FAULTS<br>-显示页面错误相关开销信息</li><li>SOURCE：显示和Source_ function, Source_ file， Source_ line相关的开销信息</li><li>SWAPS：显示交换次数相关开销的信息</li></ul><blockquote><p><strong>需要注意的结论</strong></p><p>converting HEAP to MyISAM：查询结果太大，内存都不够用了往磁盘上搬了。</p><p>Creating tmp table：创建临时表——拷贝数据到临时表；用完再删除。</p><p>Copying to tmp table on disk：把内存中临时表复制到磁盘，危险! ! !</p><p>locked：锁表</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gdfftg0zzij31720n843s.jpg" alt="创建了临时表"></p><h2 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h2><blockquote><p><strong>永远不要在生产环境开启在这个功能。</strong></p></blockquote><h3 id="配置启用"><a href="#配置启用" class="headerlink" title="配置启用"></a>配置启用</h3><p>在mysql的my.cnf中，设置如下:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#开启</span>general_log<span class="token operator">=</span>1<span class="token comment" spellcheck="true">#记录日志文件的路径</span>general log_file<span class="token operator">=</span>/path/logfile<span class="token comment" spellcheck="true">#输出格式</span>log_output<span class="token operator">=</span>FILE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编码启用"><a href="#编码启用" class="headerlink" title="编码启用"></a>编码启用</h3><pre class="line-numbers language-mysql"><code class="language-mysql">set global general_log=1;set global log_output='TABLE';#此后，你所编写的sq|语句，将会记录到mysq|库里的general_log表select * from mysql.general_log; #查看sql历史记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 慢查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql锁机制</title>
      <link href="/2019/08/12/mysql3/"/>
      <url>/2019/08/12/mysql3/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql数据库的锁机制"><a href="#Mysql数据库的锁机制" class="headerlink" title="Mysql数据库的锁机制"></a>Mysql数据库的锁机制</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说锁对数据库而言显得尤其重要，也更加复杂。</p><h3 id="读锁-写锁"><a href="#读锁-写锁" class="headerlink" title="读锁/写锁"></a>读锁/写锁</h3><p>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p><p>写锁(排他锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。</p><pre class="line-numbers language-mysql"><code class="language-mysql">show open tables; #查看是否有锁表lock table emp read,dept write; #给emp表加读锁，给dept表加写锁unlock tables; #解锁show status like 'table%'; #分析表锁定的情况#Table_locks_immediate: 产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1;#Table_locks_waited：出现表级锁定争用而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在着较严重的表级锁争用情况;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">对当前表加读锁</th><th align="center">当前session</th><th align="center">其他session</th></tr></thead><tbody><tr><td align="center">查询当前表</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">修改当前表</td><td align="center">不能（报错）</td><td align="center">阻塞（等待释放锁）</td></tr><tr><td align="center">查询其他表</td><td align="center">不能</td><td align="center">能</td></tr><tr><td align="center">释放锁</td><td align="center">-</td><td align="center">被放行，可以修改</td></tr></tbody></table><table><thead><tr><th align="center">对当前表加写锁</th><th align="center">当前session</th><th align="center">其他session</th></tr></thead><tbody><tr><td align="center">查询当前表</td><td align="center">能</td><td align="center">阻塞（等待释放锁）</td></tr><tr><td align="center">修改当前表</td><td align="center">能</td><td align="center">阻塞（等待释放锁）</td></tr><tr><td align="center">查询其他表</td><td align="center">不能</td><td align="center">能</td></tr><tr><td align="center">释放锁</td><td align="center">-</td><td align="center">被放行，可查可改</td></tr></tbody></table><h3 id="表锁-行锁-页锁"><a href="#表锁-行锁-页锁" class="headerlink" title="表锁/行锁/页锁"></a>表锁/行锁/页锁</h3><p><code>表锁</code>：偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><p>MyISAM在执行查询语句(SELECT) 前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p><ol><li>对MyISAM表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。</li><li>对MyISAM表的写操作(加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。</li></ol><p><strong>Mysql的读写锁有什么区别？简而言之，就是读锁会阻塞写，但是不会阻塞读；而写锁则会把读和写都阻塞。</strong></p><p>此外，Myisam的读写锁调度是写优先，这也是myisam不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><hr><p><code>行锁</code>：偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p><pre class="line-numbers language-mysql"><code class="language-mysql">show variables like 'tx_isolation'; #查看数据库默认的隔离级别set autocommit = 0; #取消自动提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>行锁支持事务</strong>，想获取更多关于数据库事务的理解请参考：<a href="https://lishaojie1993.gitee.io/2019/08/10/BTree/">Mysql数据库事务详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-数据库事务</title>
      <link href="/2019/08/10/BTree/"/>
      <url>/2019/08/10/BTree/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h2><p>第一范式（1NF）：强调的是<strong>列的原子性</strong>，即列不能够再分成其他几列。 </p><p>第二范式（2NF）：表中非主键列不能对主键产生部分依赖，要求每个表只描述一件事情。</p><p>第三范式（3NF）：不存在对非主键列的传递依赖。</p><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="事务ACID属性"><a href="#事务ACID属性" class="headerlink" title="事务ACID属性"></a>事务ACID属性</h3><p>事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元，必须具备以下四个属性，简称 ACID 属性：</p><ul><li><p><strong>原子性（Atomicity）</strong></p><p>事务是一个完整的操作。事务的各步操作是不可分的(原子的)；要么都执行，要么都不执行。</p></li><li><p><strong>一致性（Consistency）</strong></p><p>当事务完成时，数据必须处于一致状态。</p></li><li><p><strong>隔离性（Isolation）</strong></p><p>对数据进行修改的所有并发事务是彼此隔离的， 这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</p></li><li><p><strong>持久性（Durability）</strong></p><p>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。</p></li></ul><h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><ul><li><p><strong>脏读（Dirty Read）</strong></p><p>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。</p></li><li><p><strong>不可重复读（NonRepeatable Read）</strong></p><p>事务A多次读取同一数据，事务B在事务A多次读取的过程中对数据作了更新，导致事务A多次读取同一数据的结果不一致。</p></li><li><p><strong>幻读（Phantom Read）</strong></p><p>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li></ul><p>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库隔离级别：未提交读(Read uncommitted)，已提交读(Read committed)，可重复读(Repeatable read)和可串行化(Serializable)；</p><ul><li>未提交读(Read uncommitted)：可能读取到其他会话中未提交事务修改的数据，会出现脏读(Dirty Read)；</li><li>已提交读(Read committed)：只能读取到已经提交的数据，会出现不可重复读(NonRepeatable Read)；</li><li>可重复读(Repeatable read)：InnoDB默认级别，不会出现不可重复读(NonRepeatable Read)，但是会出现幻读(Phantom Read);</li><li>可串行化(Serializable)：强制事务排序，使之不可能相互冲突，从而解决幻读问题，使用表级共享锁，读写相互都会阻塞；</li></ul><h2 id="并发事务解决方案"><a href="#并发事务解决方案" class="headerlink" title="并发事务解决方案"></a>并发事务解决方案</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁是一种思想，认为事务间竞争没有那么多，和悲观锁是相对的，乐观锁在java的并发包中大量的使用；一般采用以下方式：使用版本号(version)机制来实现，版本号就是为数据添加一个版本标志，一般在表中添加一个version字段；当读取数据的时候把version也取出来，然后version+1，更新数据库的时候对比第一次取出来的version和数据库里面的version是否一致，如果一致则更新成功，否则失败进入重试，具体使用大致如下：</p><pre class="line-numbers language-mysql"><code class="language-mysql">begin;select id,name,version from test_lock where id=1;....update test_lock set name='xxx',version=version+1 where id=1 and version=${version};commit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先查询后更新，需要保证原子性，要么使用悲观锁的方式，对整个事务加锁；要么使用乐观锁的方式，如果在读多写少的系统中，乐观锁性能更好；</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。<br>尽管悲观锁能够防止丢失更新和不可重复读这类问题，但是它非常影响并发性能，因此应该谨慎使用。</p><h3 id="增加时间戳字段"><a href="#增加时间戳字段" class="headerlink" title="增加时间戳字段"></a>增加时间戳字段</h3><p>时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加 1，提交之前，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量。</p><h3 id="多版本并发控制MVCC"><a href="#多版本并发控制MVCC" class="headerlink" title="多版本并发控制MVCC"></a>多版本并发控制MVCC</h3><ul><li><p>目的</p><p>MVCC(Multiversion Concurrency Control)，即多版本并发控制。大多数的MYSQL事务型存储引擎，如InnoDB，Falcon都不仅仅使用简单的行锁机制，而是和MVCC–多版本并发控制来一起使用。只需要很小的开销，就可以实现非锁定读（快照读），从而大大<strong>提高数据库系统的并发性能</strong>。</p></li><li><p>原理</p><p>MVCC可以提供基于某个时间点的快照，使得对于事务看来，总是可以提供与事务开始时刻相一致的数据，而不管这个事务执行的时间有多长。所以在不同的事务看来，同一时刻看到的相同行的数据可能是不一样的，即一个行可能有多个版本。</p></li><li><p>实现</p><p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，其中一列存储<strong>行被创建</strong>的版本号，另外一列存储<strong>行被删除</strong>的版本号。每当一个事务开始的时候，innodb都会给这个事务分配一个递增的系统版本号，所以版本号也可以被认为是事务ID。MVCC只在“读已提交”和“可重复读”两个隔离级别下工作。“读未提交”总是读取最新的数据行，而不是符合当前事务版本的数据行。而“串行化”则会对所有读取的行都加锁。在“可重复读”的隔离级别下，具体各种数据库操作的实现：</p></li></ul><ol><li><p>select：满足以下两个条件innodb会返回该行数据。</p><ul><li><p>该行的<strong>创建版本号</strong>小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</p></li><li><p>该行的<strong>删除版本号</strong>大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</p></li></ul></li><li><p>insert：将新插入的行的创建版本号设置为当前系统的版本号。</p></li><li><p>delete：将要删除的行的删除版本号设置为当前系统的版本号。</p></li><li><p>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</p></li></ol><p>以上4条，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>一组为了完成<strong>特定功能的 SQL 语句集</strong>，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><p>存储过程优化思路：</p><ol><li>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</li><li>中间结果存放于临时表，加索引。</li><li>少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。</li><li>事务越短越好。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。</li><li>使用 try-catch 处理错误异常。</li><li>查找语句尽量不要放在循环内。</li></ol><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：触发器是当对某一个表进行操作时触发。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2019/07/12/multi-thread/"/>
      <url>/2019/07/12/multi-thread/</url>
      
        <content type="html"><![CDATA[<h2 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h2><p>新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）</p><ol><li><strong>新建</strong>：当创建Thread类的一个实例（对象）时，此线程进入新建状态（还没调用start()）</li><li><strong>就绪</strong>：线程调用了start()，等待CPU分配时间片，即在就绪队列中排队等候得到CPU资源。</li><li><strong>运行</strong>：线程获得CPU资源正在执行任务，开始运行run函数中的代码。</li><li><strong>阻塞</strong>：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入阻塞状态。</li><li><strong>死亡</strong>：当线程执行完毕或被其它线程杀死，线程就进入死亡状态。</li></ol><blockquote><p><strong>解释说明</strong></p><p>新建：Thread t1 = new Thread();</p><p>就绪：t1.start();</p><p>运行：run();</p><p>阻塞：sleep(long t)、wait()、suspend()</p><p>死亡：自然终止（run方法运行结束）｜异常终止（调用stop()方法）</p></blockquote><h2 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h2><p>线程相关的基本方法有 wait()，notify()，notifyAll()，sleep()，join()，yield() 等。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gd0htefwj9j313u0r6k0t.jpg" alt></p><h3 id="线程等待-wait"><a href="#线程等待-wait" class="headerlink" title="线程等待-wait()"></a>线程等待-wait()</h3><p>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会<strong>释放对象的锁</strong>。因此，wait 方法一般用在同步方法或同步代码块中。</p><h3 id="线程睡眠-sleep"><a href="#线程睡眠-sleep" class="headerlink" title="线程睡眠-sleep()"></a>线程睡眠-sleep()</h3><p>sleep() 导致当前线程休眠，与 wait 方法不同的是 sleep <strong>不会释放当前占有的锁</strong>，sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态。</p><h3 id="线程让步-yield"><a href="#线程让步-yield" class="headerlink" title="线程让步-yield()"></a>线程让步-yield()</h3><p>yield() 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p><h3 id="线程中断-interrupt"><a href="#线程中断-interrupt" class="headerlink" title="线程中断-interrupt()"></a>线程中断-interrupt()</h3><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。</p><ol><li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</p></li><li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException，从而使线程提前结束 TIMED-WATING 状态。</p></li><li><p>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</p></li><li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如你想终止一个线程的时候，可以调用thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</p></li></ol><h3 id="等待其他线程终止-join"><a href="#等待其他线程终止-join" class="headerlink" title="等待其他线程终止-join()"></a>等待其他线程终止-join()</h3><p>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</p><p><strong>为什么要用 join()方法？</strong></p><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程在子线程结束后再结束，这时候就要用到 join() 方法。</p><h3 id="线程唤醒-notify"><a href="#线程唤醒-notify" class="headerlink" title="线程唤醒-notify()"></a>线程唤醒-notify()</h3><p>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会随机唤醒其中一个线程，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒在监视器上等待的所有线程。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>isAlive()： 判断一个线程是否存活。</p><p>activeCount()： 程序中活跃的线程数。</p><p>enumerate()： 枚举程序中的线程。</p><p>currentThread()： 得到当前线程。</p><p>isDaemon()： 一个线程是否为守护线程。</p><p>setDaemon()： 设置一个线程为守护线程。</p><p>setName()： 为线程设置一个名称。</p><p>setPriority()： 设置一个线程的优先级。</p><p>getPriority():：获得一个线程的优先级。</p><blockquote><p><strong>守护线程扩展</strong></p><p>User Thread（用户线程）和Daemon Thread（守护线程）从本质上来说并没有什么区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p><p>守护线程的应用：垃圾回收线程。</p></blockquote><h2 id="线程常见面试题"><a href="#线程常见面试题" class="headerlink" title="线程常见面试题"></a>线程常见面试题</h2><h3 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h3><p>sleep()是<strong>线程类Thread</strong>的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，<strong>不会释放对象锁</strong>。</p><p>wait()是<strong>Object类</strong>的方法，当一个线程执行到wait方法时，它就进入等待状态，<strong>同时释放对象锁</strong>，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p><h3 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h3><p>notify()方法只随机唤醒一个线程从等待池到锁池，而notifyAll会将该对象在等待池内的所有线程都移动到锁池中，等待锁竞争。</p><h3 id="run-和-start-有什么区别？"><a href="#run-和-start-有什么区别？" class="headerlink" title="run() 和 start() 有什么区别？"></a>run() 和 start() 有什么区别？</h3><p>run()方法只是线程里的一个函数，如果直接调用run()其实就相当于调用了一个普通方法而已。</p><p>start()方法用来启动一个新线程，真正实现了多线程运行，此时处于就绪状态等待CPU调度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2019/06/29/list-set-map/"/>
      <url>/2019/06/29/list-set-map/</url>
      
        <content type="html"><![CDATA[<p>集合类存放于 Java.util 包中，主要有 3 种:set(集)、list(列表包含 Queue)和 map(映射)。</p><ol><li>Collection:Collection 是集合 List、Set、Queue 的最基本的接口。</li><li>Iterator:迭代器，可以通过迭代器遍历集合中的数据。</li><li>Map:是映射表的基础接口。</li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List-排列有序，可重复"><a href="#List-排列有序，可重复" class="headerlink" title="List (排列有序，可重复)"></a>List (排列有序，可重复)</h3><p>Java 的 List 是很常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类: 分别是 ArrayList、Vector 和 LinkedList。</p><ol><li>ArrayList：排列有序，可重复，底层为数组，查找快，增删慢，<strong>线程不安全，扩展为原来的1.5倍。</strong></li><li>Vector：排列有序，可重复，底层为数组，查找快，增删慢，<strong>线程安全，扩展为原来的2倍。</strong></li><li>LinkedList：排列有序，可重复，底层为<strong>双向链表，增删快，查找慢</strong>，线程不安全。</li></ol><h3 id="Set-排列无序，不可重复"><a href="#Set-排列无序，不可重复" class="headerlink" title="Set (排列无序，不可重复)"></a>Set (排列无序，不可重复)</h3><ol><li>HashSet：排列无序，不可重复，底层为HashMap。</li><li>TreeSet：排列有序，不可重复，底层为二叉树。</li><li>LinkedHashSet：继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。使用双向链表记录插入顺序。</li></ol><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>在两端出入的list，所以也可以使用数组或链表来实现。</p><p>想了解阻塞队列相关请参考：<a href="https://lishaojie1993.gitee.io/2020/02/16/BlockingQueue/">阻塞队列-BlockingQueue</a></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-数组-链表-红黑树"><a href="#HashMap-数组-链表-红黑树" class="headerlink" title="HashMap (数组+链表+红黑树)"></a>HashMap (数组+链表+红黑树)</h3><p>键不可重复，值可重复，底层哈希表，<strong>线程不安全，允许一个key为null，value也可以为null。</strong></p><p>详情可参考：<a href="https://lishaojie1993.gitee.io/2019/04/18/HashMap/">HashMap的底层实现原理</a></p><h3 id="ConcurrentHashMap-Segment-继承-ReentrantLock-加锁"><a href="#ConcurrentHashMap-Segment-继承-ReentrantLock-加锁" class="headerlink" title="ConcurrentHashMap(Segment 继承 ReentrantLock 加锁)"></a>ConcurrentHashMap(<strong>Segment</strong> 继承 <strong>ReentrantLock</strong> 加锁)</h3><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每 个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p>详情可参考：<a href="https://lishaojie1993.gitee.io/2019/03/19/ConcurrentHashMap/">ConcurrentHashMap底层实现</a></p><h3 id="HashTable-线程安全"><a href="#HashTable-线程安全" class="headerlink" title="HashTable (线程安全)"></a>HashTable (线程安全)</h3><p>键不可重复，值可重复，底层哈希表，<strong>线程安全，key、value都不允许为null。</strong></p><h3 id="TreeMap-可排序"><a href="#TreeMap-可排序" class="headerlink" title="TreeMap (可排序)"></a>TreeMap (可排序)</h3><p>键不可重复，值可重复，底层二叉树。</p><h3 id="LinkHashMap-记录插入顺序"><a href="#LinkHashMap-记录插入顺序" class="headerlink" title="LinkHashMap (记录插入顺序)"></a>LinkHashMap (记录插入顺序)</h3><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序。</p><h2 id="集合类不安全问题"><a href="#集合类不安全问题" class="headerlink" title="集合类不安全问题"></a>集合类不安全问题</h2><h3 id="ArrayList初始化"><a href="#ArrayList初始化" class="headerlink" title="ArrayList初始化"></a>ArrayList初始化</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据源码得知ArrayList初始化：构造初始容量为10的空数组</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ArrayList线程不安全"><a href="#ArrayList线程不安全" class="headerlink" title="ArrayList线程不安全"></a>ArrayList线程不安全</h3><h4 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h4><p><strong>java.util.ConcurrentModificationException：并发修改异常</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出异常</span><span class="token comment" spellcheck="true">//java.util.ConcurrentModificationException</span><span class="token comment" spellcheck="true">//    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)</span><span class="token comment" spellcheck="true">//    at java.util.ArrayList$Itr.next(ArrayList.java:859)</span><span class="token comment" spellcheck="true">//    at java.util.AbstractCollection.toString(AbstractCollection.java:461)</span><span class="token comment" spellcheck="true">//    at java.lang.String.valueOf(String.java:2994)</span><span class="token comment" spellcheck="true">//    at java.io.PrintStream.println(PrintStream.java:821)</span><span class="token comment" spellcheck="true">//    at ListDemo$1.run(ListDemo.java:13)</span><span class="token comment" spellcheck="true">//    at java.lang.Thread.run(Thread.java:748)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>ArrayList线程不安全的原因是因为ArrayList的<strong>add()</strong>方法的源码中没有加锁，并发争抢修改导致异常。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//源码为了保证并发性和效率，没有加synchronized</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>List<string> list = new Vector&lt;&gt;();</string></li><li>List<string> list = Collections.synchronizedList(new ArrayList&lt;&gt;());</string></li><li><strong>List<string> list = new CopyOnWriteArrayList&lt;&gt;();</string></strong></li></ol><p>CopyOnWrite容器即<strong>“写时复制”</strong>的容器<strong>object[] element</strong>，往这个容器里添加元素的时候，不直接往当前容器中添加，而是先拷贝当前容器，在拷贝出的新容器中<strong>object[] newElement</strong>添加元素，添加完成后再将原容器的引用指向新容器<strong>setArray(newElement)</strong>，这样的好处是可以对CopyOnWrite容器进行并发的读，是一种<strong>读写分离</strong>的思想。</p><h3 id="HashSet初始化"><a href="#HashSet初始化" class="headerlink" title="HashSet初始化"></a>HashSet初始化</h3><p>HashSet的底层实现是<strong>HashMap</strong>，默认初始容量是16，负载因子是0.75。</p><p>虽然底层是HashMap，不过HashSet只关心key，value都是一个PRESENT的常量。</p><h3 id="HashSet线程不安全"><a href="#HashSet线程不安全" class="headerlink" title="HashSet线程不安全"></a>HashSet线程不安全</h3><h4 id="故障现象-1"><a href="#故障现象-1" class="headerlink" title="故障现象"></a>故障现象</h4><p><strong>java.util.ConcurrentModificationException：并发修改异常</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SetDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">30</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//java.util.ConcurrentModificationException</span><span class="token comment" spellcheck="true">//    at java.util.HashMap$HashIterator.nextNode(HashMap.java:1442)</span><span class="token comment" spellcheck="true">//    at java.util.HashMap$KeyIterator.next(HashMap.java:1466)</span><span class="token comment" spellcheck="true">//    at java.util.AbstractCollection.toString(AbstractCollection.java:461)</span><span class="token comment" spellcheck="true">//    at java.lang.String.valueOf(String.java:2994)</span><span class="token comment" spellcheck="true">//    at java.io.PrintStream.println(PrintStream.java:821)</span><span class="token comment" spellcheck="true">//    at ListDemo$1.run(SetDemo.java:11)</span><span class="token comment" spellcheck="true">//    at java.lang.Thread.run(Thread.java:748)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分析原因-1"><a href="#分析原因-1" class="headerlink" title="分析原因"></a>分析原因</h4><p>add()方法没有加锁。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//PRESENT是一个Object类型的常量</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span> <span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>PRESENT<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>Set<string> set = Collections.synchronizedSet(new HashSet&lt;&gt;());</string></li><li><strong>Set<string> set = new CopyOnWriteArraySet&lt;&gt;();</string></strong></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> CopyOnWriteArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> al<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Creates an empty set**/</span><span class="token keyword">public</span> <span class="token function">CopyOnWriteArraySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  al <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>通过源码可以看出CopyOnWriteArraySet调用的是CopyOnWriteArrayList.</strong></p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>故障现象和原因都同上，解决方案使用<strong>ConCurrentHashMap</strong>，可参考上文中的链接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制-Git</title>
      <link href="/2019/05/13/git/"/>
      <url>/2019/05/13/git/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="Git-的特点"><a href="#Git-的特点" class="headerlink" title="Git 的特点"></a>Git 的特点</h2><p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：</p><p>从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。<a id="more"></a></p><ul><li>优点</li></ul><p>适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。</p><ul><li>缺点</li></ul><p>资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有码和版本信息。因其资料的公开性，导致大型商业化工程几乎不会使用GIT来托管工程版本信息（除非搭建企业私服）。</p><h2 id="Git-创建仓库"><a href="#Git-创建仓库" class="headerlink" title="Git 创建仓库"></a>Git 创建仓库</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p><p><strong>使用方法</strong></p><p>使用当前目录作为Git仓库，我们只需使它初始化。</p><pre><code>git init</code></pre><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。</p><pre><code>git init newrepo</code></pre><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><pre><code>$ git add *.c$ git add README$ git commit -m &#39;初始化项目版本&#39;</code></pre><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><hr><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p><p>克隆仓库的命令格式为：</p><pre><code>git clone &lt;repo&gt;</code></pre><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><pre><code>git clone &lt;repo&gt; &lt;directory&gt;</code></pre><p><strong>参数说明：</strong></p><ul><li><strong>repo:</strong> Git 仓库。</li><li><strong>directory:</strong> 本地目录。</li></ul><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><pre><code>$ git clone git://github.com/schacon/grit.git</code></pre><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><pre><code>$ git clone git://github.com/schacon/grit.git mygrit</code></pre><h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add 命令可将文件添加到缓存</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>git status 命令可以查看当前的提交状态</p><pre class="line-numbers language-xml"><code class="language-xml">➜  lishaojie.github.io git:(master) ✗ git status -s m themes/melody?? source/_posts/git.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>git diff 命令可以查看文件具体哪里做了改动</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>git commit 命令可以把缓存区的内容提交到本地仓库</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset 命令可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示。</p><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p><pre><code>git rm &lt;file&gt;</code></pre><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <strong>-f</strong></p><pre><code>git rm -f &lt;file&gt;</code></pre><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可</p><pre><code>git rm --cached &lt;file&gt;</code></pre><p>如我们删除 hello.php文件：</p><pre><code>$ git rm hello.php rm &#39;hello.php&#39;$ lsREADME</code></pre><p>不从工作区中删除文件：</p><pre><code>$ git rm --cached README rm &#39;README&#39;$ lsREADME</code></pre><p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p><pre><code>git rm –r * </code></pre><p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录</p><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>git mv 命令用于移动或重命名一个文件、目录、软连接</p><h2 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre><code>git branch (branchname)</code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre><code>git checkout (branchname)</code></pre><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><h3 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h3><pre><code>git branch</code></pre><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><pre><code>$ git branch* master</code></pre><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p><pre><code>$ git branch testing$ git branch* master  testing</code></pre><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><pre><code>$ lsREADME$ echo &#39;runoob.com&#39; &gt; test.txt$ git add .$ git commit -m &#39;add test.txt&#39;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME        test.txt$ git checkout testingSwitched to branch &#39;testing&#39;$ lsREADME</code></pre><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p><pre><code>$ git checkout masterSwitched to branch &#39;master&#39;$ lsREADME        test.txt</code></pre><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><pre><code>$ git checkout -b newtestSwitched to a new branch &#39;newtest&#39;$ git rm test.txt rm &#39;test.txt&#39;$ lsREADME$ touch runoob.php$ git add .$ git commit -am &#39;removed test.txt、add runoob.php&#39;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME        runoob.php$ git checkout masterSwitched to branch &#39;master&#39;$ lsREADME        test.txt</code></pre><p>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支命令：</p><pre><code>git branch -d (branchname)</code></pre><p>例如我们要删除 testing 分支：</p><pre><code>$ git branch* master  testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master</code></pre><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><pre><code>git merge$ git branch* master  newtest$ lsREADME        test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt   | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME        runoob.php</code></pre><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p><p>合并完后就可以删除分支:</p><pre><code>$ git branch -d newtestDeleted branch newtest (was c1501a2).</code></pre><p>删除后， 就只剩下 master 分支了：</p><pre><code>$ git branch* master</code></pre><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><pre><code>$ git branch* master$ cat runoob.php</code></pre><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p><pre><code>&lt;?phpecho &#39;runoob&#39;;?&gt;</code></pre><p>创建 change_site 分支：</p><pre><code>$ git checkout -b change_siteSwitched to a new branch &#39;change_site&#39;$ vim runoob.php$ head -3 runoob.php&lt;?phpecho &#39;runoob&#39;;?&gt;$ git commit -am &#39;changed the runoob.php&#39;[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+)</code></pre><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><pre><code>$ git checkout masterSwitched to branch &#39;master&#39;$ cat runoob.php$ vim runoob.php    # 修改内容如下$ cat runoob.php&lt;?phpecho 1;?&gt;$ git diffdiff --git a/runoob.php b/runoob.phpindex e69de29..ac60739 100644--- a/runoob.php+++ b/runoob.php@@ -0,0 +1,3 @@+&lt;?php+echo 1;+?&gt;$ git commit -am &#39;修改代码&#39;[master c68142b] 修改代码 1 file changed, 3 insertions(+)</code></pre><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><pre><code>$ git merge change_siteAuto-merging runoob.phpCONFLICT (content): Merge conflict in runoob.phpAutomatic merge failed; fix conflicts and then commit the result.$ cat runoob.php     # 代开文件，看到冲突内容&lt;?php&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADecho 1;=======echo &#39;runoob&#39;;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site?&gt;</code></pre><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><pre><code>$ vim runoob.php $ cat runoob.php&lt;?phpecho 1;echo &#39;runoob&#39;;?&gt;$ git diffdiff --cc runoob.phpindex ac60739,b63d7d7..0000000--- a/runoob.php+++ b/runoob.php@@@ -1,3 -1,3 +1,4 @@@  &lt;?php +echo 1;+ echo &#39;runoob&#39;;  ?&gt;</code></pre><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p><pre><code>$ git status -sUU runoob.php$ git add runoob.php$ git status -sM  runoob.php$ git commit[master 88afe0e] Merge branch &#39;change_site&#39;</code></pre><p>现在我们成功解决了合并中的冲突，并提交了结果。</p><h2 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p><p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p><pre><code>$ git logcommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)Merge: c68142b 7774248Author: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:55:58 2019 +0800    Merge branch &#39;change_site&#39;commit c68142b562c260c3071754623b08e2657b4c6d5bAuthor: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:52:12 2019 +0800    修改代码commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)Author: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:49:26 2019 +0800    changed the runoob.phpcommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00Author: runoob &lt;test@runoob.com&gt;Date:   Fri May 3 15:35:32 2019 +0800</code></pre><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><pre><code>$ git log --oneline$ git log --onelined5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;c68142b 修改代码7774248 (change_site) changed the runoob.phpc1501a2 removed test.txt、add runoob.php3e92c19 add test.txt3b58100 第一次版本提交</code></pre><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><pre><code>*   d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;|\  | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/  * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交</code></pre><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</p><pre><code>$ git log --reverse --oneline3b58100 第一次版本提交3e92c19 add test.txtc1501a2 removed test.txt、add runoob.php7774248 (change_site) changed the runoob.phpc68142b 修改代码d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;</code></pre><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><pre><code>$ git log --author=Linus --oneline -581b50f3 Move &#39;builtin-*&#39; into a &#39;builtin/&#39; subdirectory3bb7256 make &quot;index-pack&quot; a built-in377d027 make &quot;git pack-redundant&quot; a built-inb532581 make &quot;git unpack-file&quot; a built-in112dd51 make &quot;mktag&quot; a built-in</code></pre><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><pre><code>$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges5469e2d Git 1.7.1-rc2d43427d Documentation/remote-helpers: Fix typos and improve language272a36b Fixup: Second argument may be any arbitrary stringb6c8d2d Documentation/remote-helpers: Add invocation section5ce4f4e Documentation/urls: Rewrite to accomodate transport::address00b84e9 Documentation/remote-helpers: Rewrite description03aa87e Documentation: Describe other situations where -z affects git diff77bc694 rebase-interactive: silence warning when no commits rewritten636db2c t3301: add tests to use --format=&quot;%N&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> version control </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程书籍推荐</title>
      <link href="/2019/05/13/book/"/>
      <url>/2019/05/13/book/</url>
      
        <content type="html"><![CDATA[<h3 id="编程书籍推荐"><a href="#编程书籍推荐" class="headerlink" title="编程书籍推荐"></a>编程书籍推荐</h3><p>这里是我平时所积累的一些有关编程的书籍，包括设计模式、网站架构、还有一些常用的中间件和面试指南等。</p><p>本站所有书籍下载地址均为不限速链接，永久有效。</p><h4 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5m6q35ihj30u0154b29.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la4pe" target="_blank" rel="noopener">剑指OFFER  名企面试官精讲典型编程题  第2版.PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5la3umw8j305a05aglw.jpg" alt></p><hr><h4 id="大话设计模式"><a href="#大话设计模式" class="headerlink" title="大话设计模式"></a>大话设计模式</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5m8a97tbj30u01441kz.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la3oh" target="_blank" rel="noopener">大话设计模式(带目录完整版).PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5lmdukzej305a05aaac.jpg" alt></p><hr><h4 id="大型网站系统与Java中间件实践"><a href="#大型网站系统与Java中间件实践" class="headerlink" title="大型网站系统与Java中间件实践"></a>大型网站系统与Java中间件实践</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mb9y3t2j30u013mnpe.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la2wj" target="_blank" rel="noopener">大型网站系统与Java中间件实践.PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mglgjvsj305a05a74k.jpg" alt></p><hr><h4 id="大型网站技术架构"><a href="#大型网站技术架构" class="headerlink" title="大型网站技术架构"></a>大型网站技术架构</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mkg7twuj30ta16ghdu.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la2cj" target="_blank" rel="noopener">大型网站技术架构 核心原理与案例分析-李智慧.PDF</a></p><p>手机下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mlh6n7kj305a05a0t0.jpg" alt></p><hr><h4 id="Spring源码深度剖析"><a href="#Spring源码深度剖析" class="headerlink" title="Spring源码深度剖析"></a>Spring源码深度剖析</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mpau0skj30u01241ky.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la21i" target="_blank" rel="noopener">Spring源码深度剖析.PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc5mq0z1pnj305a05adg4.jpg" alt></p><hr><h4 id="Spring技术内幕"><a href="#Spring技术内幕" class="headerlink" title="Spring技术内幕"></a>Spring技术内幕</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5msksrb5j30u0157npd.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la1de" target="_blank" rel="noopener">SPRING技术内幕：深入解析SPRING架构与设计原理.PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mtuls3lj305a05a0t0.jpg" alt></p><hr><h4 id="Spring-Boot实战"><a href="#Spring-Boot实战" class="headerlink" title="Spring Boot实战"></a>Spring Boot实战</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5mxirk69j30u011pnpd.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la15g" target="_blank" rel="noopener">Spring Boot实战 ,丁雪丰(译者).PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5myik23cj305a05a74k.jpg" alt></p><hr><h4 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5n1x4cetj30u012du0x.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la13e" target="_blank" rel="noopener">Redis实战.PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5n09zh7dj305a05at8z.jpg" alt></p><hr><h4 id="Java并发编程实践"><a href="#Java并发编程实践" class="headerlink" title="Java并发编程实践"></a>Java并发编程实践</h4><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5n4jt76pj30u013wx6p.jpg" alt></p><p>下载链接：<a href="https://www.lanzous.com/i9la0mh" target="_blank" rel="noopener">JAVA并发编程实践-带书签-完整版.PDF</a></p><p>手机扫码下载：<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybply1gc5n3i17wbj305a05a74k.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影视作品推荐</title>
      <link href="/2019/04/26/film/"/>
      <url>/2019/04/26/film/</url>
      
        <content type="html"><![CDATA[<h2 id="电影推荐"><a href="#电影推荐" class="headerlink" title="电影推荐"></a>电影推荐</h2><h3 id="《魔戒》三部曲"><a href="#《魔戒》三部曲" class="headerlink" title="《魔戒》三部曲"></a>《魔戒》三部曲</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/1349.html" target="_blank" rel="noopener">指环王1：魔戒再现</a>｜<a href="http://yyid6080.cn/vod/detail/id/1350.html" target="_blank" rel="noopener">指环王2：双塔奇兵</a>｜<a href="http://yyid6080.cn/vod/detail/id/1351.html" target="_blank" rel="noopener">指环王3：王者无敌</a></p><p>百度网盘：<a href="https://pan.baidu.com/share/init?surl=lhlly5eaQd_MLyNMWE3q-A" target="_blank" rel="noopener">魔戒1～3加长版</a>——提取码：kq44</p><p>剧情简介：年轻的哈比族人佛罗多巴金从叔叔巴伯那里得到了一只魔戒。佛罗多发现这只戒指的制造者是黑暗魔君索伦，而索伦正急著要把戒指找回去。因为这只戒指是代表邪恶势力的魔戒，将使索伦统治下的中土世与界的人民得到解放…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9ltdbsq0j30nj0e4ql7.jpg" alt></p><h3 id="《霍比特人》三部曲"><a href="#《霍比特人》三部曲" class="headerlink" title="《霍比特人》三部曲"></a>《霍比特人》三部曲</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/1140.html" target="_blank" rel="noopener">霍比特人1：意外之旅</a>｜<a href="http://yyid6080.cn/vod/detail/id/1141.html" target="_blank" rel="noopener">霍比特人2：史矛革之战</a>｜<a href="http://yyid6080.cn/vod/detail/id/1142.html" target="_blank" rel="noopener">霍比特人3：五军之战</a></p><p>百度网盘：<a href="https://pan.baidu.com/share/init?surl=VhXrHCGol3WsZTCqSmGUNA" target="_blank" rel="noopener">霍比特人1～3</a>——提取码：5cmu</p><p>剧情简介：《霍比特人》的故事大致发生在《魔戒》三部曲之前60年左右，讲述弗罗多的叔叔——“霍比特人”比尔博·巴金斯（马丁·弗瑞曼 饰）的冒险历程。他被卷入了一场收回矮人的藏宝地孤山的旅程——这个地方被恶龙史矛革 …</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9mdkbpz8j31hc0r0n1h.jpg" alt></p><h3 id="《暮光之城》四部曲"><a href="#《暮光之城》四部曲" class="headerlink" title="《暮光之城》四部曲"></a>《暮光之城》四部曲</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/3749.html" target="_blank" rel="noopener">暮光之城1～4</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1VJ1-xYY3BpAb0I_ywbmKXw" target="_blank" rel="noopener">暮色-Twilight</a>｜<a href="https://pan.baidu.com/s/1P1x44AHn1nBzx4ogShnDFg" target="_blank" rel="noopener">新月-New Moon</a> ｜ <a href="https://pan.baidu.com/s/1jk9XyFU-WuOp419xsMJGAQ" target="_blank" rel="noopener">月食-Eclipse</a> ｜ <a href="https://pan.baidu.com/s/1dWr3yincCubHo7ywBWbuIQ" target="_blank" rel="noopener">破晓-Breaking Dawn</a></p><p>剧情简介：贝拉即将毕业，她与爱德华在婚姻问题尚有分歧。雅各布看到爱德华与贝拉依旧如胶似漆，内心十分挣扎。贝拉的衣物神秘被盗，同时爱丽丝感到昔日库伦家族的维多利亚正在准备为死去的詹姆斯复仇…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gav44bz8znj30xc0hgael.jpg" alt></p><h3 id="《哪吒之魔童降世》"><a href="#《哪吒之魔童降世》" class="headerlink" title="《哪吒之魔童降世》"></a>《哪吒之魔童降世》</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/11415.html" target="_blank" rel="noopener">哪吒之魔童降世</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1aZanceRmOLPu8fFu41CXJg" target="_blank" rel="noopener">哪吒之魔童降世</a></p><p>剧情简介：天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gav4vkfycmj31hc0u0dmf.jpg" alt></p><h3 id="《地球停转之日》"><a href="#《地球停转之日》" class="headerlink" title="《地球停转之日》"></a>《地球停转之日》</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/1456.html" target="_blank" rel="noopener">地球停转之日</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1nwM4A6X" target="_blank" rel="noopener">地球停转之日</a></p><p>剧情简介：某晚，太空微生物学教授海伦•本森被几名神秘人物带走，与她一同前往新泽西林伍德军校的还有业界内无数顶尖科学家。原来，NASA在探测外太空时发现有一不明物体正飞速接近地球。不久，一个闪耀着白色光芒的物体降 …</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9kpqbptkj30zk0k0gr6.jpg" alt></p><h3 id="《阿丽塔：战斗天使》"><a href="#《阿丽塔：战斗天使》" class="headerlink" title="《阿丽塔：战斗天使》"></a>《阿丽塔：战斗天使》</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/9263.html" target="_blank" rel="noopener">阿丽塔：战斗天使</a></p><p>剧情简介：故事设定在26世纪，那时科技已经可以重塑人类的大部分器官，不少人都换上了机械的身体。主人公艾德某天在垃圾堆里找到一个少女的机械残躯。艾德把她救活并将其命名为阿丽塔，但她已失去了以前的记忆。在一次偶然的机会下，艾德发现阿丽塔原来有着超强的战斗力，注定了她的使命就是要不停的战斗……</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9lflqh5mj30sg0cqtar.jpg" alt></p><h3 id="《侏罗纪世界》"><a href="#《侏罗纪世界》" class="headerlink" title="《侏罗纪世界》"></a>《侏罗纪世界》</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/1600.html" target="_blank" rel="noopener">侏罗纪世界1</a>｜<a href="http://yyid6080.cn/vod/detail/id/6695.html" target="_blank" rel="noopener">侏罗纪世界2</a>｜<a href="http://yyid6080.cn/vod/detail/id/4147.html" target="_blank" rel="noopener">侏罗纪公园1~3</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1EZl_Pa8DelgjOddlp2wr9A" target="_blank" rel="noopener">侏罗纪世界1</a>｜<a href="https://pan.baidu.com/s/1pczbMaB40-xpss5WrkMElQ" target="_blank" rel="noopener">侏罗纪世界2</a>｜<a href="https://pan.baidu.com/s/1Kumb7lxMpzqNkkqDR4N1Ew#list/path=%2F%5B侏L纪G园%201~3%5D%5B%20微信公众号%20莉音音%20%5D" target="_blank" rel="noopener">侏罗纪公园1~3</a></p><p>《侏罗纪公园》故事发生的22年后，纳布拉尔岛已经发展成为一个庞大的主题公园和度假胜地——侏罗纪世界。游客可以乘着船、驾着车，或者坐在透明的旋转球里欣赏身边的恐龙…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9khts9xxj30rs0bk0v4.jpg" alt></p><h3 id="《超级战舰》"><a href="#《超级战舰》" class="headerlink" title="《超级战舰》"></a>《超级战舰》</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/2892.html" target="_blank" rel="noopener">超级战舰</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1ldtuKA8NsoQLO-dziLZKgQ#list/path=%2F" target="_blank" rel="noopener">超级战舰</a></p><p>剧情简介：NASA在2005年的时候发现了一个太阳系外的类地行星，判断可能存在智慧生命。为了能与外星智慧生物接触，在夏威夷启用深空通信阵列基地，发射高功率信号进行试探。几年后外星飞船不期而至…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9kygfkdqg30dw05sqv5.gif" alt><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9kyn0762g30dw05sb2a.gif" alt></p><h2 id="电视剧推荐"><a href="#电视剧推荐" class="headerlink" title="电视剧推荐"></a>电视剧推荐</h2><h3 id="《安家》"><a href="#《安家》" class="headerlink" title="《安家》"></a>《安家》</h3><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/12415.html" target="_blank" rel="noopener">安家</a></p><p>剧情简介：房似锦年方28已经是安家天下中介公司的金字招牌，她在上司翟云霄的授意之下，空降静宜门店担任双店长。门店原生店长徐文昌是个“高贵的人”，他推崇“人性流”管理方式，也不屑对付手段卑鄙的对手。到任后房似锦施展雷霆手段坚壁清野，对外辣手反击，对内冷血整肃…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/0082zybpgy1gc9jzev3x8j30io0a0akh.jpg" alt></p><h2 id="动漫推荐"><a href="#动漫推荐" class="headerlink" title="动漫推荐"></a>动漫推荐</h2><h3 id="国产动漫"><a href="#国产动漫" class="headerlink" title="国产动漫"></a>国产动漫</h3><h4 id="《一人之下2》"><a href="#《一人之下2》" class="headerlink" title="《一人之下2》"></a>《一人之下2》</h4><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/3356.html" target="_blank" rel="noopener">一人之下2</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1dtrTsKTZJ46TTWIPL-8IgQ" target="_blank" rel="noopener">一人之下2</a></p><p>剧情简介：这个世界是存在异人的。张楚岚为了揭开爷爷当年的真相，和冯宝宝一起前往龙虎山天师府参加异人界的盛会——罗天大醮，并与众多异人高手对战…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gav93ln73og30dw089wzl.gif" alt></p><h3 id="日漫"><a href="#日漫" class="headerlink" title="日漫"></a>日漫</h3><h4 id="《鬼灭之刃》"><a href="#《鬼灭之刃》" class="headerlink" title="《鬼灭之刃》"></a>《鬼灭之刃》</h4><p>在线观看：<a href="http://yyid6080.cn/vod/detail/id/10265.html" target="_blank" rel="noopener">鬼灭之刃</a></p><p>百度网盘：<a href="https://pan.baidu.com/s/1un1OBiJYg00Y9mVqoIZ28Q" target="_blank" rel="noopener">鬼灭之刃</a></p><p>剧情简介：日本大正时期，那是一个吃人的恶鬼横行的世界，一名家人被鬼杀死，妹妹也变成了鬼的主人公炭治郎，在猎鬼人的指引下，成为了鬼猎人组织“鬼杀队”的一员，为了让妹妹祢豆子变回人类，为了讨伐杀害家人的恶鬼，为了斩断悲伤的连锁而展开了战斗…</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gauvwkc51ag30e80801ky.gif" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> film </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap底层原理</title>
      <link href="/2019/04/18/HashMap/"/>
      <url>/2019/04/18/HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap的底层原理"><a href="#HashMap的底层原理" class="headerlink" title="HashMap的底层原理"></a>HashMap的底层原理</h2><p>HashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p><p>Hashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。</p><h3 id="Put方法的原理"><a href="#Put方法的原理" class="headerlink" title="Put方法的原理"></a>Put方法的原理</h3><p>比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数：<strong>index = Hash（“apple”）</strong>来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。<a id="more"></a></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9a1hu4j30ji06fq3g.jpg" alt></p><p>这时我们可以通过<strong>链表</strong>来解决。需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为：<strong>后插入的Entry被查找的可能性更大</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9i7blpj30ju06wjrw.jpg" alt></p><h3 id="Get方法的原理"><a href="#Get方法的原理" class="headerlink" title="Get方法的原理"></a>Get方法的原理</h3><p>首先会把需要查询的key做一次Hash映射，得到对应的下标，由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gayreaylimj30jf07tt9n.jpg" alt></p><h2 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h2><h3 id="HashMap的默认初始长度"><a href="#HashMap的默认初始长度" class="headerlink" title="HashMap的默认初始长度"></a>HashMap的默认初始长度</h3><p>HashMap的默认初始长度是16，并且每次自动扩展或是手动初始化时，长度必须是2的幂。</p><h3 id="为什么这样设置？"><a href="#为什么这样设置？" class="headerlink" title="为什么这样设置？"></a>为什么这样设置？</h3><p>为了使Hash算法得到的index尽可能均匀分布。例如从Key映射到HashMap数组的对应位置时，会用到一个Hash函数：<strong>index = HashCode（Key） &amp; （Length - 1）</strong>，为了实现高效的Hash算法，采用位运算（与运算）</p><h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><p>HashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行<strong>Resize</strong>。</p><h3 id="影响Resize的两个因素"><a href="#影响Resize的两个因素" class="headerlink" title="影响Resize的两个因素"></a>影响Resize的两个因素</h3><ol><li><p>Capacity</p><p>HashMap的当前长度。</p></li><li><p>LoadFactor</p><p>HashMap负载因子，默认值为0.75f。</p></li></ol><p>衡量HashMap是否需要进行Resize的条件如下：</p><p><strong>HashMap.Size  &gt;= Capacity * LoadFactor</strong></p><h3 id="Resize做了什么？"><a href="#Resize做了什么？" class="headerlink" title="Resize做了什么？"></a>Resize做了什么？</h3><ol><li><p>扩容</p><p>创建一个新的Entry空数组，长度是原数组的2倍。</p></li><li><p>Rehash</p><p>遍历原Entry数组，把所有的Entry重新Hash到新数组。</p></li></ol><p><strong>为什么要重新Hash呢？</strong></p><p>因为长度扩大以后，Hash的规则也随之改变。（16=1111；32=11111）</p><p><strong>ReHash的Java代码如下：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么HashMap会出现死锁"><a href="#为什么HashMap会出现死锁" class="headerlink" title="为什么HashMap会出现死锁"></a>为什么HashMap会出现死锁</h3><p>在高并发情况下，如果HashMap正好达到临界点准备扩容，此时正好有两个线程在同时访问，在Rehash时链表可能会产生环形，当调用Get查找一个不存在的key，而这个key的Hash结果恰好位于环形链表处，这时程序将会进入死循环。</p><h2 id="JDK1-8下的HashMap优化"><a href="#JDK1-8下的HashMap优化" class="headerlink" title="JDK1.8下的HashMap优化"></a>JDK1.8下的HashMap优化</h2><h3 id="引入红黑树"><a href="#引入红黑树" class="headerlink" title="引入红黑树"></a>引入红黑树</h3><p>我们知道，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦拉链过长则会严重影响HashMap的性能，所以JDK1.8版本引入了红黑树：当链表长度太长（默认超过8）时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p><h3 id="Resize扩容优化"><a href="#Resize扩容优化" class="headerlink" title="Resize扩容优化"></a>Resize扩容优化</h3><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap底层实现</title>
      <link href="/2019/03/19/ConcurrentHashMap/"/>
      <url>/2019/03/19/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Segment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg" alt></p><a id="more"></a><p>可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。这样的二级结构，和数据库的水平拆分有些相似。</p><p>ConcurrentHashMap优势就是采用了[锁分段]技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。</p><h3 id="并发读写的情况"><a href="#并发读写的情况" class="headerlink" title="并发读写的情况"></a>并发读写的情况</h3><ol><li><p>不同Segment的并发写入——<strong>可以并发执行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazahwt8gmj30hs083jrj.jpg" alt></p></li><li><p>同一Segment的一写一读——<strong>可以并发执行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazai5be4aj30jv07wgmh.jpg" alt></p></li><li><p>同一Segment的并发写入——<strong>会发生阻塞</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gazaicuv2mj30k1081q3s.jpg" alt></p></li></ol><p>Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。</p><p>由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p><h2 id="ConcurrentHashMap读写过程"><a href="#ConcurrentHashMap读写过程" class="headerlink" title="ConcurrentHashMap读写过程"></a>ConcurrentHashMap读写过程</h2><h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><ol><li>为输入的Key做Hash运算，得到hash值。</li><li>通过hash值，定位到对应的Segment对象</li><li>再次通过hash值，定位到Segment当中数组的具体位置。</li></ol><h3 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a>Put方法</h3><ol><li>为输入的Key做Hash运算，得到hash值。</li><li>通过hash值，定位到对应的Segment对象</li><li>获取可重入锁</li><li>再次通过hash值，定位到Segment当中数组的具体位置。</li><li>插入或覆盖HashEntry对象。</li><li>释放锁。</li></ol><p><strong>从步骤中可以看出，ConcurrentHashMap在读写时都需要二次定位。首先定位到Segment，然后定位到Segment内的具体数组下标。</strong></p><h2 id="ConcurrentHashMap的Size方法"><a href="#ConcurrentHashMap的Size方法" class="headerlink" title="ConcurrentHashMap的Size方法"></a>ConcurrentHashMap的Size方法</h2><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：</p><ol><li>遍历所有的Segment。</li><li>把Segment的元素数量累加起来。</li><li>把Segment的修改次数累加起来。</li><li>判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li><li>如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。</li><li>再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。</li><li>释放锁，统计结束。</li></ol><h3 id="官方代码"><a href="#官方代码" class="headerlink" title="官方代码"></a>官方代码</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Try a few times to get accurate count. On failure due to</span>   <span class="token comment" spellcheck="true">// continuous async changes in table, resort to locking.</span>   <span class="token keyword">final</span> Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>segments<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> overflow<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true if size overflows 32 bits</span>    <span class="token keyword">long</span> sum<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// sum of modCounts</span>    <span class="token keyword">long</span> last <span class="token operator">=</span> 0L<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// previous sum</span>    <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// first iteration isn't retry</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>retries<span class="token operator">++</span> <span class="token operator">==</span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>                    <span class="token function">ensureSegment</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// force creation</span>            <span class="token punctuation">}</span>            sum <span class="token operator">=</span> 0L<span class="token punctuation">;</span>            size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            overflow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Segment<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> seg <span class="token operator">=</span> <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>seg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sum <span class="token operator">+=</span> seg<span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>                    <span class="token keyword">int</span> c <span class="token operator">=</span> seg<span class="token punctuation">.</span>count<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>size <span class="token operator">+=</span> c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                        overflow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> last<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            last <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>retries <span class="token operator">></span> RETRIES_BEFORE_LOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> segments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>                <span class="token function">segmentAt</span><span class="token punctuation">(</span>segments<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> overflow <span class="token operator">?</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>这种思想和乐观锁悲观锁的思想如出一辙。</p><p>为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。</p><h2 id="ConcurrentHashMap的扩容机制"><a href="#ConcurrentHashMap的扩容机制" class="headerlink" title="ConcurrentHashMap的扩容机制"></a>ConcurrentHashMap的扩容机制</h2><p>当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。</p><h2 id="JDK1-8下做了哪些优化"><a href="#JDK1-8下做了哪些优化" class="headerlink" title="JDK1.8下做了哪些优化"></a>JDK1.8下做了哪些优化</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>JDK1.8 放弃了分段锁Segment而是用了Node，采用了 CAS + synchronized 来保证并发安全性，降低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>ConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说JDK1.8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 高并发 </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字解析</title>
      <link href="/2019/03/15/volatile/"/>
      <url>/2019/03/15/volatile/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile是什么"><a href="#volatile是什么" class="headerlink" title="volatile是什么"></a>volatile是什么</h2><p>volatile是Java虚拟机提供的<strong>轻量级</strong>的<strong>同步</strong>机制。（轻量级的synchronized）</p><h2 id="volatile的特性"><a href="#volatile的特性" class="headerlink" title="volatile的特性"></a>volatile的特性</h2><ol><li><strong>保证可见性</strong></li><li><strong>不保证原子性</strong></li><li><strong>禁止指令重排序</strong></li></ol><p>volatile保证了变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则（先行发生原则）。不保证原子性，阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</p><h2 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h2><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<a id="more"></a></p><h3 id="JMM的三大特性"><a href="#JMM的三大特性" class="headerlink" title="JMM的三大特性"></a>JMM的三大特性</h3><ol><li>可见性</li><li>原子性（volatile不保证原子性，synchronized可保证）</li><li>有序性</li></ol><h3 id="JMM关于同步的规定"><a href="#JMM关于同步的规定" class="headerlink" title="JMM关于同步的规定"></a>JMM关于同步的规定</h3><ol><li>线程解锁前，必须把共享变量的值刷新回主内存。</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存。</li><li>加锁解锁是同一把锁。</li></ol><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<strong>但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存</strong>，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p><h3 id="主内存（Main-Memory）"><a href="#主内存（Main-Memory）" class="headerlink" title="主内存（Main Memory）"></a>主内存（Main Memory）</h3><p>主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。</p><h3 id="工作内存（Working-Memory）"><a href="#工作内存（Working-Memory）" class="headerlink" title="工作内存（Working Memory）"></a>工作内存（Working Memory）</h3><p>工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。</p><h3 id="为什么线程不直接操作主内存？"><a href="#为什么线程不直接操作主内存？" class="headerlink" title="为什么线程不直接操作主内存？"></a>为什么线程不直接操作主内存？</h3><p>直接操作主内存太慢了，工作内存类似于高速缓存，访问速度更快。</p><h2 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h2><p>当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。为什么volatile关键字可以有这样的特性？这得益于java语言的<strong>先行发生原则</strong>（happens-before）。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。</p><p>这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。</p><h3 id="可见性demo"><a href="#可见性demo" class="headerlink" title="可见性demo"></a>可见性demo</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyData</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addTo60</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileSee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">final</span> MyData myData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                myData<span class="token punctuation">.</span><span class="token function">addTo60</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" come in "</span><span class="token operator">+</span>myData<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>myData<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" come in "</span><span class="token operator">+</span>myData<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不保证原子性demo"><a href="#不保证原子性demo" class="headerlink" title="不保证原子性demo"></a>不保证原子性demo</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileTest</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//开启10个线程</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>          <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span><span class="token punctuation">{</span>              Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>              e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//每个线程当中让count值自增100次</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"count="</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//例子中的实际值要小于1000.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="volatile的适用范围"><a href="#volatile的适用范围" class="headerlink" title="volatile的适用范围"></a>volatile的适用范围</h3><ol start="2"><li><p><strong>运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</strong>。</p></li><li><p><strong>变量不需要与其他的状态变量共同参与不变约束</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>线程A执行如下代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//do something</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>线程B执行如下代码：</p><pre class="line-numbers language-java"><code class="language-java">start<span class="token operator">+=</span><span class="token number">3</span><span class="token punctuation">;</span>end<span class="token operator">+=</span><span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。</p></li></ol><h2 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h2><p>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。</p><h3 id="指令重排的目的"><a href="#指令重排的目的" class="headerlink" title="指令重排的目的"></a>指令重排的目的</h3><p>为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p><h2 id="volatile的内存屏障"><a href="#volatile的内存屏障" class="headerlink" title="volatile的内存屏障"></a>volatile的内存屏障</h2><h3 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h3><p>内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。</p><h3 id="内存屏障的-4-种类型"><a href="#内存屏障的-4-种类型" class="headerlink" title="内存屏障的 4 种类型"></a>内存屏障的 4 种类型</h3><p><strong>LoadLoad屏障</strong>：</p><p>抽象场景：Load1; LoadLoad; Load2</p><p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p><p><strong>StoreStore屏障：</strong></p><p>抽象场景：Store1; StoreStore; Store2</p><p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见</p><p><strong>LoadStore屏障：</strong></p><p>抽象场景：Load1; LoadStore; Store2</p><p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p><p><strong>StoreLoad屏障：</strong></p><p>抽象场景：Store1; StoreLoad; Load2</p><p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。</p><h3 id="volatile如何防止指令重排"><a href="#volatile如何防止指令重排" class="headerlink" title="volatile如何防止指令重排"></a>volatile如何防止指令重排</h3><p>在一个变量被volatile修饰后，JVM会为我们做两件事：</p><ol><li>在每个volatile写操作前插入<strong>StoreStore</strong>屏障，在写操作后插入<strong>StoreLoad</strong>屏障。</li><li>在每个volatile读操作前插入<strong>LoadLoad</strong>屏障，在读操作后插入<strong>LoadStore</strong>屏障。</li></ol><p>从而成功阻止了指令重排序。</p><h2 id="volatile在单例模式中的体现"><a href="#volatile在单例模式中的体现" class="headerlink" title="volatile在单例模式中的体现"></a>volatile在单例模式中的体现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Singleton instance<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//私有化构造函数</span>      <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//提供获取实例的方法</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span>SingletonClass<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10系统激活，内附激活码和激活软件</title>
      <link href="/2019/03/10/win-activation/"/>
      <url>/2019/03/10/win-activation/</url>
      
        <content type="html"><![CDATA[<h2 id="本文提供两种激活方式，随意选择"><a href="#本文提供两种激活方式，随意选择" class="headerlink" title="本文提供两种激活方式，随意选择"></a>本文提供两种激活方式，随意选择</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ol><li><p>启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg" alt></p><a id="more"></a></li><li><p>在开始菜单处点击鼠标右键，选择Windows PowerShell（管理员）。<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gara1vmqssj30aq0icaau.jpg" alt></p></li><li><p>此时将“以管理员身份”打开“MSDOS”窗口，在此界面中输入：slmgr.vbs /upk，按回车进行确定。<img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1gara4r1m07j30cd040dft.jpg" alt></p></li><li><p>此时弹出窗口显未“已成功卸载了产品密钥”</p></li><li><p>接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</p></li><li><p>弹出窗口提示：“成功的安装了产品密钥”。</p></li><li><p>继续输入以下命令：slmgr /skms zh.us.to</p></li><li><p>弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。</p></li><li><p>接下来输入以下命令：slmgr /ato此时将弹出窗口提示：“成功的激活了产品”。</p></li><li><p>最后就可以再次查看当前Win10专业版系统的激活状态啦。</p></li></ol><p>以上只演示了Win10专业版系统的激活方法，如果大家拥有Win10正式版其它系统版本的密钥，也可以利用类似的操作方法进行激活。</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>激活软件下载链接:<a href="https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ" target="_blank" rel="noopener">https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ</a>  密码:md2f</p><p>此软件还附带激活Office功能，在我的电脑上右键查看属性，就可以看到系统的激活状态了。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/006tNbRwgy1garaedv33mj30ol0gg75z.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> activation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS算法原理</title>
      <link href="/2019/02/28/CAS/"/>
      <url>/2019/02/28/CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CAS？"><a href="#什么是CAS？" class="headerlink" title="什么是CAS？"></a>什么是CAS？</h2><p><strong>CAS的全称是Compare and Swap，比较并交换，它是一条CPU并发原语。</strong></p><p>它的功能是判断内存中某个位置的值是否为预期值，如果是则改为新的值，这个过程是<strong>原子的</strong>。</p><p>CAS并发原语体现在Java中就是sun.misc.Unsafe类中的各个方法。调用<strong>Unsafe类（rt.jar 原生类）</strong>中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语（原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程），<strong>原语的执行必须是连续的，在执行过程中不允许被中断，所以说CAS是一条CPU的原子指令</strong>。</p><h2 id="CAS算法思想"><a href="#CAS算法思想" class="headerlink" title="CAS算法思想"></a>CAS算法思想</h2><p>CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p><p>AtomicInteger.incrementAndGet的实现用了乐观锁技术，调用了类sun.misc.Unsafe库里面的 CAS算法，用CPU指令来实现无锁自增。所以，AtomicInteger.incrementAndGet的自增比用synchronized的锁效率倍增。</p><p>Unsafe类+CAS思想（<strong>自旋</strong>）</p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><ol><li>如果CAS长时间一直不成功，会给CPU带来很大的开销。</li><li>只能保证一个共享变量的原子操作。</li><li><strong>CAS导致ABA问题</strong>。(重点)</li></ol><h3 id="什么是ABA问题"><a href="#什么是ABA问题" class="headerlink" title="什么是ABA问题"></a>什么是ABA问题</h3><p>CAS算法实现的一个重要前提是需要取出内存中某时刻的数据并在当下时刻比较并替换，这个时间差里会导致数据的变化。</p><p>比如说有一个线程one从内存V位置中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，紧接着two又将值变为A，这时候one进行CAS操作发现内存中仍然是A，然后线程one操作成功。</p><p>尽管线程one的CAS操作成功，但是不代表这个过程就是没问题的。</p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcd9qffodsj31950estmf.jpg" alt></p><h3 id="原子引用更新"><a href="#原子引用更新" class="headerlink" title="原子引用更新"></a>原子引用更新</h3><ul><li><p><strong>AtomicReference</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gcd9e0qgnwj315i0eqqc6.jpg" alt></p></li></ul><h3 id="如何规避ABA问题"><a href="#如何规避ABA问题" class="headerlink" title="如何规避ABA问题"></a>如何规避ABA问题</h3><p>原子引用 + 版本号机制（类似时间戳），使用<strong>AtomicStampedReference</strong>来解决ABA问题。</p><h2 id="CAS延伸"><a href="#CAS延伸" class="headerlink" title="CAS延伸"></a>CAS延伸</h2><h3 id="为什么用CAS不用synchronized？"><a href="#为什么用CAS不用synchronized？" class="headerlink" title="为什么用CAS不用synchronized？"></a>为什么用CAS不用synchronized？</h3><p>synchronized加锁，同一时间段只允许一个线程访问，一致性得到了保障，但是并发性下降。</p><p>CAS没有加锁，可以反复通过CAS比较，既保证了一致性，又提高了并发性。</p><h3 id="Atomic-中的-incrementAndGet与-getAndIncrement-两个方法的区别"><a href="#Atomic-中的-incrementAndGet与-getAndIncrement-两个方法的区别" class="headerlink" title="Atomic 中的 incrementAndGet与 getAndIncrement 两个方法的区别"></a>Atomic 中的 incrementAndGet与 getAndIncrement 两个方法的区别</h3><ul><li><p><strong>incrementAndGet()</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>getAndIncrement()</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>通过分析源码可知，incrementAndGet()和getAndIncrement()都调用了Unsafe类中的<strong>getAndAddInt()</strong>方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> var5<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> var5<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>区别</strong></p><p>两个方法处理的方式都是一样的，区别在于getAndIncrement()方法是返回旧值（即加1前的原始值），而incrementAndGet()返回的是新值（即加1后的值）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于zk实现分布式锁</title>
      <link href="/2018/06/04/zk-lock/"/>
      <url>/2018/06/04/zk-lock/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>对于单进程的并发场景，我们可以使用synchronized关键字和Reentrantlock类等。</p><p>对于分布式场景，我们可以使用分布式锁。</p><p>分布式锁的实现方式有很多种，zk是实现起来相对简单的。相比与redis分布式锁，zk有以下优势：</p><ul><li>redis分布式锁需要不断去尝试获取锁，比较耗性能。zk分布式锁获取不到锁注册个监听器即可。</li><li>redis获取锁的客户端挂了，只能等待超时之后再释放锁，zk是基于临时节点，挂了znode就没了，自动释放。</li></ul><h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><h4 id="创建锁"><a href="#创建锁" class="headerlink" title="创建锁"></a>创建锁</h4><p>多个jvm服务器之间，同时在zookeeper上创建相同的一个<strong>临时节点</strong>，因为临时节点路径是保证唯一，<br>只要谁能够创建节点成功，谁就能够获取到锁，<br>没有创建成功节点，只能注册个监听器监听这个锁并进行等待，当释放锁的时候，采用事件通知给其它客户端重新获取锁的资源。这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入获取锁的步骤。</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>Zookeeper使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，<br>如果session会话连接关闭的话，该临时节点也会被删除。这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入到获取锁的步骤。</p><h3 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3><p>独占锁又称排它锁，从字面意思上很容易理解他们的用途。即如果某个操作 O1 对访问资源 R1 的过程加锁，在操作 O1 结束对资源 R1 访问前，其他操作不允许访问资源 R1。我们先看张图：</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gd527kbsn8j30ma0c2jrs.jpg" alt="图1-独占锁示意图" style="zoom:50%;"><p>如上图，对于独占锁，我们可以将 lock 节点看做是资源 R1，操作 O1 访问资源 R1 看做创建 lock 节点，释放资源 R1 看做删除 lock 节点。这样我们就将独占锁的定义对应于具体的 zookeeper 节点结构，通过创建 lock 节点获取锁，删除节点释放锁。详细的过程如下：</p><p>1、多个客户端竞争创建 lock 临时节点；</p><p>2、其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher；</p><p>3、持有锁的客户端删除 lock 节点或该客户端崩溃，由 zookeeper 删除 lock 节点；</p><p>4、其他客户端获得 lock 节点被删除的通知；</p><p>5、重复上述4个步骤，直至无客户端在等待获取锁了。</p><p><strong>独占锁的流程图如下：</strong></p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gd52dt7lr5j30xq0mk77c.jpg" alt="图2-独占锁流程图" style="zoom: 50%;"><hr><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>说完独占锁的实现，下面来说说读写锁的实现。读写锁包含一个读锁和写锁，操作 O1 对资源 R1 加读锁，且获得了锁，其他操作可同时对资源 R1 设置读锁，进行共享读操作。</p><p>如果操作 O1 对资源 R1 加写锁，且获得了锁，其他操作再对资源 R1 设置不同类型的锁都会被阻塞。总结来说，<strong>读锁具有共享性，而写锁具有排他性</strong>。那么在 zookeeper 中，我们可以用怎样的节点结构实现上面的操作呢？</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gd52hcudmsj30tc0i6myj.jpg" alt="图3-读写锁示意图" style="zoom:50%;"><p>在 zookeeper 中，由于读写锁和独占锁的节点结构不同，读写锁的客户端不用再去竞争创建 lock 节点。所以在一开始，所有的客户端都会创建自己的锁节点。如果不出意外，所有的锁节点都能被创建成功，此时锁节点结构如上图所示。之后，客户端从 zookeeper 端获取 /share_lock 下所有的子节点，并判断自己能否获取锁。如果客户端创建的是<strong>读锁</strong>节点，获取锁的条件（满足其中一个即可）</p><blockquote><p>1、自己创建的节点序号排在所有其他子节点前面；</p><p>2、自己创建的节点前面无写锁节点。</p></blockquote><p>如果客户端创建的是写锁节点，由于写锁具有排他性。所以获取锁的条件要简单一些：</p><blockquote><p>只需确定自己创建的锁节点是否排在其他子节点前面即可。</p></blockquote><p>不同于独占锁，读写锁的实现稍微复杂一些。读写锁有两种实现方式，各有异同，接下来就来说说这两种实现方式。</p><h4 id="读写锁的第一种实现"><a href="#读写锁的第一种实现" class="headerlink" title="读写锁的第一种实现"></a>读写锁的第一种实现</h4><p>第一种实现是对 /sharelock 节点设置 watcher，当 /sharelock 下的子节点被删除时，未获取锁的客户端收到 /share_lock 子节点变动的通知。在收到通知后，客户端重新判断自己创建的子节点是否可以获取锁，如果失败，再次等待通知。详细流程如下：</p><p>1、所有客户端创建自己的锁节点；</p><p>2、从 zookeeper 端获取 /sharelock 下所有的子节点，并对 /sharelock 节点设置 watcher；</p><p>3、判断自己创建的锁节点是否可以获取锁，如果可以，持有锁。否则继续等待；</p><p>4、持有锁的客户端删除自己的锁节点，其他客户端收到 /share_lock 子节点变动的通知；</p><p>5、重复步骤2、3、4，直至无客户端在等待获取锁了。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gd52movc4wj30ry0sqwhy.jpg" alt="图4-读写锁的第一种实现" style="zoom:50%;"><p>上面获取读写锁流程并不复杂，但却存在性能问题。以图3所示锁节点结构为例，第一个锁节点 host1-W-0000000001 被移除后，zookeeper 会将 /share_lock 子节点变动的通知分发给所有的客户端。</p><p>但实际上，该子节点变动通知除了能影响 host2-R-0000000002 节点对应的客户端外，分发给其他客户端则是在做无用功，因为其他客户端即使获取了通知也无法获取锁。所以这里需要做一些优化，优化措施是让客户端只在自己关心的节点被删除时，再去获取锁。</p><h4 id="读写锁的第二种实现"><a href="#读写锁的第二种实现" class="headerlink" title="读写锁的第二种实现"></a>读写锁的第二种实现</h4><p>在了解读写锁第一种实现的弊端后，我们针对这一实现进行优化。这里客户端不再对 /share_lock 节点进行监视，而只对自己关心的节点进行监视。比如图3中host2-R-0000000002 对应的客户端 C2 只需监视 host1-W-0000000001 节点是否被删除，而 host3-W-0000000003 对应的客户端 C3 只需监视 host2-R-0000000002 节点是否被删除即可。</p><p>这里总结一下，不同客户端关心的锁节点是不同的。如果客户端创建的是读锁节点，那么客户端只需找出比读锁节点序号小的最后一个的写锁节点，并设置 watcher 即可。而如果是写锁节点，则更简单，客户端仅需对该节点的上一个节点设置 watcher 即可。详细的流程如下：</p><p>1、所有客户端创建自己的锁节点；</p><p>2、从 zookeeper 端获取 /share_lock 下所有的子节点；</p><p>3、判断自己创建的锁节点是否可以获取锁，如果可以，持有锁。否则对自己关心的锁节点设置 watcher；</p><p>4、持有锁的客户端删除自己的锁节点，某个客户端收到该节点被删除的通知，并获取锁；</p><p>5、重复步骤4，直至无客户端在等待获取锁了。</p><img src="https://cdn.jsdelivr.net/gh/lishaojie1993/lishaojie1993.github.io/medias/loading.gif" data-original="https://tva1.sinaimg.cn/large/00831rSTgy1gd52p5t1alj30qq0skdjb.jpg" alt="图5-读写锁的第二种实现" style="zoom:50%;"><hr><p>参考：</p><p>《ZooKeeper 分布式过程协同技术详解》 </p><p>《从Paxos到Zookeeper 分布式一致性原理与实践》</p><p>《Java技术栈》</p><h2 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h2><p>在模板模式(Template Pattern)设计模式中，<br>用一个抽象类公开定义了执行它的方法的方式/模板。</p><p>它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p><p>意图：定义一个操作中的算法的骨架，而将一些步 骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</p><p>何时使用：有一些通用的方法。</p><p>如何解决：将这些通用算法抽象出来。</p><p>关键代码：在抽象父类中实现通用方法，其它步骤下放到子类中实现。</p><p>应用实例：</p><p>1、西游记里面菩萨定好的81难，这就是-个顶层的逻辑骨架。</p><p>2、spring 中对Hibernate的支持，将一-些已经定好的方法封装起来， 比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢- . 个实体就可以保存。</p><p>优点：</p><p>1、封装不变部分，扩展可变部分。</p><p>2、提取公共代码，便于维护。</p><p>3、行为由父类控制，子类实现。</p><p>缺点：</p><p>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p>使用场景：</p><p>1、有多个子类共有的方法，且逻辑相同。</p><p>2、重要的、复杂的方法，可以考虑作为模板方法。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> zk分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式协调框架-zk</title>
      <link href="/2018/06/03/zookeeper/"/>
      <url>/2018/06/03/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="zookeeper特点"><a href="#zookeeper特点" class="headerlink" title="zookeeper特点"></a>zookeeper特点</h2><h3 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h3><p>zookeeper 是一个开源的分布式协调服务，是分布式数据一致性的解决方案。</p><blockquote><p>Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。</p></blockquote><h3 id="zookeeper能做什么"><a href="#zookeeper能做什么" class="headerlink" title="zookeeper能做什么"></a>zookeeper能做什么</h3><p>简单来说，zookeeper 主要做两件事，数据管理和监听服务。</p><p>分布式应用程序可以基于 zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、leader 选举、分布式锁和分布式队列等功能。</p><p>zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。 服务生产者将自己提供的服务注册到 zookeeper 中心，服务的消费者在进行服务调用的时候先到 zookeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo 架构中 zookeeper 就担任了注册中心这一角色。为了保证高可用，最好是以集群形态来部署 zookeeper，只要半数以上节点存活，zookeeper  就能正常服务。<a id="more"></a></p><p>zookeeper 主要提供下面几个功能：</p><ol><li>集群管理：容错、负载均衡。</li><li>配置文件的集中管理。</li><li>集群的入口。</li></ol><h3 id="Session会话"><a href="#Session会话" class="headerlink" title="Session会话"></a>Session会话</h3><p>Session 指的是 zookeeper  服务器与客户端会话。在 zookeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过<strong>心跳检测</strong>与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的<strong>Watch事件通知</strong>。 </p><p>Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p><h3 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h3><p>机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以相互PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。</p><p>下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。<br>基于ZK的临时节点的特性，可以让不同的进程都在ZK的一个指定节点下创建临时子节点，不同的进程直接可以根据这个临时子节点来判断对应的进程是否存活。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大减少了系统耦合。</p><h3 id="Watcher监听事件"><a href="#Watcher监听事件" class="headerlink" title="Watcher监听事件"></a>Watcher监听事件</h3><ol><li>监听的 Znode 被创建、删除、版本后变更(或数据变更)、子节点发生变更 会触发事件。</li><li>Watcher 是一次性的，一旦触发将会永久失效，如果需要反复监听就需要反复注册。</li></ol><h3 id="Znode节点"><a href="#Znode节点" class="headerlink" title="Znode节点"></a>Znode节点</h3><p>在 zookeeper 中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</p><ul><li>持久节点：一旦创建将一直存在于服务端，除非客户端删除。</li><li>持久顺序节点： 在持久节点基础上，通过节点路径后缀一串序号来区分多个子节点创建的先后顺序。</li><li>临时节点：生命周期与客户端会话保持一致。</li><li>临时顺序节点：</li></ul><h3 id="Stat节点状态"><a href="#Stat节点状态" class="headerlink" title="Stat节点状态"></a>Stat节点状态</h3><p>zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本：</p><ul><li>version（当前ZNode的版本）</li><li>cversion（当前ZNode子节点的版本）</li><li>cversion（当前ZNode的ACL版本）</li></ul><h3 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h3><p>zookeeper 有以下五种权限：</p><ul><li>CREATE：创建子节点的权限。</li><li>READ：获取子节点和子节点列表的权限。</li><li>WRITE：更新节点数据的权限。</li><li>DELETE：删除子节点的权限。</li><li>ADMIN：设置节点ACL的权限。<br>其中需要注意的是，CREATE 和 DELETE 这两种权限都是针对<strong>子节点</strong>的权限控制。</li></ul><h2 id="zookeeper支持的协议"><a href="#zookeeper支持的协议" class="headerlink" title="zookeeper支持的协议"></a>zookeeper支持的协议</h2><h3 id="ZAB协议-amp-Paxos算法"><a href="#ZAB协议-amp-Paxos算法" class="headerlink" title="ZAB协议 &amp; Paxos算法"></a>ZAB协议 &amp; Paxos算法</h3><p>Paxos 算法应该可以说是  zookeeper 的灵魂了。但是，zookeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在zookeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 zookeeper 设计的崩溃可恢复的原子消息广播算法。</p><h3 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h3><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，zookeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p><h3 id="ZAB协议的崩溃恢复和原子广播"><a href="#ZAB协议的崩溃恢复和原子广播" class="headerlink" title="ZAB协议的崩溃恢复和原子广播"></a>ZAB协议的崩溃恢复和原子广播</h3><p>在整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p><p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><h2 id="zookeeper集群"><a href="#zookeeper集群" class="headerlink" title="zookeeper集群"></a>zookeeper集群</h2><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><ul><li>leader：负责进行投票的发起和决议，更新系统状态。</li><li>follower：参与leader选举投票或事务请求投票，处理读请求 和 转发写请求给 leader。</li><li>observer：弱化版的follower，不参与投票，只同步 leader 的状态，提高读取速度。</li></ul><h3 id="单机模式的安装"><a href="#单机模式的安装" class="headerlink" title="单机模式的安装"></a>单机模式的安装</h3><ul><li>Step1：配置JAVA环境，检验环境：java -version</li><li>Step2：下载并解压zookeeper<pre class="line-numbers language-xml"><code class="language-xml">cd /usr/localwget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gztar -zxvf zookeeper-3.4.12.tar.gzcd zookeeper-3.4.12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>Step3：重命名配置文件zoo_sample.cfg<pre class="line-numbers language-xml"><code class="language-xml">cp conf/zoo_sample.cfg conf/zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Step4：启动zookeeper<pre class="line-numbers language-xml"><code class="language-xml">bin/zkServer.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>Step5：检测是否成功启动，用zookeeper客户端连接下服务端<pre class="line-numbers language-xml"><code class="language-xml">bin/zkCli.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="集群模式的搭建"><a href="#集群模式的搭建" class="headerlink" title="集群模式的搭建"></a>集群模式的搭建</h3><p>本例搭建的是伪集群模式，即一台机器上启动三个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别<br>Step1：配置JAVA环境，检验环境：java -version<br>Step2：下载并解压zookeeper</p><pre class="line-numbers language-xml"><code class="language-xml"># cd /usr/local# wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz# tar -zxvf zookeeper-3.4.12.tar.gz# cd zookeeper-3.4.12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Step3：重命名 zoo_sample.cfg文件</p><pre class="line-numbers language-xml"><code class="language-xml"># cp conf/zoo_sample.cfg conf/zoo-1.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Step4：修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上</p><pre class="line-numbers language-xml"><code class="language-xml"># vim conf/zoo-1.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dataDir=/tmp/zookeeper-1<br>clientPort=2181<br>server.1=127.0.0.1:2888:3888<br>server.2=127.0.0.1:2889:3889<br>server.3=127.0.0.1:2890:3890</p><p>Step5：再从zoo-1.cfg复制两个配置文件zoo-2.cfg和zoo-3.cfg，只需修改dataDir和clientPort不同即可</p><pre><code># cp conf/zoo-1.cfg conf/zoo-2.cfg# cp conf/zoo-1.cfg conf/zoo-3.cfg# vim conf/zoo-2.cfg</code></pre><p>dataDir=/tmp/zookeeper-2<br>clientPort=2182</p><pre><code># vim conf/zoo-2.cfg</code></pre><p>dataDir=/tmp/zookeeper-3<br>clientPort=2183</p><p>Step6：标识Server ID<br>创建三个文件夹/tmp/zookeeper-1，/tmp/zookeeper-2，/tmp/zookeeper-2，在每个目录中创建文件myid 文件，写入当前实例的server id，即1.2.3</p><pre class="line-numbers language-xml"><code class="language-xml"># cd /tmp/zookeeper-1# vim myid1# cd /tmp/zookeeper-2# vim myid2# cd /tmp/zookeeper-3# vim myid3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Step7：启动三个zookeeper实例</p><pre class="line-numbers language-xml"><code class="language-xml"># bin/zkServer.sh start conf/zoo-1.cfg# bin/zkServer.sh start conf/zoo-2.cfg# bin/zkServer.sh start conf/zoo-3.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="集群中leader的选举"><a href="#集群中leader的选举" class="headerlink" title="集群中leader的选举"></a>集群中leader的选举</h3><p>选举场景：1、集群刚启动时   2、leader退出</p><ol><li>第一次每个 follower 都会选自己为 leader 服务器，也就是投出的是自己的服务器 ID 和 ZXID。</li><li>每个 follower 都会受到来自其他 follower 的信息，并先按 ZXID 再按服务器 ID 最大选择选出新的选票，再次发出去。</li><li>若某台服务器得到超半数的选票将当选为新的 leader。</li></ol><h3 id="集群数据同步流程"><a href="#集群数据同步流程" class="headerlink" title="集群数据同步流程"></a>集群数据同步流程</h3><p>完成 leader 选举后，leader 等待 follower 来连接进行同步</p><ol><li>leader 等待 follower 连接。</li><li>follower 将最大的 zxid 发送给 leader。</li><li>leader 根据 zxid 确定同步点。</li><li>完成同步后，leader 给 follower 发送 uptodate 消息。</li><li>follower 收到 uptodate 后，又可以重新接受 client 连接请求了。</li></ol><h3 id="集群中事务请求处理流程"><a href="#集群中事务请求处理流程" class="headerlink" title="集群中事务请求处理流程"></a>集群中事务请求处理流程</h3><ol><li>所有事务请求都交由 leader 服务器来处理，leader 服务器会将一个事务请求转为一个proposal，并为其生成一个ZXID(事务ID)。</li><li>之后 leader 服务器会将 proposal 放入每个 follower 的队列中（leader会为每个follower分配一个队列），并发送给 follower。</li><li>follower收到 proposal 后，会将事务日志写入磁盘，并在成功后返回 leader 一个ACK。</li><li>leader 只要收到过半的 follower 的ACK响应，就会广播一个 commit 消息给 follower 通知进行 proposal 的提交，同时自身也会完成。</li></ol><h2 id="zookeeper的应用场景"><a href="#zookeeper的应用场景" class="headerlink" title="zookeeper的应用场景"></a>zookeeper的应用场景</h2><h3 id="实现命名服务-Name-Service"><a href="#实现命名服务-Name-Service" class="headerlink" title="实现命名服务(Name Service)"></a>实现命名服务(Name Service)</h3><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字（Name）。</p><p>其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在 zookeeper里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。</p><p>zookeeper 的命名服务即生成全局唯一的ID。</p><h3 id="实现分布式协调-通知"><a href="#实现分布式协调-通知" class="headerlink" title="实现分布式协调/通知"></a>实现分布式协调/通知</h3><p>分布式协调其实是很经典的一个用法，比如说A系统发送请求到mq，B系统消费之后处理了，那么A如何知道B的处理进度？用zk就可以实现分布式系统之间的协调工作。</p><p>A系统发送请求之后可以在zk上对某个节点的值注册一个监听器，一旦B系统处理完了就修改zk那个节点的值，根据监听通知机制A系统马上就可以收到通知，完美解决。</p><h3 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h3><p>有两种实现：</p><ol><li>集群中所有机器都去竞争创建某个节点，创建成功的机器相当于获取了这个锁。</li><li>所有机器都去某个父节点下创建子节点，序号最小的机器获取锁。</li></ol><p>详情可参考我的另一篇博客：<a href="https://lishaojie1993.gitee.io/2018/06/04/zk-lock">基于zk实现分布式锁</a></p><h3 id="实现分布式队列"><a href="#实现分布式队列" class="headerlink" title="实现分布式队列"></a>实现分布式队列</h3><ol><li>同步队列：在指定目录下创建 watcher，当监控到子节点数目达到指定值后再开始使用，进行读取消费。</li><li>FIFO队列：读取序列号最小的节点进行消费，例如实现生产者和消费者模型。<br>在此场景下，znode 节点值存储的可能就是消息本身。</li></ol><h3 id="实现HA高可用性"><a href="#实现HA高可用性" class="headerlink" title="实现HA高可用性"></a>实现HA高可用性</h3><p>高可用(High Availability)也是比较常见的，很多大数据系统都选择基于zk来开发高可用机制，就是一个重要进程一般都做主备两个，通过临时节点机制(创建节点的进程挂了节点会消失)，主进程挂掉后立马通过zk感知到切换到备用进程。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven相关</title>
      <link href="/2018/05/12/maven/"/>
      <url>/2018/05/12/maven/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h2><p>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</p><p>Maven是跨平台的项目管理工具。主要服务于基于Java平台的<strong>项目构建</strong>，<strong>依赖管理</strong>和项目信息管理。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>官方网站：<a href="http://maven.apache.org" target="_blank" rel="noopener">http://maven.apache.org</a>  </p><p>要求 jdk 为1.6及以上版本。</p><p>解压缩，解压目录最好不要有中文。</p><p>配置环境变量MAVEN_HOME和path。</p><p>验证是否安装成功，打开cmd窗口，输入mvn –v。<a id="more"></a></p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p><strong>%MAVEN_HOME%/conf/settings.xml</strong> 是maven全局的配置文件。</p><p>该配置文件中配置了本地仓库的路径，默认就是：~/.m2/repository。</p><p>用户配置：复制maven的全局配置文件settings.xml到~/.m2目录下，即创建用户配置文件。</p><p>注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Mvn-compile"><a href="#Mvn-compile" class="headerlink" title="Mvn compile"></a>Mvn compile</h3><p>执行 mvn compile命令，完成编译操作。</p><p>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</p><h3 id="Mvn-clean"><a href="#Mvn-clean" class="headerlink" title="Mvn clean"></a>Mvn clean</h3><p>执行 mvn clean命令。</p><p>执行完毕后，会将target目录删除。</p><h3 id="Mvn-test"><a href="#Mvn-test" class="headerlink" title="Mvn test"></a>Mvn test</h3><p>执行 mvn test命令，完成单元测试操作。</p><p>执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）。</p><h3 id="Mvn-package"><a href="#Mvn-package" class="headerlink" title="Mvn package"></a>Mvn package</h3><p>执行 mvn package命令，完成打包操作。</p><p>执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。</p><h3 id="Mvn-install"><a href="#Mvn-install" class="headerlink" title="Mvn install"></a>Mvn install</h3><p>执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作。</p><p>执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。</p><h2 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h2><h3 id="mvn-clean-compile"><a href="#mvn-clean-compile" class="headerlink" title="mvn clean compile"></a>mvn clean compile</h3><p>cmd 中录入 mvn clean compile命令。</p><p>组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类。</p><h3 id="mvn-clean-test"><a href="#mvn-clean-test" class="headerlink" title="mvn clean test"></a>mvn clean test</h3><p>cmd 中录入 mvn clean test命令。</p><p>组合指令，先执行clean，再执行test，通常应用于测试环节。</p><h3 id="mvn-clean-package"><a href="#mvn-clean-package" class="headerlink" title="mvn clean package"></a>mvn clean package</h3><p>cmd 中录入 mvn clean package命令。</p><p>组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前。</p><p>执行过程：</p><ul><li>清理————清空环境</li><li>编译————编译源码</li><li>测试————测试源码</li><li>打包————将编译的非测试类打包</li></ul><h3 id="mvn-clean-install"><a href="#mvn-clean-install" class="headerlink" title="mvn clean install"></a>mvn clean install</h3><p>cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中。</p><p>组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前。</p><p>执行过程：</p><ul><li>清理————清空环境</li><li>编译————编译源码</li><li>测试————测试源码</li><li>打包————将编译的非测试类打包</li><li>部署————将打好的包发布到资源仓库中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> version control </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2018/03/22/mybatis/"/>
      <url>/2018/03/22/mybatis/</url>
      
        <content type="html"><![CDATA[<p>参考链接：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">mybatis入门</a></p><h2 id="mybatis常见问题"><a href="#mybatis常见问题" class="headerlink" title="mybatis常见问题"></a>mybatis常见问题</h2><h3 id="1、什么是MyBatis？"><a href="#1、什么是MyBatis？" class="headerlink" title="1、什么是MyBatis？"></a>1、什么是MyBatis？</h3><p>MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。</p><h3 id="2、讲下MyBatis的缓存"><a href="#2、讲下MyBatis的缓存" class="headerlink" title="2、讲下MyBatis的缓存"></a>2、讲下MyBatis的缓存</h3><p>MyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache><a id="more"></a></cache></p><h3 id="3、Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#3、Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="3、Mybatis是如何进行分页的？分页插件的原理是什么？"></a>3、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><ol><li>Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。</li><li>分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。</li></ol><p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p><h3 id="4、简述Mybatis的插件运行原理，以及如何编写一个插件？"><a href="#4、简述Mybatis的插件运行原理，以及如何编写一个插件？" class="headerlink" title="4、简述Mybatis的插件运行原理，以及如何编写一个插件？"></a>4、简述Mybatis的插件运行原理，以及如何编写一个插件？</h3><ol><li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li><li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li></ol><h3 id="5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><ol><li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。</li><li>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li></ol><h3 id="6、-和-的区别是什么？"><a href="#6、-和-的区别是什么？" class="headerlink" title="6、#{}和${}的区别是什么？"></a>6、#{}和${}的区别是什么？</h3><ol><li>#{}是预编译处理，${}是字符串替换。</li><li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li><li>Mybatis在处理${}时，就是把${}替换成变量的值。</li><li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li></ol><h3 id="7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><ol><li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li><li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li></ol><h3 id="9、MyBatis与Hibernate有哪些不同？"><a href="#9、MyBatis与Hibernate有哪些不同？" class="headerlink" title="9、MyBatis与Hibernate有哪些不同？"></a>9、MyBatis与Hibernate有哪些不同？</h3><ol><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li><li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li></ol><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p><h3 id="10、MyBatis的好处是什么？"><a href="#10、MyBatis的好处是什么？" class="headerlink" title="10、MyBatis的好处是什么？"></a>10、MyBatis的好处是什么？</h3><ol><li>MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。</li><li>MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。</li><li>因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。</li></ol><h3 id="11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parametermap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultmap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultmap></parametermap></p><h3 id="12、什么是MyBatis的接口绑定-有什么好处？"><a href="#12、什么是MyBatis的接口绑定-有什么好处？" class="headerlink" title="12、什么是MyBatis的接口绑定,有什么好处？"></a>12、什么是MyBatis的接口绑定,有什么好处？</h3><p>接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><h3 id="13、接口绑定有几种实现方式-分别是怎么实现的"><a href="#13、接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="13、接口绑定有几种实现方式,分别是怎么实现的?"></a>13、接口绑定有几种实现方式,分别是怎么实现的?</h3><p>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p><h3 id="14、什么情况下用注解绑定-什么情况下用xml绑定？"><a href="#14、什么情况下用注解绑定-什么情况下用xml绑定？" class="headerlink" title="14、什么情况下用注解绑定,什么情况下用xml绑定？"></a>14、什么情况下用注解绑定,什么情况下用xml绑定？</h3><p>当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多</p><h3 id="15、MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#15、MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="15、MyBatis实现一对一有几种方式?具体怎么操作的？"></a>15、MyBatis实现一对一有几种方式?具体怎么操作的？</h3><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。</p><h3 id="16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h3><p>能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p><p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p><h3 id="17、MyBatis里面的动态Sql是怎么设定的-用什么语法"><a href="#17、MyBatis里面的动态Sql是怎么设定的-用什么语法" class="headerlink" title="17、MyBatis里面的动态Sql是怎么设定的?用什么语法?"></a>17、MyBatis里面的动态Sql是怎么设定的?用什么语法?</h3><p>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。</p><h3 id="18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。</resultmap></p><p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h3 id="19、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#19、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><p>还有很多其他的标签，<resultmap>、<parametermap>、<sql>、<include>、<selectkey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectkey>为不支持自增的主键生成策略标签。</selectkey></include></sql></selectkey></include></sql></parametermap></resultmap></p><h3 id="20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？"><a href="#20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？" class="headerlink" title="20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？"></a>20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？</h3><ol><li>通过在查询的sql语句中定义字段名的别名。</li><li>通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></li></ol><h3 id="21、模糊查询like语句该怎么写"><a href="#21、模糊查询like语句该怎么写" class="headerlink" title="21、模糊查询like语句该怎么写"></a>21、模糊查询like语句该怎么写</h3><ol><li>在java中拼接通配符，通过#{}赋值</li><li>在Sql语句中拼接通配符 （不安全 会引起Sql注入）</li></ol><h3 id="22、通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？"><a href="#22、通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？" class="headerlink" title="22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？"></a>22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？</h3><p>不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。</p><h3 id="23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><h3 id="24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h3 id="25、Mybatis中如何执行批处理？"><a href="#25、Mybatis中如何执行批处理？" class="headerlink" title="25、Mybatis中如何执行批处理？"></a>25、Mybatis中如何执行批处理？</h3><p>使用BatchExecutor完成批处理。</p><h3 id="26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map3）BatchExecutor：完成批处理。</p><h3 id="27、Mybatis中如何指定使用哪一种Executor执行器？"><a href="#27、Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="27、Mybatis中如何指定使用哪一种Executor执行器？"></a>27、Mybatis中如何指定使用哪一种Executor执行器？</h3><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p><h3 id="28、Mybatis执行批量插入，能返回数据库主键列表吗？"><a href="#28、Mybatis执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="28、Mybatis执行批量插入，能返回数据库主键列表吗？"></a>28、Mybatis执行批量插入，能返回数据库主键列表吗？</h3><p>能，JDBC都能，Mybatis当然也能。</p><h3 id="29、Mybatis是否可以映射Enum枚举类？"><a href="#29、Mybatis是否可以映射Enum枚举类？" class="headerlink" title="29、Mybatis是否可以映射Enum枚举类？"></a>29、Mybatis是否可以映射Enum枚举类？</h3><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h3 id="30、如何获取自动生成的-主-键值？"><a href="#30、如何获取自动生成的-主-键值？" class="headerlink" title="30、如何获取自动生成的(主)键值？"></a>30、如何获取自动生成的(主)键值？</h3><p>配置文件设置usegeneratedkeys 为 true。</p><h3 id="31、在mapper中如何传递多个参数？"><a href="#31、在mapper中如何传递多个参数？" class="headerlink" title="31、在mapper中如何传递多个参数？"></a>31、在mapper中如何传递多个参数？</h3><ol><li>直接在方法中传递参数，xml文件用#{0} #{1}来获取</li><li>使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取</li></ol><h3 id="32、resultType-resultMap的区别？"><a href="#32、resultType-resultMap的区别？" class="headerlink" title="32、resultType resultMap的区别？"></a>32、resultType resultMap的区别？</h3><ol><li>类的名字和数据库相同时，可以直接设置resultType参数为Pojo类</li><li>若不同，需要设置resultMap 将结果名字和Pojo名字进行转换</li></ol><h3 id="33、使用MyBatis的mapper接口调用时有哪些要求？"><a href="#33、使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="33、使用MyBatis的mapper接口调用时有哪些要求？"></a>33、使用MyBatis的mapper接口调用时有哪些要求？</h3><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol><h3 id="34、Mybatis比IBatis比较大的几个改进是什么？"><a href="#34、Mybatis比IBatis比较大的几个改进是什么？" class="headerlink" title="34、Mybatis比IBatis比较大的几个改进是什么？"></a>34、Mybatis比IBatis比较大的几个改进是什么？</h3><ol><li>有接口绑定,包括注解绑定sql和xml绑定Sql。</li><li>动态sql由原来的节点配置变成OGNL表达式3） 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。</li></ol><h3 id="35、IBatis和MyBatis在核心处理类分别叫什么？"><a href="#35、IBatis和MyBatis在核心处理类分别叫什么？" class="headerlink" title="35、IBatis和MyBatis在核心处理类分别叫什么？"></a>35、IBatis和MyBatis在核心处理类分别叫什么？</h3><p>IBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。</p><h3 id="36、IBatis和MyBatis在细节上的不同有哪些？"><a href="#36、IBatis和MyBatis在细节上的不同有哪些？" class="headerlink" title="36、IBatis和MyBatis在细节上的不同有哪些？"></a>36、IBatis和MyBatis在细节上的不同有哪些？</h3><ol><li>在sql里面变量命名有原来的#变量# 变成了#{变量}。</li><li>原来的 $变量$ 变成了 ${变量}。</li><li>原来在sql节点里面的class都换名字交type。</li><li>原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web框架 </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发框架以及高频知识点汇总</title>
      <link href="/2017/09/08/article/"/>
      <url>/2017/09/08/article/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h4 id="JDK-和-JRE-有什么区别？"><a href="#JDK-和-JRE-有什么区别？" class="headerlink" title="JDK 和 JRE 有什么区别？"></a>JDK 和 JRE 有什么区别？</h4><p>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</p><p>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</p><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。<a id="more"></a></p><h4 id="和-equals-的区别是什么？"><a href="#和-equals-的区别是什么？" class="headerlink" title="== 和 equals 的区别是什么？"></a>== 和 equals 的区别是什么？</h4><p>== 解读</p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><p>基本类型：比较的是值是否相同；</p><p>引用类型：比较的是引用是否相同；</p><p>代码示例：</p><pre class="line-numbers language-java"><code class="language-java">String x <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>String y <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>String z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">==</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals 解读</p><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p><p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Cat</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">private</span> String name<span class="token punctuation">;</span>        <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span>Cat c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Cat c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token string">"xx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原来 equals 本质上就是 ==。</p><p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p><pre class="line-numbers language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p><p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h4 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？"></a>两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p><p>代码示例：</p><pre class="line-numbers language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"通话"</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token string">"重地"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"str1：%d | str2：%d"</span><span class="token punctuation">,</span>  str1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>str2<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行的结果：</p><p>str1：1179395 | str2：1179395</p><p>false</p><p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h4 id="final-在-java-中有什么作用？"><a href="#final-在-java-中有什么作用？" class="headerlink" title="final 在 java 中有什么作用？"></a>final 在 java 中有什么作用？</h4><p>final 修饰的类不能被继承。</p><p>final 修饰的方法不能被重写。</p><p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><h4 id="java-中的-Math-round-1-5-等于多少？"><a href="#java-中的-Math-round-1-5-等于多少？" class="headerlink" title="java 中的 Math.round(-1.5) 等于多少？"></a>java 中的 Math.round(-1.5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃</p><h4 id="String-属于基础的数据类型吗？"><a href="#String-属于基础的数据类型吗？" class="headerlink" title="String 属于基础的数据类型吗？"></a>String 属于基础的数据类型吗？</h4><p>String 不属于基础类型，属于对象，也就是引用类型。</p><p>基础类型有 8 种：byte、boolean、char、short、int、float、long、double。</p><h4 id="java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="java 中操作字符串都有哪些类？它们之间有什么区别？"></a>java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h4 id="String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="String str=”i”与 String str=new String(“i”)一样吗？"></a>String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h4 id="如何将字符串反转？"><a href="#如何将字符串反转？" class="headerlink" title="如何将字符串反转？"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// StringBuffer reverse</span>StringBuffer stringBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stringBuffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stringBuffer<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// gfedcba</span><span class="token comment" spellcheck="true">// StringBuilder reverse</span>StringBuilder stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stringBuilder<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// gfedcba</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="String-类的常用方法都有那些？"><a href="#String-类的常用方法都有那些？" class="headerlink" title="String 类的常用方法都有那些？"></a>String 类的常用方法都有那些？</h4><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p><h4 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p><p>示例代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hi~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p><h4 id="普通类和抽象类有哪些区别？"><a href="#普通类和抽象类有哪些区别？" class="headerlink" title="普通类和抽象类有哪些区别？"></a>普通类和抽象类有哪些区别？</h4><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p><h4 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器会提示错误信息。</p><h4 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h4><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。<br>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h4 id="java-中-IO-流分为几种？"><a href="#java-中-IO-流分为几种？" class="headerlink" title="java 中 IO 流分为几种？"></a>java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h4 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h4><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p><p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p><p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p><h4 id="Files的常用方法都有哪些？"><a href="#Files的常用方法都有哪些？" class="headerlink" title="Files的常用方法都有哪些？"></a>Files的常用方法都有哪些？</h4><p>Files.exists()：检测文件路径是否存在。<br>Files.createFile()：创建文件。<br>Files.createDirectory()：创建文件夹。<br>Files.delete()：删除一个文件或目录。<br>Files.copy()：复制文件。<br>Files.move()：移动文件。<br>Files.size()：查看文件个数。<br>Files.read()：读取文件。<br>Files.write()：写入文件。</p><h2 id="java集合-容器"><a href="#java集合-容器" class="headerlink" title="java集合/容器"></a>java集合/容器</h2><h4 id="java-容器都有哪些？"><a href="#java-容器都有哪些？" class="headerlink" title="java 容器都有哪些？"></a>java 容器都有哪些？</h4><h4 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h4><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p><p>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p><h4 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h4><h4 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h4><p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。<br>hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>hashMap允许空键值，而hashTable不允许。</p><h4 id="如何决定使用-HashMap-还是-TreeMap？"><a href="#如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="如何决定使用 HashMap 还是 TreeMap？"></a>如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h4 id="说一下-HashMap-的实现原理？"><a href="#说一下-HashMap-的实现原理？" class="headerlink" title="说一下 HashMap 的实现原理？"></a>说一下 HashMap 的实现原理？</h4><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </p><p> HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p><p> 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p><h4 id="说一下-HashSet-的实现原理？"><a href="#说一下-HashSet-的实现原理？" class="headerlink" title="说一下 HashSet 的实现原理？"></a>说一下 HashSet 的实现原理？</h4><p>HashSet底层由HashMap实现<br>HashSet的值存放于HashMap的key上<br>HashMap的value统一为PRESENT</p><h4 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h4><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p><h4 id="如何实现数组和-List-之间的转换？"><a href="#如何实现数组和-List-之间的转换？" class="headerlink" title="如何实现数组和 List 之间的转换？"></a>如何实现数组和 List 之间的转换？</h4><p>List转换成为数组：调用ArrayList的toArray方法。<br>数组转换成为List：调用Arrays的asList方法。</p><h4 id="ArrayList-和-Vector-的区别是什么？"><a href="#ArrayList-和-Vector-的区别是什么？" class="headerlink" title="ArrayList 和 Vector 的区别是什么？"></a>ArrayList 和 Vector 的区别是什么？</h4><p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 </p><p>ArrayList比Vector快，它因为有同步，不会过载。 </p><p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p><h4 id="Array-和-ArrayList-有何区别？"><a href="#Array-和-ArrayList-有何区别？" class="headerlink" title="Array 和 ArrayList 有何区别？"></a>Array 和 ArrayList 有何区别？</h4><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><h4 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h4><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。<br>statck：堆栈类，先进后出。<br>hashtable：就比hashmap多了个线程安全。<br>enumeration：枚举，相当于迭代器。</p><h4 id="迭代器-Iterator-是什么？"><a href="#迭代器-Iterator-是什么？" class="headerlink" title="迭代器 Iterator 是什么？"></a>迭代器 Iterator 是什么？</h4><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><p>Java中的Iterator功能比较简单，并且只能单向移动：</p><p>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p><p>　　(2) 使用next()获得序列中的下一个元素。</p><p>　　(3) 使用hasNext()检查序列中是否还有元素。</p><p>　　(4) 使用remove()将迭代器新返回的元素删除。</p><p>　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><h4 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h4><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。<br>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p><h4 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h4><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程</p><h4 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h4><p>①. 继承Thread类创建线程类</p><p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。<br>②. 通过Runnable接口创建线程类</p><p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。<br>③. 通过Callable和Future创建线程</p><p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p><h4 id="说一下-runnable-和-callable-有什么区别？"><a href="#说一下-runnable-和-callable-有什么区别？" class="headerlink" title="说一下 runnable 和 callable 有什么区别？"></a>说一下 runnable 和 callable 有什么区别？</h4><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><h4 id="线程有哪些状态？"><a href="#线程有哪些状态？" class="headerlink" title="线程有哪些状态？"></a>线程有哪些状态？</h4><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p><p>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 。</p><h4 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h4><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p><p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p><h4 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h4><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p><h4 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h4><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p><p> start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p> run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法</p><h4 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h4><p>①. newFixedThreadPool(int nThreads)</p><p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p><p>②. newCachedThreadPool()</p><p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p><p>③. newSingleThreadExecutor()</p><p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行</p><p>④. newScheduledThreadPool(int corePoolSize)</p><p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p><h4 id="线程池都有哪些状态？"><a href="#线程池都有哪些状态？" class="headerlink" title="线程池都有哪些状态？"></a>线程池都有哪些状态？</h4><p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p><p>线程池各个状态切换框架图：</p><h4 id="线程池中-submit-和-execute-方法有什么区别？"><a href="#线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="线程池中 submit()和 execute()方法有什么区别？"></a>线程池中 submit()和 execute()方法有什么区别？</h4><p>接收的参数不一样<br>submit有返回值，而execute没有<br>submit方便Exception处理</p><h4 id="在-java-程序中怎么保证多线程的运行安全？"><a href="#在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="在 java 程序中怎么保证多线程的运行安全？"></a>在 java 程序中怎么保证多线程的运行安全？</h4><p>线程安全在三个方面体现：</p><p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；<br>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；<br>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p><h4 id="多线程锁的升级原理是什么？"><a href="#多线程锁的升级原理是什么？" class="headerlink" title="多线程锁的升级原理是什么？"></a>多线程锁的升级原理是什么？</h4><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p><p>锁升级的图示过程： </p><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><h4 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h4><p>死锁的四个必要条件：</p><p>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源<br>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放<br>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放<br>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p><p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p><p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h4 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h4><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><h4 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><p>普通同步方法，锁是当前实例对象<br>静态同步方法，锁是当前类的class对象<br>同步方法块，锁是括号里面的对象</p><h4 id="说一下volatile底层实现原理"><a href="#说一下volatile底层实现原理" class="headerlink" title="说一下volatile底层实现原理"></a>说一下volatile底层实现原理</h4><h4 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h4><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p><h4 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h4><p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；<br>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；<br>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；<br>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；<br>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；<br>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p><h4 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>ReentrantLock可以获取各种锁的信息<br>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word</p><h4 id="说一下-atomic-的原理？"><a href="#说一下-atomic-的原理？" class="headerlink" title="说一下 atomic 的原理？"></a>说一下 atomic 的原理？</h4><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p><p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。</p><p>Java反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。</p><p>Java反射机制主要提供了以下功能：</p><p>在运行时判断任意一个对象所属的类。<br>在运行时构造任意一个类的对象。<br>在运行时判断任意一个类所具有的成员变量和方法。<br>在运行时调用任意一个对象的方法。<br>得到类的字节码文件相同，这三种方式。<br>1.Class cls1=类名.class 相对简单，还是需要明确类名<br>2.cls1.getclass();必须要明确具体的类，并创建对象<br>3.class.forName(“完整的类名（带包名）”);</p><h4 id="什么是-java-序列化？什么情况下需要序列化？"><a href="#什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="什么是 java 序列化？什么情况下需要序列化？"></a>什么是 java 序列化？什么情况下需要序列化？</h4><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p><p>什么情况下需要序列化：</p><p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>b）当你想用套接字在网络上传送对象的时候；<br>c）当你想通过RMI传输对象的时候；</p><h4 id="动态代理是什么？有哪些应用？"><a href="#动态代理是什么？有哪些应用？" class="headerlink" title="动态代理是什么？有哪些应用？"></a>动态代理是什么？有哪些应用？</h4><p>动态代理：</p><p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p><p>动态代理的应用：</p><p>Spring的AOP<br>加事务<br>加权限<br>加日志</p><h4 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h4><p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><h4 id="为什么要使用克隆？"><a href="#为什么要使用克隆？" class="headerlink" title="为什么要使用克隆？"></a>为什么要使用克隆？</h4><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p><h4 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h4><p>有两种方式：</p><p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p><p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时</p><h4 id="深拷贝和浅拷贝区别是什么？"><a href="#深拷贝和浅拷贝区别是什么？" class="headerlink" title="深拷贝和浅拷贝区别是什么？"></a>深拷贝和浅拷贝区别是什么？</h4><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h4 id="jsp-和-servlet-有什么区别？"><a href="#jsp-和-servlet-有什么区别？" class="headerlink" title="jsp 和 servlet 有什么区别？"></a>jsp 和 servlet 有什么区别？</h4><p>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）<br>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。<br>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。<br>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应</p><h4 id="jsp-有哪些内置对象？作用分别是什么？"><a href="#jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="jsp 有哪些内置对象？作用分别是什么？"></a>jsp 有哪些内置对象？作用分别是什么？</h4><p>JSP有9个内置对象：</p><p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web应用的配置对象；<br>page：JSP页面本身（相当于Java程序中的this）；<br>exception：封装页面抛出异常的对象。</p><h4 id="说一下-jsp-的-4-种作用域？"><a href="#说一下-jsp-的-4-种作用域？" class="headerlink" title="说一下 jsp 的 4 种作用域？"></a>说一下 jsp 的 4 种作用域？</h4><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p><p>page代表与一个页面相关的对象和属性。<br>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。<br>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。<br>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</p><h4 id="session-和-cookie-有什么区别？"><a href="#session-和-cookie-有什么区别？" class="headerlink" title="session 和 cookie 有什么区别？"></a>session 和 cookie 有什么区别？</h4><h4 id="说一下-session-的工作原理？"><a href="#说一下-session-的工作原理？" class="headerlink" title="说一下 session 的工作原理？"></a>说一下 session 的工作原理？</h4><p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了</p><h4 id="如何避免SQL注入"><a href="#如何避免SQL注入" class="headerlink" title="如何避免SQL注入"></a>如何避免SQL注入</h4><ol><li>PreparedStatement（简单又有效的方法）</li><li>使用正则表达式过滤传入的参数</li><li>字符串过滤</li><li>JSP中调用该函数检查是否包函非法字符</li><li>JSP页面判断代码</li></ol><h4 id="什么是-XSS-攻击，如何避免？"><a href="#什么是-XSS-攻击，如何避免？" class="headerlink" title="什么是 XSS 攻击，如何避免？"></a>什么是 XSS 攻击，如何避免？</h4><p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="throw-和-throws-的区别？"><a href="#throw-和-throws-的区别？" class="headerlink" title="throw 和 throws 的区别？"></a>throw 和 throws 的区别？</h4><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型</p><h4 id="final、finally、finalize-有什么区别？"><a href="#final、finally、finalize-有什么区别？" class="headerlink" title="final、finally、finalize 有什么区别？"></a>final、finally、finalize 有什么区别？</h4><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 </p><h4 id="try-catch-finally-中哪个部分可以省略？"><a href="#try-catch-finally-中哪个部分可以省略？" class="headerlink" title="try-catch-finally 中哪个部分可以省略？"></a>try-catch-finally 中哪个部分可以省略？</h4><p>答：catch 可以省略</p><p>原因：</p><pre><code>   更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。   理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。  至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</code></pre><h4 id="try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>答：会执行，在 return 前执行。</p><h4 id="常见的异常类有哪些？"><a href="#常见的异常类有哪些？" class="headerlink" title="常见的异常类有哪些？"></a>常见的异常类有哪些？</h4><p>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。<br>SQLException：提供关于数据库访问错误或其他错误信息的异常。<br>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。<br>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。<br>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。<br>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。<br>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。<br>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。<br>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。<br>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。<br>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="http 响应码 301 和 302 代表的是什么？有什么区别？"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h4><p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p><p>区别： </p><p>301 redirect: 301 代表永久性转移(Permanently Moved)。<br>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p><h4 id="forward-和-redirect-的区别？"><a href="#forward-和-redirect-的区别？" class="headerlink" title="forward 和 redirect 的区别？"></a>forward 和 redirect 的区别？</h4><p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p><p>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p><p>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p><p>举个通俗的例子：</p><p>　　直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p><p>　　间接转发就相当于：”A找B借钱，B说没有，让A去找C借”</p><h4 id="简述-tcp-和-udp的区别？"><a href="#简述-tcp-和-udp的区别？" class="headerlink" title="简述 tcp 和 udp的区别？"></a>简述 tcp 和 udp的区别？</h4><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。<br>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。<br>TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h4 id="tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="tcp 为什么要三次握手，两次不行吗？为什么？"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h4><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p><h4 id="说一下-tcp-粘包是怎么产生的？"><a href="#说一下-tcp-粘包是怎么产生的？" class="headerlink" title="说一下 tcp 粘包是怎么产生的？"></a>说一下 tcp 粘包是怎么产生的？</h4><p>①. 发送方产生粘包</p><p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p><p>②. 接收方产生粘包</p><p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） </p><h4 id="OSI-的七层模型都有哪些？"><a href="#OSI-的七层模型都有哪些？" class="headerlink" title="OSI 的七层模型都有哪些？"></a>OSI 的七层模型都有哪些？</h4><p>应用层：网络服务与最终用户的一个接口。<br>表示层：数据的表示、安全、压缩。<br>会话层：建立、管理、终止会话。<br>传输层：定义传输数据的协议端口号，以及流控和差错校验。<br>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。<br>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。<br>物理层：建立、维护、断开物理连接。</p><h4 id="get-和-post-请求有哪些区别？"><a href="#get-和-post-请求有哪些区别？" class="headerlink" title="get 和 post 请求有哪些区别？"></a>get 和 post 请求有哪些区别？</h4><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中</p><h4 id="说一下-JSONP-实现原理？"><a href="#说一下-JSONP-实现原理？" class="headerlink" title="说一下 JSONP 实现原理？"></a>说一下 JSONP 实现原理？</h4><p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>定义：有且仅有一个实例</p><p>用途：</p><p>双重检查、静态内部类、枚举（推荐使用）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//双重检查写法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> Singleton singleton<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两种写法的优点：线程安全；延迟加载；效率较高。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//静态内部类写法</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonInstance<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：内存浪费、线程安全、使用效率</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>定义：从原型实例复制克隆出新实例，而绝不是从类去实例化</p><p>用途：</p><p>写法：原型类要实现Cloneable接口</p><h2 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring / Spring MVC"></a>Spring / Spring MVC</h2><ol start="90"><li>为什么要使用 spring？</li></ol><p>1.简介</p><p>目的：解决企业应用开发的复杂性<br>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br>范围：任何Java应用<br>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p><p>2.轻量　　</p><p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</p><p>3.控制反转　　</p><p>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它</p><p>4.面向切面　　</p><p>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</p><p>5.容器</p><p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p><p>6.框架</p><p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p><p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p><h4 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h4><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p> 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p><h4 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h4><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p><p>　1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p><p>　IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p><p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><p>　　我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统</p><pre><code>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</code></pre><h4 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h4><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><h4 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h4><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p><p>构造方法注入<br>setter注入<br>基于注解的注入</p><h4 id="spring-中的-bean-是线程安全的吗？"><a href="#spring-中的-bean-是线程安全的吗？" class="headerlink" title="spring 中的 bean 是线程安全的吗？"></a>spring 中的 bean 是线程安全的吗？</h4><p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p><h4 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h4><p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p><p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例<br>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例<br>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效<br>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效<br>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效<br>    其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p><p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p><h4 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h4><p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p><p>spring中bean装配有两种方式：</p><p>隐式的bean发现机制和自动装配<br>在java代码或者XML中进行显示配置<br>当然这些方式也可以配合使用。</p><h4 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h4><p>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。<br>基于 TransactionProxyFactoryBean 的声明式事务管理<br>基于 @Transactional 的声明式事务管理<br>基于 Aspectj AOP 配置事务</p><h4 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h4><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><p>脏读：一个事务读到另一个事务未提交的更新数据。</p><p>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p><p>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</p><h4 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h4><p>Spring MVC运行流程图：</p><p>Spring MVC运行描述：</p><ol><li><p>用户发送请求至前端控制器DispatcherServlet</p></li><li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p></li><li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p></li><li><p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p></li><li><p>HandlerAdapter执行处理器(handler，也叫后端控制器)。</p></li><li><p>Controller执行完成返回ModelAndView</p></li><li><p>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</p></li><li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p></li><li><p>ViewReslover解析后返回具体View对象</p></li><li><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p></li><li><p>DispatcherServlet响应用户</p><p>​    </p></li></ol><h4 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h4><p>Spring MVC的核心组件：</p><p>DispatcherServlet：中央控制器，把请求给转发到具体的控制类<br>Controller：具体处理请求的控制器<br>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略<br>ModelAndView：服务层返回的数据和视图层的封装类<br>ViewResolver：视图解析器，解析具体的视图<br>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</p><h4 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h4><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。</p><p>value， method：</p><p>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method：指定请求的method类型， GET、POST、PUT、DELETE等；<br>consumes，produces<br>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；<br>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>params，headers</p><p>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h4 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h4><p>《@Autowired用法详解》：blog.csdn.net/u013257679/article/details/52295106</p><h2 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot / Spring Cloud"></a>Spring Boot / Spring Cloud</h2><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h4 id="mybatis-中-和-的区别是什么？"><a href="#mybatis-中-和-的区别是什么？" class="headerlink" title="mybatis 中 #{}和 ${}的区别是什么？"></a>mybatis 中 #{}和 ${}的区别是什么？</h4><p>${}是字符串替换；#{}是预编译处理。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理${}时，就是把${}替换成变量的值；<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h4 id="mybatis-有几种分页方式？"><a href="#mybatis-有几种分页方式？" class="headerlink" title="mybatis 有几种分页方式？"></a>mybatis 有几种分页方式？</h4><p>数组分页<br>sql分页<br>拦截器分页<br>RowBounds分页</p><h4 id="mybatis-逻辑分页和物理分页的区别是什么？"><a href="#mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="mybatis 逻辑分页和物理分页的区别是什么？"></a>mybatis 逻辑分页和物理分页的区别是什么？</h4><p>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。<br>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</p><h4 id="mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>mybatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h4 id="说一下-mybatis-的一级缓存和二级缓存？"><a href="#说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="说一下 mybatis 的一级缓存和二级缓存？"></a>说一下 mybatis 的一级缓存和二级缓存？</h4><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 </p><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ； </cache></p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p><h4 id="mybatis-和-hibernate-的区别有哪些？"><a href="#mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="mybatis 和 hibernate 的区别有哪些？"></a>mybatis 和 hibernate 的区别有哪些？</h4><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p><p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p><p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </p><h4 id="mybatis-有哪些执行器（Executor）？"><a href="#mybatis-有哪些执行器（Executor）？" class="headerlink" title="mybatis 有哪些执行器（Executor）？"></a>mybatis 有哪些执行器（Executor）？</h4><p>Mybatis有三种基本的执行器（Executor）：</p><p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。<br>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><h4 id="mybatis-分页插件的实现原理是什么？"><a href="#mybatis-分页插件的实现原理是什么？" class="headerlink" title="mybatis 分页插件的实现原理是什么？"></a>mybatis 分页插件的实现原理是什么？</h4><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><h4 id="mybatis-如何编写一个自定义插件？"><a href="#mybatis-如何编写一个自定义插件？" class="headerlink" title="mybatis 如何编写一个自定义插件？"></a>mybatis 如何编写一个自定义插件？</h4><p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p><p>  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p><p>Executor：拦截执行器的方法(log记录)<br>StatementHandler ：拦截Sql语法构建的处理<br>ParameterHandler ：拦截参数的处理<br>ResultSetHandler ：拦截结果集的处理<br>Mybatis自定义插件必须实现Interceptor接口：</p><p>public interface Interceptor {<br>    Object intercept(Invocation invocation) throws Throwable;<br>    Object plugin(Object target);<br>    void setProperties(Properties properties);<br>}<br>intercept方法：拦截器具体处理逻辑方法 </p><p>plugin方法：根据签名signatureMap生成动态代理对象 </p><p>setProperties方法：设置Properties属性 </p><p>自定义插件demo：</p><p>// ExamplePlugin.java<br>@Intercepts({@Signature(<br>  type= Executor.class,<br>  method = “update”,<br>  args = {MappedStatement.class,Object.class})})<br>public class ExamplePlugin implements Interceptor {<br>  public Object intercept(Invocation invocation) throws Throwable {<br>  Object target = invocation.getTarget(); //被代理对象<br>  Method method = invocation.getMethod(); //代理方法<br>  Object[] args = invocation.getArgs(); //方法参数<br>  // do something …… 方法拦截前执行代码块<br>  Object result = invocation.proceed();<br>  // do something …….方法拦截后执行代码块<br>  return result;<br>  }<br>  public Object plugin(Object target) {<br>    return Plugin.wrap(target, this);<br>  }<br>  public void setProperties(Properties properties) {<br>  }<br>}</p><p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： </p><p>type：表示拦截的类，这里是Executor的实现类；<br>method：表示拦截的方法，这里是拦截Executor的update方法；<br>args：表示方法参数。</p><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><h4 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h4><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。</p><h4 id="一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了1条数据，此时-id-是几？"><a href="#一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了1条数据，此时-id-是几？" class="headerlink" title="一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？"></a>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？</h4><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 8。并没有变化</p><h4 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p><h4 id="说一下-ACID-是什么？"><a href="#说一下-ACID-是什么？" class="headerlink" title="说一下 ACID 是什么？"></a>说一下 ACID 是什么？</h4><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h4 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h4><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p><p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p><p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p><p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p><h4 id="float-和-double-的区别是什么？"><a href="#float-和-double-的区别是什么？" class="headerlink" title="float 和 double 的区别是什么？"></a>float 和 double 的区别是什么？</h4><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p><h4 id="mysql-的内连接、左连接、右连接有什么区别？"><a href="#mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="mysql 的内连接、左连接、右连接有什么区别？"></a>mysql 的内连接、左连接、右连接有什么区别？</h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p><p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p><h4 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p><p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p><h4 id="怎么验证-mysql-的索引是否满足需求？"><a href="#怎么验证-mysql-的索引是否满足需求？" class="headerlink" title="怎么验证 mysql 的索引是否满足需求？"></a>怎么验证 mysql 的索引是否满足需求？</h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p><p>explain 语法：explain select * from table where type=1。</p><h4 id="说一下数据库的事务隔离？"><a href="#说一下数据库的事务隔离？" class="headerlink" title="说一下数据库的事务隔离？"></a>说一下数据库的事务隔离？</h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h4 id="说一下-mysql-常用的引擎？"><a href="#说一下-mysql-常用的引擎？" class="headerlink" title="说一下 mysql 常用的引擎？"></a>说一下 mysql 常用的引擎？</h4><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p><p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p><h4 id="说一下-mysql-的行锁和表锁？"><a href="#说一下-mysql-的行锁和表锁？" class="headerlink" title="说一下 mysql 的行锁和表锁？"></a>说一下 mysql 的行锁和表锁？</h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p><h4 id="说一下乐观锁和悲观锁？"><a href="#说一下乐观锁和悲观锁？" class="headerlink" title="说一下乐观锁和悲观锁？"></a>说一下乐观锁和悲观锁？</h4><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p><p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p><h4 id="mysql-问题排查都有哪些手段？"><a href="#mysql-问题排查都有哪些手段？" class="headerlink" title="mysql 问题排查都有哪些手段？"></a>mysql 问题排查都有哪些手段？</h4><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p><h4 id="如何做-mysql-的性能优化？"><a href="#如何做-mysql-的性能优化？" class="headerlink" title="如何做 mysql 的性能优化？"></a>如何做 mysql 的性能优化？</h4><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。<br>选择正确的存储引擎。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h4 id="redis-是什么？"><a href="#redis-是什么？" class="headerlink" title="redis 是什么？"></a>redis 是什么？</h4><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><h4 id="redis-有哪些使用场景"><a href="#redis-有哪些使用场景" class="headerlink" title="redis 有哪些使用场景"></a>redis 有哪些使用场景</h4><p>数据高并发的读写<br>海量数据的读写<br>对扩展性要求高的数据</p><h4 id="redis-有哪些功能？"><a href="#redis-有哪些功能？" class="headerlink" title="redis 有哪些功能？"></a>redis 有哪些功能？</h4><p>数据缓存功能<br>分布式锁的功能<br>支持数据持久化<br>支持事务<br>支持消息队列</p><h4 id="redis-和-memecache-的区别？"><a href="#redis-和-memecache-的区别？" class="headerlink" title="redis 和 memecache 的区别？"></a>redis 和 memecache 的区别？</h4><p>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>redis的速度比memcached快很多<br>redis可以持久化其数据</p><h4 id="redis-为什么是单线程的？"><a href="#redis-为什么是单线程的？" class="headerlink" title="redis 为什么是单线程的？"></a>redis 为什么是单线程的？</h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p><p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p><p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p><h4 id="什么是缓存穿透？怎么解决？"><a href="#什么是缓存穿透？怎么解决？" class="headerlink" title="什么是缓存穿透？怎么解决？"></a>什么是缓存穿透？怎么解决？</h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p><p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><h4 id="redis-支持的数据类型有哪些？"><a href="#redis-支持的数据类型有哪些？" class="headerlink" title="redis 支持的数据类型有哪些？"></a>redis 支持的数据类型有哪些？</h4><p>string、list、hash、set、zset。</p><h4 id="redis-支持哪些-java-客户端？"><a href="#redis-支持哪些-java-客户端？" class="headerlink" title="redis 支持哪些 java 客户端？"></a>redis 支持哪些 java 客户端？</h4><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h4 id="jedis-和-redisson-有哪些区别？"><a href="#jedis-和-redisson-有哪些区别？" class="headerlink" title="jedis 和 redisson 有哪些区别？"></a>jedis 和 redisson 有哪些区别？</h4><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h4 id="redis缓存和数据库数据的一致性？"><a href="#redis缓存和数据库数据的一致性？" class="headerlink" title="redis缓存和数据库数据的一致性？"></a>redis缓存和数据库数据的一致性？</h4><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p><h4 id="redis-持久化有几种方式？"><a href="#redis-持久化有几种方式？" class="headerlink" title="redis 持久化有几种方式？"></a>redis 持久化有几种方式？</h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p><p>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</p><p>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p><h4 id="redis-怎么实现分布式锁？"><a href="#redis-怎么实现分布式锁？" class="headerlink" title="redis 怎么实现分布式锁？"></a>redis 怎么实现分布式锁？</h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p><p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p><h4 id="redis-分布式锁有什么缺陷？"><a href="#redis-分布式锁有什么缺陷？" class="headerlink" title="redis 分布式锁有什么缺陷？"></a>redis 分布式锁有什么缺陷？</h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p><h4 id="redis-如何做内存优化？"><a href="#redis-如何做内存优化？" class="headerlink" title="redis 如何做内存优化？"></a>redis 如何做内存优化？</h4><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 </p><p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p><h4 id="redis-淘汰策略有哪些？"><a href="#redis-淘汰策略有哪些？" class="headerlink" title="redis 淘汰策略有哪些？"></a>redis 淘汰策略有哪些？</h4><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p><p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p><p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p><p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p><p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。</p><h4 id="redis-常见的性能问题有哪些？"><a href="#redis-常见的性能问题有哪些？" class="headerlink" title="redis 常见的性能问题有哪些？"></a>redis 常见的性能问题有哪些？</h4><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h4 id="zookeeper-是什么？"><a href="#zookeeper-是什么？" class="headerlink" title="zookeeper 是什么？"></a>zookeeper 是什么？</h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h4 id="zookeeper-都有哪些功能？"><a href="#zookeeper-都有哪些功能？" class="headerlink" title="zookeeper 都有哪些功能？"></a>zookeeper 都有哪些功能？</h4><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p><h4 id="说一下-zookeeper-的通知机制？"><a href="#说一下-zookeeper-的通知机制？" class="headerlink" title="说一下 zookeeper 的通知机制？"></a>说一下 zookeeper 的通知机制？</h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p><h4 id="zookeeper-有几种部署模式？"><a href="#zookeeper-有几种部署模式？" class="headerlink" title="zookeeper 有几种部署模式？"></a>zookeeper 有几种部署模式？</h4><p>zookeeper 有三种部署模式：</p><p>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p><h4 id="zookeeper-怎么保证主从节点的状态同步？"><a href="#zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="zookeeper 怎么保证主从节点的状态同步？"></a>zookeeper 怎么保证主从节点的状态同步？</h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p><h4 id="集群中为什么要有主节点？"><a href="#集群中为什么要有主节点？" class="headerlink" title="集群中为什么要有主节点？"></a>集群中为什么要有主节点？</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p><h4 id="集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="jvm的主要组成部分和作用？"><a href="#jvm的主要组成部分和作用？" class="headerlink" title="jvm的主要组成部分和作用？"></a>jvm的主要组成部分和作用？</h4><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）</p><p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h4 id="jvm-运行时数据区？"><a href="#jvm-运行时数据区？" class="headerlink" title="jvm 运行时数据区？"></a>jvm 运行时数据区？</h4><p>程序计数器<br>虚拟机栈<br>本地方法栈<br>堆<br>方法区</p><p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p><h4 id="堆栈的区别？"><a href="#堆栈的区别？" class="headerlink" title="堆栈的区别？"></a>堆栈的区别？</h4><p>栈内存存储的是局部变量而堆内存存储的是实体；</p><p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p><p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p><h4 id="队列和栈是什么？有什么区别？"><a href="#队列和栈是什么？有什么区别？" class="headerlink" title="队列和栈是什么？有什么区别？"></a>队列和栈是什么？有什么区别？</h4><p>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p><h4 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p>类加载器分类：</p><p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载<java_home style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;">\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home><br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><h4 id="说一下类加载的执行过程？"><a href="#说一下类加载的执行过程？" class="headerlink" title="说一下类加载的执行过程？"></a>说一下类加载的执行过程？</h4><p>类加载分为以下 5 个步骤：</p><p>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p><h4 id="怎么判断对象是否可以被回收？"><a href="#怎么判断对象是否可以被回收？" class="headerlink" title="怎么判断对象是否可以被回收？"></a>怎么判断对象是否可以被回收？</h4><p>一般有两种方法来判断：</p><p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p><h4 id="java-中都有哪些引用类型？"><a href="#java-中都有哪些引用类型？" class="headerlink" title="java 中都有哪些引用类型？"></a>java 中都有哪些引用类型？</h4><p>强引用<br>软引用<br>弱引用<br>虚引用（幽灵引用/幻影引用）</p><h4 id="说一下-jvm-有哪些垃圾回收算法？"><a href="#说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="说一下 jvm 有哪些垃圾回收算法？"></a>说一下 jvm 有哪些垃圾回收算法？</h4><p>标记-清除算法<br>标记-整理算法<br>复制算法<br>分代算法</p><h4 id="说一下-jvm-有哪些垃圾回收器？"><a href="#说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="说一下 jvm 有哪些垃圾回收器？"></a>说一下 jvm 有哪些垃圾回收器？</h4><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p><h4 id="详细介绍一下-CMS-垃圾回收器？"><a href="#详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="详细介绍一下 CMS 垃圾回收器？"></a>详细介绍一下 CMS 垃圾回收器？</h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h4 id="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1</p><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h4 id="简述分代垃圾回收器怎么工作的？"><a href="#简述分代垃圾回收器怎么工作的？" class="headerlink" title="简述分代垃圾回收器怎么工作的？"></a>简述分代垃圾回收器怎么工作的？</h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p><p> 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><p> 把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h4 id="说一下-jvm-调优的工具？"><a href="#说一下-jvm-调优的工具？" class="headerlink" title="说一下 jvm 调优的工具？"></a>说一下 jvm 调优的工具？</h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p><h4 id="常用的-jvm-调优的参数都有哪些？"><a href="#常用的-jvm-调优的参数都有哪些？" class="headerlink" title="常用的 jvm 调优的参数都有哪些？"></a>常用的 jvm 调优的参数都有哪些？</h4><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p><h2 id="程序优化"><a href="#程序优化" class="headerlink" title="程序优化"></a>程序优化</h2><h4 id="慎用异常"><a href="#慎用异常" class="headerlink" title="慎用异常"></a>慎用异常</h4><p>try-catch不要放在循环中，尽量把try-catsh放到循环体外来提升性能。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用局部环境"><a href="#使用局部环境" class="headerlink" title="使用局部环境"></a>使用局部环境</h4><p>局部变量的访问速度高于类的成员变量。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//  private static int a = 0;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="位运算代替乘除法"><a href="#位运算代替乘除法" class="headerlink" title="位运算代替乘除法"></a>位运算代替乘除法</h4><p>HashMap的源码中使用了位运算，a*=2和a/=2，用位运算可以写为a&lt;&lt;=1，a&gt;&gt;=1</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> develop frame summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/2017/09/02/hello-world/"/>
      <url>/2017/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to the Hexo documentation. If you encounter any problems when using Hexo, have a look at the <a href="https://hexo.io/docs/troubleshooting" target="_blank" rel="noopener">troubleshooting guide</a>, raise an issue on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a> or start a topic on the <a href="https://groups.google.com/group/hexo" target="_blank" rel="noopener">Google Group</a>.</p><h2 id="What-is-Hexo"><a href="#What-is-Hexo" class="headerlink" title="What is Hexo?"></a>What is Hexo?</h2><p>Hexo is a fast, simple and powerful blog framework. You write posts in <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.<a id="more"></a></p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>It only takes a few minutes to set up Hexo. If you encounter a problem and can’t find the solution here, please <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">submit a GitHub issue</a> and we’ll help.</p><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>Installing Hexo is quite easy and only requires the following beforehand:</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Should be at least Node.js 8.10, recommends 10.0 or higher)</li><li><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>If your computer already has these, congratulations! You can skip to the <a href="https://hexo.io/docs/index.html#Install-Hexo" target="_blank" rel="noopener">Hexo installation</a> step.</p><p>If not, please follow the following instructions to install all the requirements.</p><h3 id="Install-Git"><a href="#Install-Git" class="headerlink" title="Install Git"></a>Install Git</h3><ul><li>Windows: Download &amp; install <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac: Install it with <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> or <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">installer</a>.</li><li>Linux (Ubuntu, Debian): <code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS): <code>sudo yum install git-core</code></li></ul><blockquote><p>For Mac users</p><p>You may encounter some problems when compiling. Please install Xcode from App Store first. After Xcode is installed, open Xcode and go to <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> to install command line tools.</p></blockquote><h3 id="Install-Node-js"><a href="#Install-Node-js" class="headerlink" title="Install Node.js"></a>Install Node.js</h3><p>Node.js provides <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">official installer</a> for most platforms.</p><p>Alternative installation methods:</p><ul><li>Windows: Install it with <a href="https://github.com/jasongin/nvs/" target="_blank" rel="noopener">nvs</a> (recommended) or <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a>.</li><li>Mac: Install it with <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> or <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a>.</li><li>Linux (DEB/RPM-based): Install it with <a href="https://github.com/nodesource/distributions" target="_blank" rel="noopener">NodeSource</a>.</li><li>Others: Install it through respective package manager. Refer to <a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="noopener">the guide</a> provided by Node.js.</li></ul><p>nvs is also recommended for Mac and Linux to avoid possible permission issue.</p><blockquote><p>Windows</p><p>If you use the official installer, make sure <strong>Add to PATH</strong> is checked (it’s checked by default).</p></blockquote><blockquote><p>Mac / Linux</p><p>If you encounter <code>EACCES</code> permission error when trying to install Hexo, please follow <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">the workaround</a> provided by npmjs; overriding with root/sudo is highly discouraged.</p></blockquote><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><p>Once all the requirements are installed, you can install Hexo with npm:</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="Advanced-installation-and-usage"><a href="#Advanced-installation-and-usage" class="headerlink" title="Advanced installation and usage"></a>Advanced installation and usage</h3><p>Advanced users may prefer to install and use <code>hexo</code> package instead.</p><pre><code>$ npm install hexo</code></pre><p>Once installed, you can run Hexo in two ways:</p><ol><li><p><code>npx hexo &lt;command&gt;</code></p></li><li><p>Linux users can set relative path of <code>node_modules/</code> folder:</p><pre><code>echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
